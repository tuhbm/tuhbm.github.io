{"meta":{"title":"코드머니 플레이북","subtitle":"","description":"개발자로 공부한내용 & 살아가며 취득한 정보 전달 & 책을 읽고 느낀 리뷰 & 개인적으로 느낀 점을을 칼럼으로 작성하였습니다.","author":"Taekyun Kim","url":"https://tuhbm.github.io"},"pages":[{"title":"보고 배우는 개발자 김태균입니다","date":"2018-02-17T19:47:47.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"about/index.html","permalink":"https://tuhbm.github.io/about/index.html","excerpt":"","text":"블로그의 시작이 블로그는 제가 공부하고 익인 내용을 정리하기 위해 시작하였습니다.비전공자로 시작한 개발….어려운만큼 저와 같은 분이 많을 것이라 생각이 됩니다.블로그를 통해 지속적으로 공부하는 내용을 정리해서보다 쉽게 포스팅하여 정보공유의 노력도 함께 하겠습니다. 주요 내용 HTML CSS JavaScript Column Java 기타언어들.. 등등…"}],"posts":[{"title":"한국, 왜 지금 ‘핵추진잠수함’인가 -도입 계기·맞교환 구조·향후 과제 쉽게 정리","slug":"nuclearSubmarine","date":"2025-10-31T01:00:00.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2025/10/31/nuclearSubmarine/","link":"","permalink":"https://tuhbm.github.io/2025/10/31/nuclearSubmarine/","excerpt":"한줄 요약한미 정상 간 패키지 딜(안보+경제 맞교환)**이 매듭지어지며, 한국의 오랜 숙원인 **핵추진잠수함(SSN)**이 본궤도에 올랐습니다.핵심은 **왜 지금이냐인데, 답은 세 가지입니다. ① 정상 간 빅딜, ② 미국 조선소(필라델피아)와 연계된 산업 협력, ③ 북·중 변수로 커진 지속 잠항 전력 수요. (워싱턴포스트/로이터/Breaking Defense 보도 종합)","text":"한줄 요약한미 정상 간 패키지 딜(안보+경제 맞교환)**이 매듭지어지며, 한국의 오랜 숙원인 **핵추진잠수함(SSN)**이 본궤도에 올랐습니다.핵심은 **왜 지금이냐인데, 답은 세 가지입니다. ① 정상 간 빅딜, ② 미국 조선소(필라델피아)와 연계된 산업 협력, ③ 북·중 변수로 커진 지속 잠항 전력 수요. (워싱턴포스트/로이터/Breaking Defense 보도 종합) 1) 이번에 ‘급물살’ 탄 직접 계기1-1. 정상 간 패키지 딜(맞교환) 핵심: 한국의 핵추진잠수함 건조 승인 발표와 함께 관세·투자·에너지가 묶인 패키지 성격이 부각됐습니다. 의미: 안보(잠수함)와 경제(투자·일감·에너지)가 같은 테이블에서 오간 드문 사례로, 한국은 핵심 전력, 미국은 산업·고용·동맹 분담 확대를 확보. 1-2. 필라델피아 조선소 ‘현지 건조’ 카드 무대: 미국 필라델피아 조선소(Philly Shipyard) 활용 시나리오가 공개 언급. 의미: 미국은 일감·인력 양성을, 한국은 전력화 속도·생태계 업그레이드를 얻는 동맹형 산업 패키지에 가깝습니다. 1-3. 안보 환경의 압박(북·중·러 변수) 북한: SLBM 등으로 바다 아래 장기 억제 수요가 급증. 중국/러시아: 주변 해역 활동 확대 → 원해(먼바다) 장시간 추적·감시 전력 필요. 2) 왜 ‘지금’인가: 정책 창(Policy Window)이 열린 이유 선행 투자·기술 축적 KSS-III(디젤/AIP)로 설계·건조 경험을 쌓으며, 마지막 정치·외교 문턱만 남은 상태였음. AUKUS 이후의 ‘전례’ AUKUS(미국·영국·호주가 안보·군사 기술을 함께 나누는 약속)로 해군 원자력 추진 공유의 전례가 생김. 한국은 한미 양자 트랙에서 유사한 정책 창을 포착. 미국 산업·동맹 관리 필요 미 해군 조선 능력·인력의 병목을 동맹 투자·일감으로 완화하고, 동시에 역내 억제 아키텍처를 강화. 3) 이번 결정, 무엇을 ‘맞바꿨나’ 한국이 얻는 것 장시간 잠항 기반 원해 억제력 조선·원전·소재·정비·소음저감·SW 인증 등 고부가 밸류체인 확대 연합작전에서 전략적 지분 상승 미국이 얻는 것 자국 조선소 일감·일자리(필라델피아) 인도·태평양 동맹 분담 확대 AUKUS 병행 속 해양질서 주도권 유지 4) 주변국·국내 반응 요약 호주: “AUKUS 계획은 차질 없다” → 한국 건은 미국의 별도 양자 딜로 선 긋기. 일본: 한국 SSN 보유 시 안보 지형 변화와 자국 내 핵추진 논의 재점화 가능성에 촉각. 중국: 비확산·군비경쟁 우려 제기. 북한: “위협” 프레임으로 도발 명분 활용 가능. 한국 내부: 찬성: 대잠·정찰 강화, 연합작전 기여, 산업 파급 우려: 비확산·외교 부담, 예산·일정 리스크, 사용후핵연료 관리 5) 어려운 용어 정리 AUKUS(아우커스) → 미·영·호가 군사·기술을 함께 나누는 약속. 호주는 여기서 핵추진잠수함을 들여옵니다. SSN(핵추진잠수함) → 원자로를 엔진처럼 써서 오래 잠수하는 잠수함. 핵무장을 뜻하지 않음(무장은 재래식). SSBN(핵무장잠수함) → 핵탄두를 싣는 전략잠수함. 한국 논의와 다른 개념. 비확산(NPT)/IAEA → 핵무기 확산을 막는 국제 규칙(NPT) / 핵 물질을 감시하는 국제기구(IAEA). 연료가 무기로 새지 않게 관리. 6) 앞으로의 관건(정치는 ‘OK’, 기술·법은 ‘진행형’) 연료 모델 확정(HEU/LEU): 비확산 부담 vs 설계·정비 난이도 법·절차: 한미 원자력협정 부속 합의, IAEA 감시·환수 체계 기술 이전 범위: 추진 원자로·저소음/진동·핵심 부품의 민감선 설정 산업 병목 해소: 미국 도크·인력 포화와 일정 조율 전략 커뮤니케이션: “핵무장이 아니라 핵추진” 메시지의 일관·반복 7) 10년 로드맵(가상 시나리오) 2026~2028: 연료·법·감시 설계 확정 / 운용·정비 인력 양성 2029~2032: 선체–원자로 통합 설계·건조, 정비 인프라 구축 2033~2035: 시운전 → 초기 전력화(정치·기술 변수에 따라 변동 가능) 참고 출처 Washington Post — US will share tech to let South Korea build a nuclear-powered submarine, Trump says (2025-10-29) Reuters — Trump says South Korea has approval to build nuclear-powered submarine (2025-10-29) Defense News — US will share tech to let South Korea build a nuclear submarine, Trump says (2025-10-29) Breaking Defense — Trump: US to share nuclear sub tech with S. Korea; build boats in Philly (2025-10-30) Breaking Defense — South Korea’s 30-year quest for nuclear submarines pays off (2025-10-31) ABC News (Australia) — Albanese confident on AUKUS despite US–Korea submarine pledge (2025-10-30) The Japan Times — South Korea to build nuclear-powered subs in U.S., Trump says (2025-10-30) The War Zone — South Korea’s Nuclear Submarine Ambitions Take Major Step Forward (2025-10-31)","categories":[{"name":"국제","slug":"국제","permalink":"https://tuhbm.github.io/categories/%EA%B5%AD%EC%A0%9C/"}],"tags":[{"name":"핵추진잠수함","slug":"핵추진잠수함","permalink":"https://tuhbm.github.io/tags/%ED%95%B5%EC%B6%94%EC%A7%84%EC%9E%A0%EC%88%98%ED%95%A8/"},{"name":"SSN","slug":"SSN","permalink":"https://tuhbm.github.io/tags/SSN/"},{"name":"AUKUS","slug":"AUKUS","permalink":"https://tuhbm.github.io/tags/AUKUS/"},{"name":"비확산","slug":"비확산","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%ED%99%95%EC%82%B0/"},{"name":"한미정상회담","slug":"한미정상회담","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%EB%AF%B8%EC%A0%95%EC%83%81%ED%9A%8C%EB%8B%B4/"},{"name":"필라델피아조선소","slug":"필라델피아조선소","permalink":"https://tuhbm.github.io/tags/%ED%95%84%EB%9D%BC%EB%8D%B8%ED%94%BC%EC%95%84%EC%A1%B0%EC%84%A0%EC%86%8C/"}]},{"title":"2025년 한미 정상회담, 쉬운 총정리","slug":"usaAndKoreaMeeting","date":"2025-10-30T03:00:00.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2025/10/30/usaAndKoreaMeeting/","link":"","permalink":"https://tuhbm.github.io/2025/10/30/usaAndKoreaMeeting/","excerpt":"한 문장 요약“비행기 대량 구매 + 미국산 가스(LNG) 장기 도입 + 해군력(핵추진 잠수함) 업그레이드 논의.”당장은 경기/수급 안정에 보탬이지만, 돈과 시간, 대중(對中) 관계 관리라는 과제도 함께 생겼습니다. 핵심만 3가지","text":"한 문장 요약“비행기 대량 구매 + 미국산 가스(LNG) 장기 도입 + 해군력(핵추진 잠수함) 업그레이드 논의.”당장은 경기/수급 안정에 보탬이지만, 돈과 시간, 대중(對中) 관계 관리라는 과제도 함께 생겼습니다. 핵심만 3가지 항공: 대한항공의 초대형 기단 교체가 발표되었습니다. 정비(MRO)·부품·일자리로 파급이 예상됩니다. 에너지(LNG): 한국가스공사가 연 330만 톤 규모의 미국산 LNG를 장기 도입하기로 했습니다(본격 물량은 2028년 이후). 가격 급등 시 버틸 힘을 키우는 효과가 있습니다. 안보(해군력): 핵추진 잠수함(SSN) 관련 협력 의지가 공개적으로 확인되었습니다. 기술·예산·시간이 많이 드는 장기 과제입니다. 어려운 용어, 한 줄 요약 핵추진 잠수함(SSN): 원자로로 움직여 오래, 멀리 작전 가능한 잠수함(핵무기 탑재와는 별개 개념). LNG: 액화천연가스. 배로 대량 운송하며 전력·난방 연료로 사용. (참고) AUKUS: 미·영·호의 안보협력 틀. 한국의 핵잠 논의가 바다에서의 억지력 강화라는 큰 흐름과 맞물려 언급됩니다. 한국: 뭐가 좋고, 뭐가 걱정일까?장점(Pros) 산업 파급: 대규모 기단 교체는 정비·부품 국산화 기회로 이어질 수 있습니다. 에너지 안심: 미국산 LNG 장기 계약으로 공급 안정성·가격 변동성 완충 기대. 해군력 업그레이드 기대: 원해작전·대잠수함 역량 강화의 로드맵이 가시화. 단점(Cons) 돈과 시간: 핵추진 잠수함은 연료·원자로·조선소·인력 등 전 주기 투자가 필요해 정책·예산 논의가 길어질 수 있습니다. 대중(對中) 균형: 미국과의 협력이 커질수록 대중 교역·투자 균형 관리가 더 까다로워질 수 있습니다. 재정 우선순위: 방산·에너지·인프라 대형 프로젝트가 동시다발로 진행되면 예산 배분 논쟁이 커집니다. 미국: 득실 간단 정리장점 수출·일자리 확대: 항공·에너지 등 제조·에너지 수출이 늘고 지역 일자리에 보탬. 해양 억지력 강화: 동맹과 함께 인도·태평양의 바다에서 영향력 확대. 단점 기술 확산 논쟁: 핵추진 관련 지원은 비확산(Non-proliferation) 우려를 자극할 수 있음. 정치·절차 리스크: 의회 심사·예산·절차 문제로 속도가 지연될 가능성. 이번 회담이 시장과 일상에 주는 신호 단기(1~3개월): 항공·정비, LNG 인프라, 해양·방산 관련 업종에 관심이 몰릴 수 있습니다. 중기(6~12개월): 핵잠 로드맵(연료·조선소·인력) 구체화 공표 여부 LNG 저장·배관·터미널 증설 계획 공개 시점 보잉 오프셋/부품 현지화 진척(“우리 일감” 확대) 방위비·동맹 분담에 대한 국내 합의 형성 속도 질문에 바로 답하기(FAQ)Q1. 핵추진이면 핵무기 보유로 이어지나요?A. 아닙니다. ‘핵추진’은 동력 방식입니다. 무기 탑재 여부와는 다른 문제입니다. Q2. LNG를 오래 사두면 손해일 수도 있나요?A. 가격이 내려가면 아쉬울 수 있지만, 공급이 불안정할 때 버틸 힘을 확보하는 보험 성격이 있습니다. Q3. 당장 체감할 변화는요?A. 비행기 도입은 비교적 빨리 정비·부품 수요로 이어집니다. 핵잠은 장기 과제라 단계별 뉴스가 이어질 전망입니다. 12개월 전망: 세 가지 시나리오 완만한 호전(유력) 항공·에너지 계약 이행, 핵잠은 설계·예산 단계. 제조·인프라·방산 일부 종목 견조. 리밸런싱(중간) 대외 변수로 수출 회복이 더디면 정부가 방산·에너지 인프라에 재정 투입 확대. 롤러코스터(낮음~중간) 핵잠·대외정치 이슈로 일정 지연/재조정 → 원화·증시 변동성 확대. 참고·출처(클릭 이동) 트럼프 방한·의전·무역 합의 개요 The Washington Post (2025-10-29): https://www.washingtonpost.com/politics/2025/10/29/trump-apec-south-korea/ The Guardian (2025-10-29): https://www.theguardian.com/world/2025/oct/29/trump-heads-to-south-korea-amid-deadlocked-trade-talks-over-350bn-deal-on-tariffs 핵추진 잠수함 관련 승인·지지 발언 The Washington Post (2025-10-29): https://www.washingtonpost.com/world/2025/10/29/trump-south-korea-nuclear-submarine/ The Guardian (2025-10-30): https://www.theguardian.com/world/2025/oct/30/trump-gives-south-korea-permission-to-build-nuclear-powered-submarine ABC News (2025-10-30): https://www.abc.net.au/news/2025-10-30/south-korea-permission-to-build-nuclear-submarines/105951210 The Japan Times (2025-10-30): https://www.japantimes.co.jp/news/2025/10/30/asia-pacific/south-korea-us-nuclear-powered-submarines/ 항공기 103대 계약 Boeing 보도자료 (2025-08-25): https://investors.boeing.com/investors/news/press-release-details/2025/Korean-Air-Commits-to-Record-Purchase-of-103-Boeing-Jets-to-Modernize-Fleet/default.aspx Chosun English (2025-10-30): https://www.chosun.com/english/world-en/2025/10/30/GDZ6OL5NJNHT5KJWKR4OE6H6EU/ LNG 330만 톤 장기 도입 Korea JoongAng Daily (2025-08-26): https://koreajoongangdaily.joins.com/news/2025-08-26/business/industry/Korea-to-buy-33-million-tons-of-US-LNG-annually-for-10-yrs-from-2028/2384445","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"}],"tags":[{"name":"한미정상회담","slug":"한미정상회담","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%EB%AF%B8%EC%A0%95%EC%83%81%ED%9A%8C%EB%8B%B4/"},{"name":"트럼프","slug":"트럼프","permalink":"https://tuhbm.github.io/tags/%ED%8A%B8%EB%9F%BC%ED%94%84/"},{"name":"이재명","slug":"이재명","permalink":"https://tuhbm.github.io/tags/%EC%9D%B4%EC%9E%AC%EB%AA%85/"},{"name":"항공산업","slug":"항공산업","permalink":"https://tuhbm.github.io/tags/%ED%95%AD%EA%B3%B5%EC%82%B0%EC%97%85/"},{"name":"LNG","slug":"LNG","permalink":"https://tuhbm.github.io/tags/LNG/"},{"name":"안보정책","slug":"안보정책","permalink":"https://tuhbm.github.io/tags/%EC%95%88%EB%B3%B4%EC%A0%95%EC%B1%85/"},{"name":"한국전망","slug":"한국전망","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%EA%B5%AD%EC%A0%84%EB%A7%9D/"}]},{"title":"십만전자 시대 개막 — 삼성전자 10만원 돌파가 의미하는 것","slug":"sam_10","date":"2025-10-28T17:23:15.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2025/10/28/sam_10/","link":"","permalink":"https://tuhbm.github.io/2025/10/28/sam_10/","excerpt":"십만전자 시대 개막 — 삼성전자 10만원 돌파가 의미하는 것 한 줄 요약: 삼성전자 주가가 사상 처음 10만원을 상회하며 이른바 ‘십만전자’가 현실화되었습니다. 같은 시기 코스피도 장중 4000선을 터치하며 대형주 중심 장세가 강화됐습니다. 왜 지금 ‘십만전자’인가","text":"십만전자 시대 개막 — 삼성전자 10만원 돌파가 의미하는 것 한 줄 요약: 삼성전자 주가가 사상 처음 10만원을 상회하며 이른바 ‘십만전자’가 현실화되었습니다. 같은 시기 코스피도 장중 4000선을 터치하며 대형주 중심 장세가 강화됐습니다. 왜 지금 ‘십만전자’인가 반도체 업사이클 회복 기대: AI 서버/데이터센터 수요 확대, 메모리 가격 반등, 파운드리 수주 회복 전망이 겹쳤습니다. 수급 호재: 외국인·기관 동시 매수세가 시총 상위주로 유입되며 지수를 견인했습니다. 이벤트 모멘텀: 분기 실적 시즌, 제품 믹스(HBM·DDR5) 개선 기대, 첨단 패키징 경쟁력 이슈 등이 동시 노출됐습니다. 주가 10만원의 5가지 해석 심리적 레벨 돌파 — 10만원은 절대가격이자 상징입니다. 매물 부담을 뚫으며 투자심리가 개선됐습니다. 실적 선반영 구간 — 3~4분기 실적과 가이던스에 대한 프런트러닝이 반영됐을 가능성이 큽니다. AI-메모리 리레이팅 — HBM·서버 DRAM 등 고부가 제품 비중 상승이 멀티플 상향을 유도합니다. 코스피 체급 장세 — 지수 레벨 업 구간에서 대형주 쏠림이 심화되는 전형적 국면입니다. 글로벌 동조화 — 엔비디아·반도체 장비 강세가 메모리·파운드리로 파급되는 흐름입니다. 숫자로 보는 현재 위치 (간단 팩트체크) 돌파 시점: 10월 말 장중 10만원 상회. 마감 레벨: 10만원대 종가 보도가 다수 확인되었습니다. 최근 트렌드: 10월 중순부터 10만원 ‘근접 → 돌파’로 전환된 흐름. 참고: 실시간 호가/체결가는 증권사 HTS/MTS 기준을 따르며, 포털·금융 데이터는 지연 표기될 수 있습니다. 리스크와 반론 사이클 리스크: 메모리 업황은 변동성이 큽니다. ASP 둔화 시 멀티플 재조정 가능성이 있습니다. 공급 증가: 경쟁사 증설·기술 진전(특히 HBM)으로 가격 경쟁이 심화될 수 있습니다. 실적-주가 괴리: 기대가 선반영된 구간에서는 컨퍼런스콜 가이던스가 약할 경우 조정 폭이 커질 수 있습니다. 거시 변수: 금리·환율·수출 규제 등 외생 변수에 민감합니다. Q&amp;AQ. 지금 바로 들어가도 될까요?A. 급등 직후에는 변동성이 큽니다. 계좌 변동성을 낮추려면 시점과 가격을 나눠 분할 접근하시길 권합니다. Q. ‘십만전자’ 다음은 어디를 볼까요?A. 가격 목표보다 실적 레벨업이 중요합니다. HBM 공급, 파운드리 수율, 서버 고객 발주가 실제 이익 상향으로 이어지는지가 핵심입니다. Q. 장기투자자는 무엇을 점검해야 하나요?A. (1) 제품 믹스의 구조적 변화(HBM·패키징), (2) 파운드리 경쟁력 회복, (3) 주주환원 정책의 일관성을 보시기 바랍니다. 마무리 — 다음 관전 포인트 실적 시즌 코멘트: HBM·파운드리 관련 가이던스 톤 수급 포지셔닝: 외국인 매수 지속 여부, 스마트베타/ETF 유입 밸류 리레이팅의 지속성: 멀티플 상향이 마진·현금흐름으로 뒷받침되는지 ‘십만전자’는 출발점일 수 있습니다. 가격이 아니라 사업·실적의 구조 변화를 추적해 주세요. ※ 본 글은 투자 권유가 아니며, 투자 판단의 최종 책임은 투자자 본인에게 있습니다.","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"},{"name":"투자","slug":"경제/투자","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/%ED%88%AC%EC%9E%90/"}],"tags":[{"name":"주식","slug":"주식","permalink":"https://tuhbm.github.io/tags/%EC%A3%BC%EC%8B%9D/"},{"name":"삼성전자","slug":"삼성전자","permalink":"https://tuhbm.github.io/tags/%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90/"},{"name":"반도체","slug":"반도체","permalink":"https://tuhbm.github.io/tags/%EB%B0%98%EB%8F%84%EC%B2%B4/"},{"name":"투자전략","slug":"투자전략","permalink":"https://tuhbm.github.io/tags/%ED%88%AC%EC%9E%90%EC%A0%84%EB%9E%B5/"},{"name":"시장분석","slug":"시장분석","permalink":"https://tuhbm.github.io/tags/%EC%8B%9C%EC%9E%A5%EB%B6%84%EC%84%9D/"}]},{"title":"워런 버핏 투자법, 초보자를 위한 실전 가이드","slug":"buffett","date":"2025-10-27T11:00:00.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2025/10/27/buffett/","link":"","permalink":"https://tuhbm.github.io/2025/10/27/buffett/","excerpt":"한 문장 요약: 좋은 회사를 ‘제값보다 싸게’ 사서 ‘오래’ 보유하되, 내가 이해하는 범위 안에서만 행동하기. 왜 버핏인가 철학의 핵심: 훌륭한 회사를 적정가 이하로 사서 오래 보유 원칙의 힘: 복잡한 기법보다 규칙을 지키는 태도와 **시간(복리)**이 성과를 만든다고 봅니다.","text":"한 문장 요약: 좋은 회사를 ‘제값보다 싸게’ 사서 ‘오래’ 보유하되, 내가 이해하는 범위 안에서만 행동하기. 왜 버핏인가 철학의 핵심: 훌륭한 회사를 적정가 이하로 사서 오래 보유 원칙의 힘: 복잡한 기법보다 규칙을 지키는 태도와 **시간(복리)**이 성과를 만든다고 봅니다. 버핏 철학 한눈에 보기(핵심 8원칙) 이해의 영역: 내가 이해하는 사업만 투자합니다. 모르면 건너뜁니다. 경쟁우위(=경제적 해자): 브랜드, 네트워크, 전환비용처럼 경쟁이 따라오기 어려운 구조. 사업의 체력: 일관된 이익, 높은 자본수익률(ROE), 과도하지 않은 부채. 안전마진: 내재가치보다 의미 있게 싸게 살 여유(보통 20~30%+). 오너 마인드: 주식=사업 지분. 경영진의 자본배분 능력과 윤리를 확인합니다. 장기 복리: 회전율을 낮추고 시간의 편을 듭니다. 단순함·절제: 레버리지 남용 금지, 복잡한 모델보다 상식과 규율. 두 가지 규칙: ① 돈을 잃지 마라 ② 규칙 1을 잊지 마라. 초보자를 위한 버핏식 5단계 실행법1) 이해의 영역 정하기 본업·전공·경험과 맞닿은 산업 2~3개만 고르십시오. 예) IT 인프라 직장인 → 클라우드 도구·반도체 장비 / 약사 → 제약·유통 2) “좋은 회사” 1차 선별(스크리닝 가이드) 10년 매출·영업이익 우상향 ROE 12%+(산업별 탄력적 적용) 부채 과도하지 않음, 이자보상배율 양호 잉여현금흐름(FCF) 안정적·플러스 희석(유상증자/과한 스톡옵션) 남발 없음 팁: 절대치보다 일관성과 추세를 중시하십시오. 3) 대략의 내재가치 계산(아주 단순 버전) 오너이익(Owner Earnings) 감각 익히기영업이익 → 세후이익 → +감가상각 − 유지보수성 CAPEX ≈ 주주에게 남는 현금 보수적 성장률로 5~10년 가정 후 할인(성장은 낮게, 위험은 높게). 비관·기준·낙관 3가지 시나리오 평균을 쓰되 비관에 가중. 4) 안전마진 가격에서만 분할매수 계산한 내재가치 대비 20~30% 이상 할인 구간에서만 매수候補. 3~5회 분할매수로 평균단가를 관리합니다. 5) 보유·점검·기록 분기·연례보고로 ‘사업’ 변화만 점검(주가가 아니라 논리 확인). 매도 트리거 경쟁우위 약화/부채 급증 등 논리 붕괴 고평가로 대체기회가 명확 더 좋은 사업으로의 합리적 교체 버핏식 체크리스트(프린트용)A. 사업·경쟁우위 무엇을 팔며, 고객은 왜 계속 사나요? 경쟁사가 쉽게 못 따르는 강점이 뚜렷한가요?(브랜드/네트워크/전환비용) 원가 상승 시 가격 전가력이 있나요? B. 체력·재무 10년 실적이 경기순환을 버텼나요? ROE 12%+를 지속했나요? 부채는 감당 가능하며 이자보상배율이 양호한가요? 잉여현금흐름이 꾸준히 플러스인가요? C. 경영·지배구조 주주서한·IR에 솔직함과 일관성이 보이나요? 배당·자사주·투자 등 자본배분이 합리적이었나요? D. 가치·가격 보수적 가정의 내재가치 추정이 있는가요? 지금 가격에 **안전마진(20~30%+)**이 있나요? 대체할 더 좋은 기회가 없나요? E. 나의 행동 이 사업을 30초 안에 설명할 수 있나요? 매수·분할·매도 원칙을 문서화했나요? 한 종목 비중은 총자산의 2~5% 이내인가요?(초보 기준) 예시로 감 잡기(가상의 회사 “모아식품”) 사업: 간편식 브랜드 1위, 대형 유통 채널 점유 경쟁우위: 강한 브랜드·레시피, 대체 어려운 재구매 재무: 10년 매출/이익 우상향, ROE 18%, 부채비율 60%, FCF 안정 오너이익: 최근 3년 평균 1,000억(보수적) 가정: 향후 5년 성장 5%, 이후 0%, 할인율 10% 내재가치 범위: 2.83.4조(비관낙관) → 기준 3.1조 안전마진: 2.4조 이하에서만 3회 분할매수 점검 포인트: 원재료 급등 시 가격 전가력, 점유율 유지, 신제품 히트율 숫자를 더 정교하게 만드는 데 집착하기보다 보수적 범위와 행동 원칙을 먼저 고정하십시오. 자주 하는 실수 &amp; 교정법 FOMO 매수 → 내 체크리스트 100% 통과 전 매수 금지 고평가 구간에서 무리한 물타기 → 현금비중 규칙(예: 20~40%) 유지 테마 추종 → “30초 설명 테스트” 통과할 때만 검토 손실회피로 원칙 붕괴 → 매도 트리거를 사전에 문서화 7일 미니 루틴(바로 적용) Day 1: 이해의 영역 2~3개 산업 적기 Day 2: 스크리닝 기준 충족 후보 10종 찾기 Day 3: 후보 3종의 10년 재무 추세 정리 Day 4: 경쟁우위 메모(고객 이유·장벽) Day 5: 내재가치 대략 계산(비관/기준/낙관) Day 6: 매수·분할·매도 트리거 문서화 Day 7: 관찰리스트 알림 설정(가격 안 오면 안 산다) 기록 템플릿(복붙해서 사용)관찰 시트(권장 열)티커(종목코드) | 산업 | 경쟁우위 메모 | 10Y ROE | 부채/이자보상 | FCF 추세 | 내재가치(비/기/낙) | 목표매수가 | 분할횟수 | 매도트리거 매수 전 점검 메모 논리 요약(3줄): 핵심 위험(3개): 왜 지금 가격인가: 실수 시 액션: (손실컷·보유·교체 중 사전 선택) 버핏식 원칙 카드(프린트용 10줄) 이해 안 가면 안 산다 주식이 아닌 사업을 산다 좋은 회사를 제값보다 싸게 안전마진은 생명선 경쟁우위와 **사람(경영진)**을 본다 장기 복리, 회전율 낮추기 레버리지 남용 금지 기록·회고 습관화 감정보다 규칙 규칙1을 잊지 말 것","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"},{"name":"투자","slug":"경제/투자","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/%ED%88%AC%EC%9E%90/"}],"tags":[{"name":"워런버핏","slug":"워런버핏","permalink":"https://tuhbm.github.io/tags/%EC%9B%8C%EB%9F%B0%EB%B2%84%ED%95%8F/"},{"name":"가치투자","slug":"가치투자","permalink":"https://tuhbm.github.io/tags/%EA%B0%80%EC%B9%98%ED%88%AC%EC%9E%90/"},{"name":"경쟁우위","slug":"경쟁우위","permalink":"https://tuhbm.github.io/tags/%EA%B2%BD%EC%9F%81%EC%9A%B0%EC%9C%84/"},{"name":"안전마진","slug":"안전마진","permalink":"https://tuhbm.github.io/tags/%EC%95%88%EC%A0%84%EB%A7%88%EC%A7%84/"},{"name":"장기투자","slug":"장기투자","permalink":"https://tuhbm.github.io/tags/%EC%9E%A5%EA%B8%B0%ED%88%AC%EC%9E%90/"},{"name":"초보투자","slug":"초보투자","permalink":"https://tuhbm.github.io/tags/%EC%B4%88%EB%B3%B4%ED%88%AC%EC%9E%90/"},{"name":"체크리스트","slug":"체크리스트","permalink":"https://tuhbm.github.io/tags/%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8/"}]},{"title":"한화 이글스 vs LG 트윈스, 2025 한국시리즈 관전 포인트 총정리","slug":"2025_korea_baseball","date":"2025-10-26T12:15:30.000Z","updated":"2025-10-31T04:16:02.976Z","comments":true,"path":"2025/10/26/2025_korea_baseball/","link":"","permalink":"https://tuhbm.github.io/2025/10/26/2025_korea_baseball/","excerpt":"개요2025 한국시리즈는 10월 26일(일) 14:00, 잠실 에서 개막합니다.시리즈는 베스트 오브 7(2–3–2 포맷) 으로 진행되며, 정규시즌 1위 LG가 홈 어드밴티지를 갖습니다. 1·2차전과 6·7차전은 잠실, 3~5차전은 대전 한화생명이글스파크(한화 홈)에서 열릴 예정입니다.게임 1 선발예정: LG 앤더스 톨허스트(Anders Tolhurst) vs 한화 문동주","text":"개요2025 한국시리즈는 10월 26일(일) 14:00, 잠실 에서 개막합니다.시리즈는 베스트 오브 7(2–3–2 포맷) 으로 진행되며, 정규시즌 1위 LG가 홈 어드밴티지를 갖습니다. 1·2차전과 6·7차전은 잠실, 3~5차전은 대전 한화생명이글스파크(한화 홈)에서 열릴 예정입니다.게임 1 선발예정: LG 앤더스 톨허스트(Anders Tolhurst) vs 한화 문동주 1) 시리즈 빅픽처: 흐름을 좌우할 5가지 구장 효과(잠실→대전)와 경기 양상잠실은 넓은 외야·장타 억제 성향이 뚜렷합니다. 초반(1–2차전)에는 수비·불펜의 한 점 지키기가 중요하고, 시리즈가 대전으로 이동하면 장타·클러치 한 방의 가치가 커집니다. 선발 카드의 ‘앞머리’ 싸움Game 1: 톨허스트 vs 문동주. 둘 중 누가 6이닝 이상을 책임지느냐가 해당 경기뿐 아니라 양팀 불펜 피로도를 가르는 1차 분기점입니다. 불펜 컨디션 vs. 체력 변수LG는 정규시즌 1위로 대기 기간 동안 불펜 정비가 가능했고, 한화는 PO를 거치며 경기 리듬·집중력을 끌어올렸습니다. 초반 연투가 누적되는 쪽이 후반전(6~7차전) 리스크를 안게 됩니다. 클러치 히팅과 1점 승부잠실에서 시작하는 탓에 저득점 경기 확률이 높습니다. 번트·주루·땅볼 생산력 같은 ‘작은 야구’의 완성도가 체감 승률을 좌우합니다. 정규시즌 상성보다 ‘현재 폼’두 팀은 시즌 내내 투·타 균형을 앞세워 상위권을 지켰습니다. 한국시리즈는 표본이 작기 때문에, 최근 컨디션·당일 매치업이 과거 맞대결 기록보다 더 큰 변수가 됩니다. 2) 선발 로테이션 체크(예상)LG 트윈스 앤더스 톨허스트: 빠른공·슬라이더 기반의 컨택 억제/삼진·땅볼 혼합형. 잠실의 장타 억제 특성과 궁합이 좋습니다. 국내 선발 축: 임찬규 등 스트라이크 존 관리와 변화구·커맨드형이 중심. 초반 리드 상황에선 빠른 불펜 연계가 유력합니다. 한화 이글스 문동주: 상·하 위력적인 포심(윗존)**으로 삼진 창출이 가능. 플레이오프에서도 **고구속+침착한 위기관리를 보여줬습니다. 외국인 선발 축: 코디 폰스 카드와의 조합이 유력. 잠실에선 낮은 코스·그라운드볼 유도가 관건입니다. 포인트: 앞선 두 경기(1·2차전)에서 선발이 6이닝을 채우는 쪽이 시리즈 주도권을 잡을 확률이 높습니다. 이는 불펜 세이브 인원 최소화와 대타·대주 운영 여유로 직결됩니다. 3) 타선·수비·주루 스타일 비교LG 트윈스 접촉·출루 중심 + 수비 안정감. 초반 선취점을 만들고 불펜 봉합으로 마무리하는 루틴이 강점입니다. 잠실 특성상 외야 범위·송구 정확도의 가치가 상승합니다. 한화 이글스 노시환–채은성 축의 중장거리 화력과 맞물림 타선. PO에서 확인된 결정타 생산력·클러치 집중력이 시리즈에서도 관건입니다. 팀 투수진은 시즌 내내 볼넷 억제·위기관리 지표가 개선되며 상승세를 만들었습니다. 4) 불펜 매치업: 7–9회의 체스 LG: 세트업–마무리 라인이 정규시즌 내내 안정적이었고, 리드 상황에선 스페셜리스트 매칭으로 한 이닝을 쪼개 쓰는 운영이 예상됩니다. 한화: 우완 파워암과 좌완 스페셜리스트를 타자·이닝 맞춤으로 투입하는 전술이 돋보입니다. 변수는 연투 관리입니다. 5) 키 매치업 6선 노시환(한화) vs LG 선발의 상·하존 운영 — 높은 포심 대응이 한화 장타 생산의 바로미터. LG 톱–미들(컨택 라인) vs 한화 파워암 릴리버 — 7~8회 볼넷 억제가 승부 포인트. 문동주의 초구 스트라이크% vs LG 타선의 타이밍 조절 — 초구 승부가 투구수·깊이를 좌우. 톨허스트의 땅볼 유도 vs 한화 상위 장타 라인 — 잠실에선 GB%가 곧 승률. 대주자 카드(대전) vs 포수 견제·송구 — 1·2루 리드폭/퀵모션 싸움. 번트·진루타 성공률 — 1점 차 경기에서 체감 차이가 큽니다. 6) 시리즈 초반 ‘흐름 시나리오’ 3가지 시나리오 A (LG 페이스): 잠실 1·2차전 선취–불펜 봉합 성공 → 원정(대전)에서 1승만 확보해도 6차전 홈 우세. 시나리오 B (한화 반전): 문동주/외인 축이 1~2차전 중 1경기 실점 최소화 → 대전에서 장타 한 방으로 2승 1패 이상 설계. 시나리오 C (장기전): 초반 1승 1패 후 불펜 체력전으로 6~7차전 승부. 한 수비 플레이/한 타석이 시리즈를 가르는 전개. 데이터 &amp; 참고 링크 공식 일정(개막 10/26 14:00 KST, 2–3–2 포맷) KBO 영문 데일리 스케줄: https://eng.koreabaseball.com/Schedule/DailySchedule.aspx 조선: “포스트시즌 10월 5일 시작, 한국시리즈 2–3–2 포맷/정규 1위 홈 어드밴티지” (9/28)https://www.chosun.com/english/sports-en/2025/09/28/6W6B53MR6FGPROYIFXNP7UXKPM/ 매일경제(영문): “한국시리즈 홈구장 배치 2–3–2로 운영” (9/28)https://www.mk.co.kr/en/sports/11430984 WorldBaseball.com: “LG vs 한화, 첫 한국시리즈 맞대결·2–3–2 포맷·경기일정” (10/24)https://worldbaseball.com/kbo-lg-twins-and-hanwha-eagles-to-meet-in-korean-series-for-the-first-time/ 선발/미디어데이·게임 1 프리뷰(톨허스트 vs 문동주) Chosun Biz(영문): “LG–한화, 10/26 잠실서 KS 1차전”https://biz.chosun.com/en/en-sports/2025/10/26/RO4ACH4PLBHHDFJKZ66K2HN4XY/ Chosun English: “LG–한화 한국시리즈 미디어데이 개최(10/26)”https://www.chosun.com/english/sports-en/2025/10/26/M3UAQC2EWNF5RLQFBMCBEDF2PU/ SportsChosun(영문): “Game 1 선발 톨허스트, 한화는 문동주”https://en.sportschosun.com/sports/2025/10/was-it-just-hint-of-good-119598 Maeil Business(영문): “문동주, KS 1차전 선발”https://www.mk.co.kr/en/sports/11451117 경기별 페이지/중계 안내(비공식 팬 사이트 포함) MyKBOstats: “10/27 잠실, 한화 vs LG”https://mykbostats.com/games/13181-Hanwha-vs-LG-20251027 SofaScore 라이브 매치 페이지(10/26)https://www.sofascore.com/baseball/match/lg-twins-hanwha-eagles/ToAbshpAb 마무리 코멘트이 시리즈의 키워드는 “초반 버티기 vs 후반 체력전”입니다. 잠실에서 LG가 정교함으로 앞서가면 지키는 야구, 한화는 대전에서 장타·클러치로 뒤집는 야구가 그려집니다. 승부는 3차전까지의 불펜 피로도와 결정타의 순간에서 갈릴 가능성이 큽니다.","categories":[{"name":"스포츠","slug":"스포츠","permalink":"https://tuhbm.github.io/categories/%EC%8A%A4%ED%8F%AC%EC%B8%A0/"}],"tags":[{"name":"야구","slug":"야구","permalink":"https://tuhbm.github.io/tags/%EC%95%BC%EA%B5%AC/"},{"name":"KBO","slug":"KBO","permalink":"https://tuhbm.github.io/tags/KBO/"},{"name":"한국시리즈","slug":"한국시리즈","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%EA%B5%AD%EC%8B%9C%EB%A6%AC%EC%A6%88/"},{"name":"한화이글스","slug":"한화이글스","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%ED%99%94%EC%9D%B4%EA%B8%80%EC%8A%A4/"},{"name":"LG트윈스","slug":"LG트윈스","permalink":"https://tuhbm.github.io/tags/LG%ED%8A%B8%EC%9C%88%EC%8A%A4/"},{"name":"관전포인트","slug":"관전포인트","permalink":"https://tuhbm.github.io/tags/%EA%B4%80%EC%A0%84%ED%8F%AC%EC%9D%B8%ED%8A%B8/"},{"name":"선발로테이션","slug":"선발로테이션","permalink":"https://tuhbm.github.io/tags/%EC%84%A0%EB%B0%9C%EB%A1%9C%ED%85%8C%EC%9D%B4%EC%85%98/"}]},{"title":"10·15 부동산 대책 총정리 — 규제지역 확대·LTV 차등·허가구역 강화","slug":"10_15_realty","date":"2025-10-25T15:23:10.000Z","updated":"2025-10-31T04:16:02.976Z","comments":true,"path":"2025/10/25/10_15_realty/","link":"","permalink":"https://tuhbm.github.io/2025/10/25/10_15_realty/","excerpt":"정정 안내: 문의 주신 “10월 5일 정책 변경”은 공식 발표일이 아닙니다. 정부의 종합 패키지는 2025년 10월 15일에 발표·고시되었고, 조치별로 순차 시행되었습니다. 본 글은 10·15 대책 기준으로 정리했습니다. 한눈에 보기 무엇이 바뀜? 서울 전역 + 경기 12개 지역 규제 동시 확대(조정대상지역·투기과열지구·토지거래허가구역)로 이른바 ‘삼중 규제’ 강화, 2) LTV(주택담보대출비율) 추가 하향 및 가격구간별 차등, 3) 은행 주담대 위험가중치 상향(일정 앞당김), 4) 과열권역 추가 지정 및 거래허가 요건 강화.","text":"정정 안내: 문의 주신 “10월 5일 정책 변경”은 공식 발표일이 아닙니다. 정부의 종합 패키지는 2025년 10월 15일에 발표·고시되었고, 조치별로 순차 시행되었습니다. 본 글은 10·15 대책 기준으로 정리했습니다. 한눈에 보기 무엇이 바뀜? 서울 전역 + 경기 12개 지역 규제 동시 확대(조정대상지역·투기과열지구·토지거래허가구역)로 이른바 ‘삼중 규제’ 강화, 2) LTV(주택담보대출비율) 추가 하향 및 가격구간별 차등, 3) 은행 주담대 위험가중치 상향(일정 앞당김), 4) 과열권역 추가 지정 및 거래허가 요건 강화. 왜 지금?금리 인하 사이클 기대와 유동성 재확대 가능성 속 수도권 가격 재가열, 이를 동반한 가계부채·금융안정 리스크를 선제적으로 관리하겠다는 취지. 시점 정리공식 패키지 발표는 2025년 10월 15일. 일부 지정·고시는 같은 주에 순차 시행. “10월 5일”은 정책 필요성을 다룬 보도가 있었으나 공식 변경일은 아님. 디테일 해설1) 규제지역·허가구역 ‘트리플’ 강화 서울 전역과 경기 12개 지역이 조정대상지역·투기과열지구·토지거래허가구역으로 중첩 지정. 효과: 분양·매수 자격 강화, 전매 제한 강화, 자금조달계획서 제출 요건 상향, 허가구역 내 실거주 목적 외 매입 제한 등. 2) LTV·대출 규제 추가 하향(가격구간 차등) 고가 주택일수록 LTV 더 낮게 책정하는 가격구간별 차등 구조로 전환·강화. 수도권 과열지역은 DSR 적용도 엄격화되며, 사실상 초기 현금 비중 확대를 유도. 세부 수치는 지역·가격구간·차주 특성 및 금융기관 적용 기준에 따라 달라질 수 있어 사전 한도 점검이 필수. 3) 은행 건전성 규제(위험가중치) 조기 상향 주담대 위험가중치 상향 적용 시점을 앞당겨 은행의 대출공급 유인을 낮춤. 파급: 심사 보수화 가능성, 금리 스프레드 소폭 확대 가능성. 4) 토지거래허가·과열권역 확대 허가구역 확대 및 과열권역 추가 지정으로 거래허가·실수요 증빙 요건 강화. 실수요 보호와 투기적 단기 수요 차단이 목표. 5) 시장 반응 발표 직후 문의 급증 → 거래 둔화 패턴 예상. 전·월세 시장 불안, 정비사업 속도 둔화 등의 부작용 가능성 제기. 효과에 대해선 찬반 논쟁 지속: 수요 억제의 단기효과 vs. 공급·금리 등 구조요인의 영향. 누구에게 어떤 영향? 구분 영향 요약 실전 포인트 무주택자(실수요) 대출심사 강화로 초기자금 부담↑ 예산 재점검, 가격대·지역 분산 탐색, 생애최초·특례 여부 사전 확인 일시적 2주택/갈아타기 허가·자금계획 요건 까다로움 기존주택 매도·전입 일정 타임라인 관리 다주택자·법인 규제지역 확대·허가구역 강화로 투자 난이도↑ 포트폴리오 정리·리밸런싱 검토 매도자(분양 포함) 수요 위축 → 거래량 둔화 가능성 가격전략 보수화, 실거주 수요 타깃 마케팅 시나리오 예시 서울 9억대 후반 아파트 실수요 매수 LTV 차등 및 DSR 엄격화로 대출한도 축소 → 현금 보유·보증료·금리민감도를 재산정해야 함. 허가구역 내 투자성 매수 실거주 목적 외 제한으로 거래 난이도 상승, 자금·거주계획 증빙이 필수. 자주 묻는 질문(FAQ)Q1. 10월 5일이 ‘정책 변경일’인가요?A. 아니요. 공식 패키지 발표는 10월 15일입니다. 10월 5일에는 시장 과열과 대책 필요성을 다룬 보도가 있었으나, 정책 변경의 공식일은 아닙니다. Q2. LTV 수치가 정확히 얼마로 바뀐 건가요?A. 핵심은 가격구간별·지역별 차등 강화입니다. 구체적 수치는 고시·금융사 적용에 따라 다를 수 있으므로 사전 상담으로 개인 한도를 확인하세요. Q3. 거래는 얼어붙나요, 집값은 잡히나요?A. 단기적으로 거래위축 가능성이 크지만, 금리·유동성·공급·기대심리에 따라 효과가 달라집니다. 대책은 수요 측 속도조절 성격이 강합니다. 필자 코멘트이번 대책의 핵심은 “가격이 높고 투기 가능성이 큰 구간을 더 강하게 조이는 것”입니다. 실수요자는 대출여력 점검과 대체지역 탐색이 필요하고, 투자자는 허가·증빙·자금 부담을 냉정히 반영해야 합니다. 다만 금리 경로·공급 계획이 병행되지 않으면 규제의 지속 효과는 제한될 수 있습니다. 참고·출처(링크) 정부 보도자료(금융위·관계부처) — 10·15 대책 개요https://www.korea.kr/briefing/pressReleaseView.do?newsId=156719048 KDI 경제정보센터(EIEC) — 10·15 대책 관련 정책자료 요약https://eiec.kdi.re.kr/policy/materialView.do?num=272246 BusinessKorea — “Government Designates Entire Seoul Area as Land Transaction Permit Zones…”(일부 조치 효력 시작일 안내)https://www.businesskorea.co.kr/news/articleView.html?idxno=254074 Korea JoongAng Daily — 10·15 대책 해설(수요관리·공급 병행 필요성)https://koreajoongangdaily.joins.com/news/2025-10-16/opinion/editorials/Oct-15-housing-measures-target-demand-but-supply-must-keep-up/2420807 Maeil Business(영문) — 대출 규제 방향·맥락 정리https://www.mk.co.kr/en/economy/11445463 Chosun English — 규제지역·대출규제 강화 보도https://www.chosun.com/english/market-money-en/2025/10/15/QL55MIH2LFGXHOK3CZM2YARLVQ/ Bloomberg — “South Korea Unveils New Curbs to Rein in Red-Hot Housing Market”(위험가중치·대출제한 관련)https://www.bloomberg.com/news/articles/2025-10-15/south-korea-unveils-new-curbs-to-rein-in-red-hot-housing-market CERIK 정책브리핑(PDF) — 10·15 대책 주요 내용 정리https://www.cerik.re.kr/uploads/report/3013/%EA%B1%B4%EC%84%A4%EB%8F%99%ED%96%A5%EB%B8%8C%EB%A6%AC%ED%95%91%201027%ED%98%B8.pdf 실제와 다른내용이 있을 수 있으며, 해당내용은 참고만 부탁드립니다. 만약 다른 내용이 있다면 댓글로 바로 잡아주시면 감사하겠습니다.","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"},{"name":"부동산","slug":"경제/부동산","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/%EB%B6%80%EB%8F%99%EC%82%B0/"}],"tags":[{"name":"10·15대책","slug":"10·15대책","permalink":"https://tuhbm.github.io/tags/10%C2%B715%EB%8C%80%EC%B1%85/"},{"name":"규제지역","slug":"규제지역","permalink":"https://tuhbm.github.io/tags/%EA%B7%9C%EC%A0%9C%EC%A7%80%EC%97%AD/"},{"name":"LTV","slug":"LTV","permalink":"https://tuhbm.github.io/tags/LTV/"},{"name":"토지거래허가구역","slug":"토지거래허가구역","permalink":"https://tuhbm.github.io/tags/%ED%86%A0%EC%A7%80%EA%B1%B0%EB%9E%98%ED%97%88%EA%B0%80%EA%B5%AC%EC%97%AD/"},{"name":"가계부채","slug":"가계부채","permalink":"https://tuhbm.github.io/tags/%EA%B0%80%EA%B3%84%EB%B6%80%EC%B1%84/"},{"name":"주택금융","slug":"주택금융","permalink":"https://tuhbm.github.io/tags/%EC%A3%BC%ED%83%9D%EA%B8%88%EC%9C%B5/"}]},{"title":"왕초보 ETF 입문서 - 개념·세금·환헤지·추천 종목 한 번에","slug":"etf","date":"2025-10-24T12:24:20.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2025/10/24/etf/","link":"","permalink":"https://tuhbm.github.io/2025/10/24/etf/","excerpt":"들어가며처음 검색해 보면 총보수(TER), 추적오차/괴리율, 환헤지(H) 같은 용어부터 막히기 쉽습니다. 이 글은 필수 개념 → 세금/환헤지 → 고르는 법 → 많이 추천되는 전략과 실제 티커 순서로, 초보자분들이 바로 실행할 수 있게 간결하게 정리했습니다. 1) ETF 핵심만 콕 집어보기 ETF = 거래소에 상장된 인덱스 펀드로, 주식처럼 사고팔 수 있습니다. 좋은 ETF를 고르는 핵심 4가지 총보수(TER): 동일 전략이면 낮을수록 유리 추적오차/괴리율: 지수와 실제 수익의 차이·시가와 순자산가치(NAV)의 차이 → 작을수록 좋음 유동성/스프레드: 거래대금이 충분하고 매수·매도 호가 차이가 좁을수록 체결 손실↓ 환헤지(H): 원/달러 환율 변동을 중화(티커명에 보통 “(H)” 표기) 참고: NAV는 장 마감 기준가, iNAV는 장중 실시간 추정가로 매매 판단 보조에 유용합니다. 2) 국내 상장 vs 해외 상장 – 세금 한 장 요약 국내 상장 ETF (국내주식형) 매매차익 비과세, 분배금은 배당소득 15.4% 원천징수. (해외자산형·채권형 등) 매매차익·분배금 배당소득 15.4%(금융소득종합과세 합산 가능, 제도는 수시 개정). 해외 상장 ETF(예: 미국) 양도소득세 22%(지방세 포함) – 연 250만 원 공제 후 과세, 분배금은 배당소득. 팁: 실제 신고·계좌 설계 전에는 운용사/거래소 공시와 최신 세법을 반드시 재확인하세요.","text":"들어가며처음 검색해 보면 총보수(TER), 추적오차/괴리율, 환헤지(H) 같은 용어부터 막히기 쉽습니다. 이 글은 필수 개념 → 세금/환헤지 → 고르는 법 → 많이 추천되는 전략과 실제 티커 순서로, 초보자분들이 바로 실행할 수 있게 간결하게 정리했습니다. 1) ETF 핵심만 콕 집어보기 ETF = 거래소에 상장된 인덱스 펀드로, 주식처럼 사고팔 수 있습니다. 좋은 ETF를 고르는 핵심 4가지 총보수(TER): 동일 전략이면 낮을수록 유리 추적오차/괴리율: 지수와 실제 수익의 차이·시가와 순자산가치(NAV)의 차이 → 작을수록 좋음 유동성/스프레드: 거래대금이 충분하고 매수·매도 호가 차이가 좁을수록 체결 손실↓ 환헤지(H): 원/달러 환율 변동을 중화(티커명에 보통 “(H)” 표기) 참고: NAV는 장 마감 기준가, iNAV는 장중 실시간 추정가로 매매 판단 보조에 유용합니다. 2) 국내 상장 vs 해외 상장 – 세금 한 장 요약 국내 상장 ETF (국내주식형) 매매차익 비과세, 분배금은 배당소득 15.4% 원천징수. (해외자산형·채권형 등) 매매차익·분배금 배당소득 15.4%(금융소득종합과세 합산 가능, 제도는 수시 개정). 해외 상장 ETF(예: 미국) 양도소득세 22%(지방세 포함) – 연 250만 원 공제 후 과세, 분배금은 배당소득. 팁: 실제 신고·계좌 설계 전에는 운용사/거래소 공시와 최신 세법을 반드시 재확인하세요. 3) 처음 사기 좋은 “대표 전략” 4종 미국 대형주(S&amp;P500) – 장기 코어, 정보/유동성 풍부(단, 달러·밸류에이션 변동성) 전 세계 분산(ACWI/올월드/VT) – 한 종목으로 글로벌 분산(단, 특정국 강세장에선 민첩성↓) 나스닥100 – 성장/AI 모멘텀(단, 금리상승기 변동성↑) 채권/금(완충·분산) – 주식 하락기 변동성 완화·인플레 분산(채권은 금리/환율, 금은 현금흐름 없음) 4) 실제 인기 ETF 예시표 (요약) 총보수·분배주기·헤지 여부는 운용사 공시 기준, 유동성은 초보자 판단에 도움이 되도록 정성 등급(상/중/하)**으로 표기했습니다.매수 전 마지막으로 **운용사 상품 페이지에서 수치를 다시 확인하세요. 국내 상장(원화 거래) 전략 종목명 티커 총보수(연) 분배주기 헤지 유동성(참고) 미국 대형주 TIGER 미국S&amp;P500 360750 0.0068% 분기 무헤지 상 미국 대형주 KODEX 미국S&amp;P500 379800 0.0062% 분기 무헤지 상 나스닥100 TIGER 미국나스닥100 133690 0.0068% 분기 무헤지 상 금(선물) KODEX 골드선물(H) 132030 0.68% 공시참조 헤지형(H) 중 해외 상장(미국) 전략 종목명 티커 총보수(연) 분배주기 헤지 유동성(참고) 미국 대형주 Vanguard S&amp;P 500 ETF VOO 0.03% 분기 — 상 나스닥100 Invesco QQQ QQQ 0.20% 분기 — 상 전 세계 주식 Vanguard Total World VT 0.06% 분기 — 상 미 총합채권 Vanguard Total Bond BND 0.03% 월배당 — 상 5) 전략별 장단점 요약 S&amp;P500(미국 대형주): 유동성·정보 접근성 최고, 장기 코어 / 달러·밸류 변동성 노출 전 세계 분산(VT 등): 국가 리스크 분산·관리 간단 / 강세 국가 단독장에선 수익 민첩성↓ 나스닥100: 성장/AI 모멘텀 / 금리상승기 변동성 큼 채권(BND 등): 포트폴리오 완충·월배당 / 금리·신용 사이클 민감 금(선물·현물): 인플레·위기 분산 / 현금흐름 없음·선물은 롤오버 비용 6) 독자 타깃 맞춤 버전6-1. 완전초보 3줄 요약 너무 복잡하게 고르지 말고 S&amp;P500 1개 또는 전세계 1개로 시작 총보수 낮고 거래대금 많은 상품 우선 세금은 국내상장=배당소득 중심, 해외상장=양도소득 22%·연 250만 공제 기억 6-2. 직장인(바쁠 때) 계좌: 연금/ISA 적극 활용(절세) 포트폴리오: **전세계 70% + 글로벌 채권(H) 30%**처럼 간단한 원스톱 구조 반기 1회 리밸런싱(±5% 밴드)만 습관화 6-3. 연금저축/IRP 중심 총보수↓·분산↑ 상품 위주 분배금 재투자형 기본 가정(세후 누적 수익률 관점) 해외 상장 직접 편입이 번거로우면 국내 상장 해외주식형으로 대체 주석/출처 국내 ETF 과세 가이드(삼성자산운용 공식): https://www.samsungfund.com/etf/insight/guide/view05.do 해외주식 양도소득세(국세청 안내 PDF): https://www.nts.go.kr/comm/nttFileDownload.do?fileKey=42e27a680ded33cc64242dc2a83908fc TIGER 미국S&amp;P500·나스닥100 총보수 0.0068% 인하 공지(미래에셋 공식): https://investments.miraeasset.com/tigeretf/ko/customer/notice/view.do?detailsKey=590 TIGER 2종 보수 인하 기사(한국경제 Plus 요약): https://plus.hankyung.com/apps/newsinside.view?aid=2025020667245 KODEX 미국S&amp;P500 총보수 0.0062% 기사: https://news.nate.com/view/20250207n09641 KODEX 미국S&amp;P500 공식 상품 페이지(총보수 표기): https://www.funetf.co.kr/product/etf/view/KR7379800006 KODEX 골드선물(H) 개요(팩트·지표 참고): https://kr.investing.com/etfs/samsung-kodex-gold-futures-special VOO 공식 페이지(경비율 0.03%): https://advisors.vanguard.com/investments/products/voo/vanguard-sp-500-etf QQQ 공식 페이지(총보수 0.20%): https://www.invesco.com/qqq-etf/en/home.html VT 공식 페이지(경비율 0.06%): https://investor.vanguard.com/investment-products/etfs/profile/vt BND 공식 페이지(경비율 0.03%·월분배): https://advisors.vanguard.com/investments/products/bnd/vanguard-total-bond-market-etf","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"},{"name":"투자","slug":"경제/투자","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/%ED%88%AC%EC%9E%90/"}],"tags":[{"name":"ETF","slug":"ETF","permalink":"https://tuhbm.github.io/tags/ETF/"},{"name":"투자입문","slug":"투자입문","permalink":"https://tuhbm.github.io/tags/%ED%88%AC%EC%9E%90%EC%9E%85%EB%AC%B8/"},{"name":"세금","slug":"세금","permalink":"https://tuhbm.github.io/tags/%EC%84%B8%EA%B8%88/"},{"name":"환헤지","slug":"환헤지","permalink":"https://tuhbm.github.io/tags/%ED%99%98%ED%97%A4%EC%A7%80/"},{"name":"연금","slug":"연금","permalink":"https://tuhbm.github.io/tags/%EC%97%B0%EA%B8%88/"},{"name":"직장인","slug":"직장인","permalink":"https://tuhbm.github.io/tags/%EC%A7%81%EC%9E%A5%EC%9D%B8/"}]},{"title":"하이버프(HighBuff) 투자 앱 리뷰 - 시간을 아끼는 자동 투자, 써보니 이렇습니다.","slug":"highBUff","date":"2025-10-23T15:20:23.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2025/10/23/highBUff/","link":"","permalink":"https://tuhbm.github.io/2025/10/23/highBUff/","excerpt":"하이버프(HighBuff) 투자 앱 리뷰바쁜 일상에서 뉴스와 차트를 매일 따라가는 건 쉽지 않습니다. 하이버프(HighBuff)**는 이런 수고를 줄이기 위해, 사용자가 **목표와 위험 한도만 정하면 포트폴리오 구성–매수/매도–점검–리밸런싱까지 자동으로 처리해 주는 것을 내세우는 투자 앱입니다.한마디로 말하면 “투자 방향과 울타리는 내가 정하고, 운전은 앱이 한다”는 방식입니다. 하이버프는 어떤 앱인가요? 무엇을 해주나요?내 투자 성향(안정형~공격형)을 고르고, 최대손실 허용 범위(MDD), 매매 잦음(회전율), 위험자산 비중 같은 한도를 정하면, 그 범위 안에서 자동 운용합니다. 어떻게 보여주나요?지수(KOSPI/KOSDAQ 등)와의 비교 그래프, 기간별 수익/손실 요약, 언제 무엇을 매수/매도했는지 같은 리포트 화면을 제공합니다. 어디에 투자하나요?소개 자료 기준으로 국내·해외 시장을 다룹니다. 실제 가능 범위는 계좌 설정이나 서비스 정책에 따라 달라질 수 있어요.","text":"하이버프(HighBuff) 투자 앱 리뷰바쁜 일상에서 뉴스와 차트를 매일 따라가는 건 쉽지 않습니다. 하이버프(HighBuff)**는 이런 수고를 줄이기 위해, 사용자가 **목표와 위험 한도만 정하면 포트폴리오 구성–매수/매도–점검–리밸런싱까지 자동으로 처리해 주는 것을 내세우는 투자 앱입니다.한마디로 말하면 “투자 방향과 울타리는 내가 정하고, 운전은 앱이 한다”는 방식입니다. 하이버프는 어떤 앱인가요? 무엇을 해주나요?내 투자 성향(안정형~공격형)을 고르고, 최대손실 허용 범위(MDD), 매매 잦음(회전율), 위험자산 비중 같은 한도를 정하면, 그 범위 안에서 자동 운용합니다. 어떻게 보여주나요?지수(KOSPI/KOSDAQ 등)와의 비교 그래프, 기간별 수익/손실 요약, 언제 무엇을 매수/매도했는지 같은 리포트 화면을 제공합니다. 어디에 투자하나요?소개 자료 기준으로 국내·해외 시장을 다룹니다. 실제 가능 범위는 계좌 설정이나 서비스 정책에 따라 달라질 수 있어요. 용어 한 줄 정리MDD(최대 낙폭): 내 자산이 최고점 대비 얼마나 떨어졌는지 나타내는 수치. 예: MDD 10%라면, 최고점에서 최대 10%까지는 흔들림을 감수하겠다는 뜻입니다. 요금/체험과 출금 규정 (개요) 체험은 무료로 안내되어 있으며, 투입 금액의 한도가 있습니다(국내/해외 한도는 별도 공지 참고). 수익금 출금: 영업일 기준 D+3 투입한 원금(운용금) 출금: 영업일 기준 D+5 주의: 운용금(원금)을 출금하거나 해지하면 체험이 종료될 수 있습니다. (수익금 출금은 별도) 체험 기간이나 세부 정책은 변경될 수 있으니 공식 안내를 반드시 확인해 주세요. 핵심 기능을 한눈에 리스크 프리셋 + 세부 설정안정형/중립형/공격형 같은 틀을 고른 뒤, MDD·회전율·위험자산 비중을 숫자로 제한합니다. 앱은 이 가드레일(울타리) 안에서 자동 운용합니다. 자동 리밸런싱과 거래 집행시장 상황에 맞춰 비중을 조정하고(리밸런싱), 실제 매수/매도까지 자동으로 진행합니다. 보기 쉬운 리포트지수 대비 성과, 기간별 손익, 리밸런싱 내역을 대시보드 형태로 제공합니다. 개인이 엑셀로 일일이 정리할 필요가 줄어듭니다. 장점 정해 놓은 선 안에서 ‘풀오토’내가 정한 위험 한도만 넘지 않도록 운용하므로, 일상에 집중하면서 투자 경험을 이어가기 좋습니다. 손실 관리에 도움이 되는 울타리(MDD 등)최대손실 한도를 미리 정해 두면, 감정적으로 휘둘리기보다 규칙 기반으로 대응하기 쉬워집니다. 체험 무료 + 수익금만 빼는 전략 가능수익금만 가끔 출금하고 원금은 유지하면, 체험을 오래 이어가며 내 성향에 맞는지 살펴볼 수 있습니다. 국내·해외 분산 기대여러 시장을 활용하면 특정 나라나 업종에 쏠림을 줄이는 효과를 기대할 수 있습니다. 리포트가 깔끔성과와 변화를 한 화면에서 보며 **벤치마크(지수)**와 비교하기 쉬워요. 단점·유의사항 유동성(현금화) 제약원금(운용금)을 출금하면 체험이 끝날 수 있습니다. 자주 들락날락하는 자금에는 덜 맞습니다. (수익금 출금은 별도) 알고리즘 운용의 ‘불투명함’의사결정 과정을 모든 단계에서 직접 확인하거나 수정하긴 어렵습니다. 완전 수동 제어를 선호하신다면 답답할 수 있어요. 시장 환경에 따른 성과 변동어떤 전략도 모든 시장에서 항상 이기진 못합니다. 원금 손실 가능성은 늘 있습니다. 앱 완성도 이슈는 개인차일부 이용자는 인터페이스나 출금 동선에서 불편을 언급하기도 합니다. 다만 이는 버전과 사용자 환경에 따라 차이가 있습니다. 사용 흐름 예시 설치와 가입스토어에서 HighBuff 설치 → 계정 생성. 리스크 설정안정형/중립형/공격형 중 고르고, MDD·회전율·위험자산 비중을 숫자로 제한. 입금 후 자동 운용 시작한도 내 금액을 넣으면, 포트폴리오 구성–거래–점검–리밸런싱이 자동으로 돌아갑니다. 리포트 확인 &amp; 출금 규정 숙지성과 대시보드를 보며 지수 대비를 체크하고, 수익금(D+3)·원금(D+5) 출금 규정을 이해합니다. 이런 분께 추천드립니다 투자에 쓰는 시간을 최소화하고 싶은 직장인/초보 투자자 숫자로 위험 한도를 정해 놓고 그 안에서 자동 운용을 체험하고 싶은 분 소액으로 먼저 해보고 맞으면 규모를 키우려는 분 다만, 아래 유형이라면 신중히 생각해 보세요. 현금 흐름이 자주 필요한 분(원금 출금 시 체험 종료 가능) 매매 시점과 종목 선택을 본인이 100% 통제하고 싶은 액티브 트레이더 에디터의 사용 팁 생활자금과 투자자금 분리: 유동성 스트레스를 줄입니다. MDD는 보수적으로 시작: 데이터를 쌓으며 천천히 조정하세요. 수익금만 정기 회수: 체험을 길게 가져가며 앱이 나와 맞는지 판단할 수 있습니다. 항상 벤치마크와 비교: 지수보다 낫거나 못한 기간을 기록해 전략 적합성을 판단하세요. 자주 묻는 질문(간단 버전)Q. 체험은 정말 무료인가요?A. 체험 구간은 운용 수수료 없이 제공된다고 안내되어 있습니다. 다만 정책은 변경될 수 있으니 공식 페이지를 꼭 확인하세요. Q. 돈은 언제든 뺄 수 있나요?A. 수익금은 D+3, 원금은 D+5가 안내 기준입니다. 단, 원금을 출금/해지하면 체험이 종료될 수 있습니다. Q. 국내·해외 모두 가능한가요?A. 소개 기준에 따르면 국내·해외 시장을 지원합니다. 실제 가능 범위는 계좌/국가 설정과 정책을 확인해 주세요. 마무리하이버프는 “내가 정한 규칙 안에서 자동으로 운용해 주는 앱”이라는 점이 가장 큰 매력입니다. 시간은 아끼고, 감정 개입을 줄이며, 수익금만 회수하는 방식으로 체험을 이어가면 부담을 최소화할 수 있습니다. 반대로 원금의 상시 유동성이 중요하거나 직접 매매의 손맛을 중시한다면 덜 맞을 수 있습니다. 본 글은 투자 권유가 아니며, 앱 이용을 통해 추천드리는 글입니다.","categories":[{"name":"경제","slug":"경제","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/"},{"name":"투자","slug":"경제/투자","permalink":"https://tuhbm.github.io/categories/%EA%B2%BD%EC%A0%9C/%ED%88%AC%EC%9E%90/"}],"tags":[{"name":"재테크","slug":"재테크","permalink":"https://tuhbm.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"},{"name":"투자앱","slug":"투자앱","permalink":"https://tuhbm.github.io/tags/%ED%88%AC%EC%9E%90%EC%95%B1/"},{"name":"로보어드바이저","slug":"로보어드바이저","permalink":"https://tuhbm.github.io/tags/%EB%A1%9C%EB%B3%B4%EC%96%B4%EB%93%9C%EB%B0%94%EC%9D%B4%EC%A0%80/"},{"name":"AI투자","slug":"AI투자","permalink":"https://tuhbm.github.io/tags/AI%ED%88%AC%EC%9E%90/"},{"name":"하이버프","slug":"하이버프","permalink":"https://tuhbm.github.io/tags/%ED%95%98%EC%9D%B4%EB%B2%84%ED%94%84/"}]},{"title":"야식과 술 마시고 바로 자면 생기는 일 - 역류부터 지방간까지","slug":"lateNightSnack","date":"2025-10-22T11:20:00.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2025/10/22/lateNightSnack/","link":"","permalink":"https://tuhbm.github.io/2025/10/22/lateNightSnack/","excerpt":"오늘 밤의 유혹: 야식 + 음주 후 ‘바로 잠’이 몸에 남기는 것들바쁜 밤, 허기와 위로 사이에서야근으로 저녁을 건너뛰고 집에 돌아오면 시곗바늘은 이미 밤을 넘깁니다. 출출한 배를 달래줄 치킨 한 조각, 라면 한 그릇, 그리고 “오늘도 고생했어요”라는 의미의 맥주 한 캔. 허기를 채운 안도감과 함께 눈꺼풀은 무거워지고, 그대로 침대로 향하시지요.하지만 ‘야식 + 술 → 바로 수면’ 조합은 잠들 때는 달콤해도, 위·간·심장·뇌에 야근을 시킵니다. 다음 날의 무거운 몸, 잦은 속 쓰림, 길어지는 피곤함이 그 영수증입니다. 자기 직전 먹고 마신 뒤 ‘바로 잠’의 대가1) 수면의 질 저하 깊은 수면·REM 감소, 각성 증가: 소화와 알코올 대사로 심박과 체온이 올라 자주 깨기 쉽습니다. 야뇨·갈증: 알코올의 이뇨 작용으로 화장실 횟수 증가, 탈수로 입·목 건조. 수면 호흡 문제 악화: 알코올이 기도 주변 근육을 이완시켜 코골이·수면무호흡을 악화시킬 수 있습니다. 2) 소화기 부담 역류성식도염 위험 상승: 포만 상태로 눕는 데 더해 알코올·기름진 야식이 하부식도괄약근 이완을 유발해 역류·속 쓰림·목 이물감을 부릅니다. 위염·위궤양 악화 가능성: 매운 양념·튀김과 알코올 조합은 점막 자극을 키워 더부룩함·트림을 유발합니다. 후두 자극: 반복되는 역류는 쉰 목소리·기침으로 이어질 수 있습니다.","text":"오늘 밤의 유혹: 야식 + 음주 후 ‘바로 잠’이 몸에 남기는 것들바쁜 밤, 허기와 위로 사이에서야근으로 저녁을 건너뛰고 집에 돌아오면 시곗바늘은 이미 밤을 넘깁니다. 출출한 배를 달래줄 치킨 한 조각, 라면 한 그릇, 그리고 “오늘도 고생했어요”라는 의미의 맥주 한 캔. 허기를 채운 안도감과 함께 눈꺼풀은 무거워지고, 그대로 침대로 향하시지요.하지만 ‘야식 + 술 → 바로 수면’ 조합은 잠들 때는 달콤해도, 위·간·심장·뇌에 야근을 시킵니다. 다음 날의 무거운 몸, 잦은 속 쓰림, 길어지는 피곤함이 그 영수증입니다. 자기 직전 먹고 마신 뒤 ‘바로 잠’의 대가1) 수면의 질 저하 깊은 수면·REM 감소, 각성 증가: 소화와 알코올 대사로 심박과 체온이 올라 자주 깨기 쉽습니다. 야뇨·갈증: 알코올의 이뇨 작용으로 화장실 횟수 증가, 탈수로 입·목 건조. 수면 호흡 문제 악화: 알코올이 기도 주변 근육을 이완시켜 코골이·수면무호흡을 악화시킬 수 있습니다. 2) 소화기 부담 역류성식도염 위험 상승: 포만 상태로 눕는 데 더해 알코올·기름진 야식이 하부식도괄약근 이완을 유발해 역류·속 쓰림·목 이물감을 부릅니다. 위염·위궤양 악화 가능성: 매운 양념·튀김과 알코올 조합은 점막 자극을 키워 더부룩함·트림을 유발합니다. 후두 자극: 반복되는 역류는 쉰 목소리·기침으로 이어질 수 있습니다. 3) 대사·간 건강 혈당 롤러코스터: 늦은 시각의 고탄수·고지방 섭취는 혈당·인슐린 급등 후 급락을 불러, 새벽 허기와 아침 과식을 유도합니다. 지방 축적·체중 증가: 수면 중 활동량이 적어 야식 칼로리가 체지방으로 저장되기 유리합니다. 지방간 위험 증가: 과잉 칼로리와 알코올 대사가 겹치면 간은 중성지방 합성에 몰두해 간 수치 상승·지방간 진행으로 이어질 수 있습니다. 지질 이상: 늦은 야식은 중성지방 증가·HDL 감소 등으로 심혈관 위험에 불리합니다. 4) 심혈관·자율신경 불안정 심박·혈압 변동: 포만감과 알코올로 교감신경 항진이 나타나 민감한 분들에겐 야간 부정맥 소인이 될 수 있습니다. 회복력 저하 → 퍼포먼스 하락: 숙면이 방해되어 다음 날 피로·집중력 저하로 이어집니다. 5) 위험을 키우는 메뉴와 습관 튀김·라면·피자·곱창: 고지방·고염 → 역류·부종·갈증. 매운 양념·탄산: 점막 자극·가스 팽창. 디저트 + 술: 혈당 급등 후 급락과 추가 식욕 유발. 폭음: 수면무호흡 악화·야뇨·부정맥 위험. 먹고 30분 내 취침: 역류·답답함의 최악 타이밍. 6) 덜 아픈 ‘현실 타협’ 루틴 타이밍: 가능하면 취침 3시간 전 식사. 늦어졌다면 가볍게(닭가슴살·두부·계란 + 샐러드, 현미 반 공기, 미지근한 물). 음주: 1–2잔 이내로 줄이고 물 1–2컵을 함께. 자세: 상체를 10–15cm 높이고 자기(베개 겹치기 또는 웨지 사용). 다음 날: 수분·전해질 보충 → 가벼운 유산소 20–30분 → 단백질 중심 소량 아침(계란, 그릭요거트). 장기 관리: 주 2회만 야식 허용 데이를 정하고, 나머지 날은 비상 간식(바나나, 삶은 계란, 무가당 요거트)으로 허기를 관리합니다. 주의 증상: 가슴 통증, 흑변 또는 토혈, 호흡 곤란, 야간 무호흡이 의심되면 즉시 진료를 권합니다. 생길 수 있는 대표 질병/증상 한눈에 보기 역류성식도염(후두염 포함): 속 쓰림, 목 이물감, 만성 기침 수면무호흡·코골이 악화: 주간 졸림, 집중력 저하, 심혈관 위험 증가 위염·위궤양 악화: 상복부 통증, 더부룩함 지방간(비알코올성/알코올성): 간 수치 상승, 피로 대사 이상: 인슐린저항성, 중성지방 상승, 체중 증가 심혈관 부담: 심박 변동 불안정, 고혈압 소인 악화 밤의 위로가 내일의 나를 지치게 하지 않도록야식과 한 잔은 오늘의 고단함을 위로하는 작은 의식입니다. 다만 그 달콤한 위로가 내일의 나에게 청구서로 돌아오지 않게 하려면, 양을 줄이고 타이밍을 조절하는 지혜가 필요합니다. SNS 요약(복붙용)“야식+술 후 바로 잠은 역류·코골이·지방간 위험을 키웁니다. 취침 3시간 전 식사, 가벼운 메뉴, 상체 올리고 자기—이 세 가지만 지켜도 내일이 가벼워집니다.”","categories":[{"name":"건강","slug":"건강","permalink":"https://tuhbm.github.io/categories/%EA%B1%B4%EA%B0%95/"}],"tags":[{"name":"야식","slug":"야식","permalink":"https://tuhbm.github.io/tags/%EC%95%BC%EC%8B%9D/"},{"name":"음주","slug":"음주","permalink":"https://tuhbm.github.io/tags/%EC%9D%8C%EC%A3%BC/"},{"name":"수면의질","slug":"수면의질","permalink":"https://tuhbm.github.io/tags/%EC%88%98%EB%A9%B4%EC%9D%98%EC%A7%88/"},{"name":"역류성식도염","slug":"역류성식도염","permalink":"https://tuhbm.github.io/tags/%EC%97%AD%EB%A5%98%EC%84%B1%EC%8B%9D%EB%8F%84%EC%97%BC/"},{"name":"지방간","slug":"지방간","permalink":"https://tuhbm.github.io/tags/%EC%A7%80%EB%B0%A9%EA%B0%84/"},{"name":"코골이","slug":"코골이","permalink":"https://tuhbm.github.io/tags/%EC%BD%94%EA%B3%A8%EC%9D%B4/"},{"name":"수면무호흡","slug":"수면무호흡","permalink":"https://tuhbm.github.io/tags/%EC%88%98%EB%A9%B4%EB%AC%B4%ED%98%B8%ED%9D%A1/"},{"name":"숙취","slug":"숙취","permalink":"https://tuhbm.github.io/tags/%EC%88%99%EC%B7%A8/"},{"name":"인슐린저항성","slug":"인슐린저항성","permalink":"https://tuhbm.github.io/tags/%EC%9D%B8%EC%8A%90%EB%A6%B0%EC%A0%80%ED%95%AD%EC%84%B1/"}]},{"title":"2025년 10월, 진짜 잘하는 AI는 누구? GPT-5·Gemini 2.5·Claude 3.7·Grok 4·Cursor 실사용 비교","slug":"aiComparison","date":"2025-10-21T22:50:00.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2025/10/21/aiComparison/","link":"","permalink":"https://tuhbm.github.io/2025/10/21/aiComparison/","excerpt":"한줄 요약업무에서 바로 도움이 되는 선택을 하려면 모델(두뇌) + 도구(손발)**를 함께 보셔야 합니다. 코딩·리팩터링은 **GPT-5/Claude가 안정적이고, 긴 문서 요약·분석은 Gemini 2.5가 유리합니다. 난도 높은 탐구형 문제는 Grok 4가 아이디어를 잘 뽑아냅니다. 그리고 실제 개발 현장에서는 Cursor(커서) 같은 AI 편집기가 프로젝트 단위 작업을 빠르게 밀어 주며 체감 생산성을 크게 끌어올립니다. 1) 왜 지금 비교하나올해 가을은 주요 모델이 한 차례씩 업그레이드된 뒤 안정화 구간에 접어든 시점입니다. 즉, 우리 일에 바로 들이기 좋은 타이밍입니다. 특히 최근에는 단순 자동완성(다음 코드 예측)만으로는 부족하고, 에이전트(작업을 단계별로 대신 처리하는 AI 도우미)와 긴 문맥 처리(수백 페이지를 한 번에 이해)가 실제 생산성 차이를 만듭니다. 이런 흐름에서 모델만 볼 게 아니라, IDE(코드 편집기) 레벨의 AI 도구인 Cursor까지 함께 보는 것이 합리적입니다. 2) 핵심 비교: 모델 4종 + 도구 1종","text":"한줄 요약업무에서 바로 도움이 되는 선택을 하려면 모델(두뇌) + 도구(손발)**를 함께 보셔야 합니다. 코딩·리팩터링은 **GPT-5/Claude가 안정적이고, 긴 문서 요약·분석은 Gemini 2.5가 유리합니다. 난도 높은 탐구형 문제는 Grok 4가 아이디어를 잘 뽑아냅니다. 그리고 실제 개발 현장에서는 Cursor(커서) 같은 AI 편집기가 프로젝트 단위 작업을 빠르게 밀어 주며 체감 생산성을 크게 끌어올립니다. 1) 왜 지금 비교하나올해 가을은 주요 모델이 한 차례씩 업그레이드된 뒤 안정화 구간에 접어든 시점입니다. 즉, 우리 일에 바로 들이기 좋은 타이밍입니다. 특히 최근에는 단순 자동완성(다음 코드 예측)만으로는 부족하고, 에이전트(작업을 단계별로 대신 처리하는 AI 도우미)와 긴 문맥 처리(수백 페이지를 한 번에 이해)가 실제 생산성 차이를 만듭니다. 이런 흐름에서 모델만 볼 게 아니라, IDE(코드 편집기) 레벨의 AI 도구인 Cursor까지 함께 보는 것이 합리적입니다. 2) 핵심 비교: 모델 4종 + 도구 1종 A. GPT-5 (OpenAI)강점: 범용형. 코딩, 글쓰기, 멀티모달(텍스트·이미지·오디오를 함께 다루는 방식) 전반에서 균형이 좋습니다. 복잡한 리팩터링과 테스트 조율을 안정적으로 이끕니다.추천 작업: 레거시 코드 개선, 다국어 코드 리뷰, 문서·데이터·이미지를 섞은 리서치. B. Gemini 2.5 Pro / Flash (Google)강점: 긴 문맥(Long context: 수십만~백만 토큰 규모의 큰 문서 묶음)**을 한 번에 다루는 능력이 강합니다. 사양서·정책집·논문 다발을 통째로 넣고 요약/비교/근거 인용하기에 유리합니다. Flash 계열은 속도·비용 효율 중심입니다.**추천 작업: 대용량 문서 요약, 규정 변경 전후 비교, 보고서 아웃라인 생성. C. Claude 3.7 (Anthropic)강점: 실전형 코딩 이슈 해결과 코드 품질·정책 준수 같은 보수적 환경에서 평가가 좋습니다. 설명이 차분하고 문맥 유지가 안정적입니다.추천 작업: 대규모 리팩터링, 보안·정책 민감한 코드 리뷰, 사내 코딩 가이드 준수 작업. D. Grok 4 (xAI)강점: 난도 높은 추론(수학·물리·퀀트의 복잡한 사고 문제)에 강점이 있다는 평가가 많습니다. 초기 브레인스토밍에서 유용한 가설과 접근법을 다양하게 제시합니다.추천 작업: 연구형 문제 아이디에이션, 복잡한 가설 수립, 난문항 풀이 전략 수립. E. Cursor(커서) — VS Code 기반 AI IDE(코드 편집기)강점: 프로젝트 단위로 일을 밀어 주는 기능이 강합니다. 자동완성(Tab completion: 타이핑 전에 다음 코드를 제안)과 대화형 수정(Chat: 자연어로 ‘이 파일/이 함수만 고쳐줘’)은 기본이고, 스코프 지정 변경(Scoped changes: 바꿀 범위를 한정), 에이전트(Agent: 단계별 작업 실행), Bugbot(버그봇: Pull Request 자동 리뷰), CLI(명령줄) 자동화까지 제공해 다중 파일 수정 → PR 품질 관리 → 배치 자동화를 한 흐름으로 연결합니다. VS Code 확장 생태계와의 친화도도 높아 기존 개발 환경을 크게 바꾸지 않고 도입할 수 있습니다.추천 작업: 여러 파일을 동시에 리팩터링하거나 동일 규칙을 일괄 적용(예: API 교체, 코딩 컨벤션 정리) PR(풀 리퀘스트: 코드 합치기 전 변경 제안) 병목을 줄이고 자동화된 리뷰·수정 제안을 받고 싶은 팀 협업 에디터 밖에서도 반복 규칙을 대량으로 적용하려는 배치 자동화(예: CLI로 다수 저장소 병렬 점검/수정) IDE 안에서 모델 전환(GPT/Claude/Gemini 등)을 하며 상황별로 품질·속도를 최적화 3) 언제 무엇을 쓰면 좋은가(상황별 추천) 대규모 문서 요약/근거 인용 → Gemini 2.5로 1차 요약 후, GPT-5로 해설·표현 다듬기(긴 문맥 처리 + 읽기 쉬운 설명의 조합) 레거시 코드 고치기·리팩터링(팀 협업) → Cursor + (GPT-5 또는 Claude). Cursor의 스코프 지정·다중 파일 수정·PR 자동 리뷰로 “일(작업 단위)”을 전개하고, 모델은 정확도/설명력을 위해 GPT-5/Claude를 선택 난도 높은 연구형 문제(수학/물리/퀀트) → Grok 4로 아이디어 풀을 넓히고, GPT-5로 검증·정리 속도·비용이 중요한 반복 작업 → Claude(경량) 또는 Gemini Flash IDE 안에서 전부 처리하고 싶다 → Cursor 단독으로 에이전트·Bugbot·CLI까지 구성. 필요하면 모델 스위치로 품질/속도 조절 4) 실전 워크플로우 예시예시 1: “문제 정의 → 스코프 제한 → 자동 수정 → PR 리뷰 → 머지” 문제 정의: 목표와 제약을 명확히 적기 예시: 목표—data/legacy/ 폴더의 순환 의존성 제거 / 제약—퍼블릭 API(바깥에서 부르는 함수 모양)는 유지 스코프 제한: Cursor에서 바꿀 범위를 해당 폴더로 지정(Scoped changes: 엉뚱한 파일 수정 방지) 자동 수정: 에이전트에게 “실패 테스트 먼저 통과하는 최소 패치”와 “근본 리팩터링안” 두 가지를 요청해 차이·리스크 비교 PR 자동 리뷰: PR을 열고 Bugbot으로 보안·성능·품질을 자동 점검(High/Med/Low 라벨 &amp; 수정 제안 반영) 머지/롤백 준비: 커밋 메시지와 변경 이유 자동 요약, 실패 시 롤백 절차 기록 예시 2: “긴 문서 100개 요약·근거 인용” Gemini 2.5에 문서 묶음을 넣고 전/후 변화표, 출처 페이지 번호, 반대 견해까지 표로 출력(긴 문맥 강점) GPT-5로 핵심 논지와 리스크를 문장력 있게 다듬어 리더블(읽기 쉬운)하게 정리 블로그용 요약 카드(3~5줄)와 CTA(다음 실험 예고) 작성 예시 3: “에디터 밖 배치 자동화” Cursor CLI(명령줄 인터페이스)에서 에이전트를 실행해 여러 저장소를 병렬 스캔하고 규칙에 맞춰 수정 제안 생성 GitHub Actions 등 CI와 연동해 PR이 열릴 때마다 자동 코드 리뷰 실행 5) 쉬운 용어 사전 Agent(에이전트): 목표를 주면 단계를 나눠 대신 처리하는 AI 도우미 Long context(긴 문맥): 수백 페이지 같은 큰 문서/코드를 한 번에 이해하는 능력 Autocomplete(자동완성): 다음에 올 코드를 미리 제안하는 기능 Scoped changes(스코프 지정): 바꿀 파일·폴더 범위를 한정해 안전하게 수정 PR/Pull Request(풀 리퀘스트): 코드 합치기 전에 올리는 변경 제안 CLI(명령줄): 창 대신 글자 명령으로 조작하는 방식. 자동화·배치에 유리 6) 이미지/표 아이디어 작업 유형별 추천 매트릭스: 행—작업(리팩터링, 긴 문서, 연구형 문제, 자동화), 열—GPT-5 / Gemini / Claude / Grok / Cursor. 체크 표시로 한눈에 개발 흐름 지도: 문제 정의 → 스코프 지정 → 자동 수정 → PR 리뷰 → 머지 흐름을 도식화 에디터 vs 도구 비교 카드: Copilot(줄단위 자동완성 중심) vs Cursor(프로젝트 단위 작업). 참고: Copilot도 최근 에이전트 기능을 제공합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"}],"tags":[{"name":"GPT-5","slug":"GPT-5","permalink":"https://tuhbm.github.io/tags/GPT-5/"},{"name":"Gemini 2.5","slug":"Gemini-2-5","permalink":"https://tuhbm.github.io/tags/Gemini-2-5/"},{"name":"Claude 3.7","slug":"Claude-3-7","permalink":"https://tuhbm.github.io/tags/Claude-3-7/"},{"name":"Grok 4","slug":"Grok-4","permalink":"https://tuhbm.github.io/tags/Grok-4/"},{"name":"Cursor","slug":"Cursor","permalink":"https://tuhbm.github.io/tags/Cursor/"},{"name":"코드자동화","slug":"코드자동화","permalink":"https://tuhbm.github.io/tags/%EC%BD%94%EB%93%9C%EC%9E%90%EB%8F%99%ED%99%94/"},{"name":"긴문맥","slug":"긴문맥","permalink":"https://tuhbm.github.io/tags/%EA%B8%B4%EB%AC%B8%EB%A7%A5/"},{"name":"에이전트","slug":"에이전트","permalink":"https://tuhbm.github.io/tags/%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8/"}]},{"title":"일급객체","slug":"first-class-citizen","date":"2021-10-21T21:37:30.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2021/10/21/first-class-citizen/","link":"","permalink":"https://tuhbm.github.io/2021/10/21/first-class-citizen/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 일급객체다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 일급객체다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다. 변수, 배열내에 요소 객체의 프로퍼티등에 할당 가능 함수의 파라미터값으로 전달 및 반환 가능 123456789101112131415const sayHello = () =&gt; &#123; return&#x27;Hi!!! nice to meet you&#x27;;&#125;; //변수에 할당가능const nationsHello = [ &#x27;안녕하세요&#x27;, &#x27;싸와디캅&#x27;, &#x27;Hello&#x27;, () =&gt; &#123; return &#x27;곤니찌와&#x27;, &#x27;봉쥬르&#x27;; &#125;]; // 배열내에 값으로 사용 가능const sayIntroduce = (greeting, name) =&gt; &#123; return `$&#123;greeting&#125; \\n my name is $&#123;name&#125;`;&#125;;sayIntroduce(sayHello(), &#x27;john&#x27;) // 함수의 파라미터로 사용 및 반환 가능 요약일급객체: 변수, 배열등에 프로퍼티로 할당가능하고, 함수의 파라미터의 값으로 전달 가능자바스크립트에서 함수는 결국 값을 리턴하고, 그러므로 어디든 함수로 전달가능하므로 일급객체이다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"함수","slug":"함수","permalink":"https://tuhbm.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"값","slug":"값","permalink":"https://tuhbm.github.io/tags/%EA%B0%92/"},{"name":"function","slug":"function","permalink":"https://tuhbm.github.io/tags/function/"},{"name":"value","slug":"value","permalink":"https://tuhbm.github.io/tags/value/"},{"name":"parameter","slug":"parameter","permalink":"https://tuhbm.github.io/tags/parameter/"},{"name":"first class citizen","slug":"first-class-citizen","permalink":"https://tuhbm.github.io/tags/first-class-citizen/"}]},{"title":"자료정렬","slug":"arrayAlign","date":"2021-09-21T21:37:30.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2021/09/21/arrayAlign/","link":"","permalink":"https://tuhbm.github.io/2021/09/21/arrayAlign/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 정렬지난시간에 알고리즘에 대해 알아보았습니다.알고리즘을 요약하자면, 어떠한 명령어들을 처리하는 과정이라고 하였습니다. 이러한 과정을 함에 있어서 효율적이고 좋은 성능을 통해 개발을 하는 것이 좋은 알고리즘이라고 했었습니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 정렬지난시간에 알고리즘에 대해 알아보았습니다.알고리즘을 요약하자면, 어떠한 명령어들을 처리하는 과정이라고 하였습니다. 이러한 과정을 함에 있어서 효율적이고 좋은 성능을 통해 개발을 하는 것이 좋은 알고리즘이라고 했었습니다. 지난번 전화번호부를 다시 예로 들어 보겠습니다.전화번호부책에서 어떠한 부분을 찾는데,ㄱㅎ까지 AB까지 1~0까지 순서대로 차례로 탐색 또는 검색 방법을 순차적검색 또는 선형탐색이라고합니다. 하지만ㄱㅎ까지 AB까지 1~0까지 순서가 없이 마구잡이로 섞여있다고 가정을 해봅니다.Q, I, O, P, D, J, A, M, N, S, W, E, Z, X, B, L, H, F, U, T, Y, R이렇게 정렬되어있지 않은 부분에서 무언가 찾으려면, 시간이 걸립니다.또한 더 복잡한 데이터안에서 무언가 찾기란 쉽지 않습니다. 그렇기때문에 전화번호부는 AZ까지 ㄱㅎ까지 정렬이 되어있는 것을 볼 수 있습니다. *’데이터는 원하는 형태로 정렬될 때 비로소 의미 있는 정보가 된다.’*라는 말이 있습니다.많은 정보를 가지고 있음에도 활용을 하려면 정렬되어 있는 상태로 있어야 그 정보를 활용할 수 있다는 말입니다. 그렇기에 데이터를 활용할때 정렬하는 방법 중 몇가지에 대해 말해보겠습니다. 버블정렬버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말합니다.단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중합니다.두 개의 인접한 수를 비교하고 만약 순서에 맞지 않는다면 교환해주는 방식으로 작동합니다.큰값이 점점 끝쪽으로 거품처럼 밀려나간다고 생각하시면, 이해가 빠를것 같습니다. 예를 들어보겠습니다.5, 1, 6, 2, 4, 3의 리스트를 정렬해보겠습니다.5, 1, 6, 2, 4, 3 첫번째로 5와 1을 비교해 순서를 정렬합니다.1, 5, 6, 2, 4, 3 첫번째 정렬이 이루어졌습니다. 다음은1, 5, 6, 2, 4, 3 5와 6을 비교합니다.1, 5, 6, 2, 4, 3 비교를 해도 5 &lt; 6 이기때문에 그대로 둡니다.다음으로1, 5, 6, 2, 4, 3를 비교합니다.이러한순서로 정렬이되면,1, 5, 2, 4, 3, 6 이됩니다.그러면 다시1, 5, 2, 4, 3, 6을 비교하고1, 5, 2, 4, 3, 6을 비교하여1, 5, 2, 4, 3, 6이런식으로 계속 비교를 하여, 결국1, 2, 3, 4, 5, 6 으로 최종 정렬이됩니다. 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있습니다.n개의 요소를 정렬해 주기 위해서는 n-1번 실행해주어야 합니다.최악의 상황인 경우 최대한의 횟수를 실행해줘야 하므로 경제적이지 않습니다. 선택정렬선택정렬은 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬입니다. 예를 들어보겠습니다.5, 1, 6, 2, 4, 3의 리스트를 정렬해보겠습니다. 5, 1, 6, 2, 4, 3 첫번째로 5와 1을 비교해 순서를 정렬합니다.1, 5, 6, 2, 4, 3 첫번째 정렬이 이루어졌습니다.첫번째까지는 버블정렬과 동일합니다.하지만 선택정렬은 첫 번째 위치(혹은 가장 마지막 위치)의 수가 가장 작은수라는 가정에 의해 이루어집니다. 1, 5, 6, 2, 4, 3을 비교해 5 &lt; 6 이므로 기존을 유지합니다.1, 5, 6, 2, 4, 3을 비교합니다. 2가 가장 작은 수로 둘의 자리를 바꿔줍니다.1, 2, 6, 5, 4, 3가 됩니다. 이렇게 두번째 자리까지 정렬이 완료되었다는 가정하에 다음스텝을 진행합니다.1, 2, 6, 5, 4, *3** 이렇게 세번째 자리의 수와 가장 작은 수를 찾아 자리를 바꾸는 식으로 진행됩니다.이런식으로 최종적으로1, 2, 3, 4, 5, 6으로 정렬됩니다. 선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가합니다.버블 정렬의 교환 횟수보다는 적습니다.그러나 한 번의 교환이 일어나기 위해서는 정렬되지 않은 수의 모든 비교가 이루어져야 하므로, n²번의 비교가 이루어 집니다.선택 정렬은 최선의 경우에도 최악의 경우에서 수행하는 횟수만큼 비교와 교환을 해주어야 합니다. 삽입정렬삽입정렬은 자료가 정렬된 부분과 정렬되지 않은 부분으로 나누어집니다.정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입되는 형태의 정렬 방법입니다. 예를 들어보겠습니다.5, 1, 6, 2, 4, 3의 리스트를 정렬해보겠습니다.정렬되지 않은 리스트에서 첫번째 가장 작은 수를 찾습니다.편의상 | 를 사용해 정렬된부분과 정렬되지 않은 부분을 구분합니다.5, 1, 6, 2, 4, 3 첫번째 제일 작은 수가 정렬됩니다.1 | 5, 6, 2, 4, 3 정렬되지 않은 부분 중 가장 작은 수를 찾습니다. 1보다 큰수입니다.1 | 5, 6, 2, 4, 3 5보다는 작습니다.1, 2 | 5, 6, 4, 3 정렬이됩니다.1, 2 | 5, 6, 4, 3 다시 가장작은 수를 찾습니다. 정렬된 숫자중 가작 작은수인 1과 비교를 하고 1 &lt; 3이므로 다음으로 넘어갑니다.1, 2 | 5, 6, 4, 3 다음 정렬된 수와 비교를 합니다. 2 &lt; 3이므로1, 2, 3 | 5, 6, 4그다음으로 들어갑니다.이렇게 처음을 제외하고 다음부터는 작은 수를 찾아 정렬된 수와 비교한 후 제자리를 찾아 나머지를 밀어내는 방식으로 정렬됩니다. 삽입 정렬은 특정 실행 단계에서, 어떤 원소가 정렬된 배열 내에 자리를 찾았다고 해서 그것이 최종적인 제자리라는 보장은 없습니다. 다음 단계가 진행되면서 다른 자료에 의해 위치가 바뀔 수 있기 때문입니다. 따라서 삽입 정렬은 자료의 양이 적을 때 성능이 우수하며 자료 대부분이 이미 정렬이 되어있는 경우 효율적입니다. 삽입정렬은 이미 정렬된 자료에 새로운 자료를 삽입해야 하는 경우가 발생하면, 정렬된 자료들이 자리를 이동해야 하므로 안정성이 낮습니다. 합병정렬합병 정렬은 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식입니다.합병정렬의 장점은 가장 빠른 정렬방법입니다.단점은 시간은 가장 빠르게 처리하면서, 메모리를 매우 많이 차지 한다는 점입니다. 바로 예를 들어보겠습니다.5, 1, 6, 2, 4, 3, 8, 7의 리스트를 정렬해보겠습니다.편의상 | 를 통해 구분을 하겠습니다.5, 1, 6, 2, 4, 3, 8, 7 가장 먼저 앞에 두수를 비교해 정렬 후 하나로 합칩니다.1, 5 | 6, 2, 4, 3, 8, 7 비교를 하지 않은 두수를 비교해 역시 정렬 후 하나로 합칩니다.1, 5 | 6, 2 | 4, 3, 8, 7 이런식으로 쭉쭉 진행하여1, 5 | 6, 2 | 4, 3 | 8, 7 이렇게 4개의 리스트로 변경되었습니다.1, 5 | 6, 2 | 4, 3 | 8, 7 이렇게 두개의 정렬된 데이터를 비교해 정렬 후 합칩니다.1, 2, 5, 6 | 4, 3 | 8, 7 이런방식으로 일어나는데 다음으로는1, 2, 5, 6 | 4, 3, 8, 7 이렇게 될 것입니다.1, 2, 5, 6 | 4, 3, 8, 7 다음엔 또 두개의 리스트를 비교하고최종적으로 1, 2, 3, 4, 5, 6, 7, 8 하나의 리스트로 정렬하게됩니다. 이렇게 나누어지고 합쳐지는 중간 단계의 배열을 임시로 저장하고 함수가 종료될 때 까지 기억하고 있어야 하기 때문에,메모리의 필요한 공간이 늘어납니다. 합병 정렬 역시 반을 나눈다는 개념이 사용되기 때문에 시간이 적게 들 것이라고 유추할 수 있습니다.만약 8개의 원소가 있다면 3번 나누어질 것입니다. 따라서 n개의 원소가 있을 때 완전히 다 나누어지기까지 호출되는 함수의 개수는 log n개라는 것을 알 수 있습니다.그리고 합병 정렬은 병합하는 알고리즘을 포함합니다.합쳐지는 과정에서 각 원소들의 크기를 비교하기 때문에 n번의 비교 과정이 있습니다. 즉 한번 나누어질 때마다 n번의 비교 횟수가 추가되는 것입니다. 요즘 같이 성능이 좋은 하드웨어가 많은 경우 합병정렬하는데 무리가 가지 않습니다.하드웨어의 성능을 고려하며, 상황에 적합하다면 합병정렬을 사용하는 방법이 가장 효율적으로 정렬 할 수 있는 방법입니다. 정리이처럼 정렬에는 다양한 방법이 있습니다.버블정렬, 선택정렬, 삽입정렬, 합병정렬 등등…. 다양한방법을 상황에 맞게 올바른 정렬방법을 사용하여,정보들을 원하는 형태로 정렬하여, 정보를 의미있게 사용하여, 효율적으로 정보전달을 해야합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"효율성","slug":"효율성","permalink":"https://tuhbm.github.io/tags/%ED%9A%A8%EC%9C%A8%EC%84%B1/"},{"name":"algorithm","slug":"algorithm","permalink":"https://tuhbm.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://tuhbm.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"개발","slug":"개발","permalink":"https://tuhbm.github.io/tags/%EA%B0%9C%EB%B0%9C/"}]},{"title":"첫 연봉의 중요성","slug":"importanceOfFirstAnnualSalary","date":"2021-08-11T22:35:06.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2021/08/11/importanceOfFirstAnnualSalary/","link":"","permalink":"https://tuhbm.github.io/2021/08/11/importanceOfFirstAnnualSalary/","excerpt":"‘시작이 반’ 이라는 말이 있다. 이처럼 첫연봉은 사회로 나온 처음으로 매겨진 나의 가치이다.모든 직업과 직군에 따라 하는 업무와 연봉과 사회적 지휘 그리고 준비과정은 각각 다르다.그리고 본인이 하고 있는 직군을 그만두고 새로운 일을 시작 하지 않는 이상 본인이 준비했던 직군의 일을 계속 할 것이다.나는 현재 개발자로써 직장생활에서의 느낀 점을 적어보려한다. 물론 각 직군마다 내가 말한 점과는 다를 수 있다.","text":"‘시작이 반’ 이라는 말이 있다. 이처럼 첫연봉은 사회로 나온 처음으로 매겨진 나의 가치이다.모든 직업과 직군에 따라 하는 업무와 연봉과 사회적 지휘 그리고 준비과정은 각각 다르다.그리고 본인이 하고 있는 직군을 그만두고 새로운 일을 시작 하지 않는 이상 본인이 준비했던 직군의 일을 계속 할 것이다.나는 현재 개발자로써 직장생활에서의 느낀 점을 적어보려한다. 물론 각 직군마다 내가 말한 점과는 다를 수 있다. 과거 나보다 먼저 취업을 한 친구들이 아직 취업을 하지 못한 친구들에게 하는 말중 기억에 남는 이야기가 한가지 있다. 첫 연봉의 차이가 나중까지 간다고 하더라.이말을 듣고, 계속된 취업에 도전하고 있는 나는 생각했다.‘무슨 말도 안되는 소리를 하는거지? 연봉에서 가장 중요한 부분은 본인의 능력이지!’ 회사를 다니면서 5년차까지는 이런 생각을 갖고 있었다.하지만 퇴사하는 선배 또는 동기들의 연봉을 알고 나서부터 생각이 바뀌었다.A는 계약직으로 시작해 정사원을 거쳐 대리급으로 퇴사하였고, B신입사원 공채를 통해서 입사하여 대리급으로 퇴사를 하였다. 같은 비슷한 직급으로 퇴사시기의 차이는 있지만 두사람이 같은 회사에서 받고 있던 연봉을 들었을때 나는 매우 놀랐다. A와 B의 연봉은 거의 앞자리가 다른 천만원 이상의 차이가 있었다. 이것을 알게된 후 과거 친구가 얘기했던 말이 떠올랐다. ‘첫연봉의 차이가 이렇게 크구나….’ A는 B에 비해 업무적으로 뒤떨어지지 않았다. 오히려 회사에서 더 장기 근속하며, 성실하게 일을 하였고 계약직으로 시작하여 계약직 종료시점에 회사에서 정직원 전환을 권유해 입사했을 정도로 평가가 좋았다.업무를 하면서 A는 커뮤니케이션도 잘하고 후배도 잘챙기며, 본인 업무도 잘 진행하는 선배였다. 반면 B는 주변을 챙기기 보다는 본인의 업무를 중심적으로 업무를 진행 하는 스타일이었다. 그렇기에 주변 평판도 A보다는 B가 더 좋았었다. 심지어 A가 회사에 전반적인 업무에 대한 히스토리와 프로세스를 B에게 알려 줄 정도로 후배인 나에게는 A가 뛰어나 보였다. 둘다 첫 회사였고, 신입사원 프로세스를 거쳐 입사하게 된 케이스다.A와 B의 차이는 성별도 같았고, 나이도 같았다. 다만 차이라고하면 A는 전문대를 나와 회사에서 계약직으로 근무하면서도 방통대를 다니며 학력을 쌓아 학사졸업 후 정규직이 되었고, B는 서울의 4년제 학교를 졸업하고 약 1년정도의 취업 준비기간을 통해 공채로 정규직이 되었다. 둘의 첫 연봉의 차이는 같은 평가를 받아도, 심지어 A가 B보다 더 좋은 평가를 받은 해가 있었음에도 둘의 격차는 퇴사 할때까지 따라잡히지 못한 것이다. 같은 회사에서 보는 입사의 형태와 입사 시기 그리고 학벌의 차이에 이런 격차는 존재했는데, 과연 타회사를 보면 어떨까? 현재는 코로나 여파와 서비스들의 비대면 서비스 전환 등으로 인하여, 좋은 개발자들은 많은 돈을 주고 모셔간다는 말이 있을 정도로 개발자들이 좋은 대우를 받고있다. 이는 경력자 뿐만아니라 신입사원 또한 포함이다. 입사하는 과정이 각각 회사마다 다르겠지만 많은 사람들이 개발자로써의 시작을 꿈꾸고 있다. 하지만 많은 회사들은 신입들에게 각각 다른 연봉으로 시작하고 있다. 내가 아는 A사와 B사는 각각 회사 규모도 다르고, 신입사원을 뽑는 절차도 다르다. 두회사의 연봉차이도 회사에 따라 앞자리가 다름은 물론이고 1,500만원차이가 난다.이렇게 시작시점부터 비슷한 시기에 첫 직장생활을 하더라도 차이가 벌어진 상태로 시작을 한다. 부모님 세대에는 한번 회에사 입사를 하면 정년퇴임까지 다녀야한다고 생각하시는 분들이 많았다. 하지만 개발자들은 다른 직군에 비해 이직이 매우 잦은 편이다. 내가 신입으로 처음 회사생활을 할때만 해도 ‘개발자들은 타직군에 비해 초봉이 낮기때문에 이직을 하면서 연봉을 올린다.’ 라는 말을 많이 들었다. 그렇기에 연봉을 올리기 위해 잦은 이직을 하는 경우도 많았다. 과거에는 보통 이력서를 내고, 면접을 보고 입사하는 과정을 거쳤다. 그렇기에 비교적 간단한 과정이었다. 하지만 요즘 개발자들을 뽑는 과정은 매우 까다로워졌다. 이력서를 내고 서류에 합격하여도, 알고리즘 시험 또는 과제등을 통과해야 면접의 기회가 주어진다. 이런 모든 과정을 통과하면 채용이 되는 과정이다. 사실 중간에 시험 또는 과제 하나 들어간 부분이라 간단해 보일 수 있지만 해당 내용을 통해 채용하려는 회사는 지원자의 실력 또는 팀원으로 함께 개발이 가능한지 여부도 파악을 할 수 있다. 심지어 어떤 회사는 과제이후 전화면접과 실무면접등 면접을 하루종일 보는 기업도 있고, 회사에서 교육과정을 통해 교육을 받고, 그중 우수한 사람을 채용하는 회사도 있다. 그렇기에 취업 및 이직은 매우 어렵다. 그렇기에 위에 언급했던 ‘이직을 통해, 연봉을 올린다.’ 라는 말도 매우 힘들어진 상황이다. 모든 사람들이 첫시작을 좋게 시작 할 순 없다. 무조건 노력해서 최고의 연봉을 받고 시작을 하라는 이야기는 아니다. 모든 업종이 내가 말한 부분에 부합하지 않을 수도 있다. 하지만 첫연봉을 통해 내친구 또는 동료 들과 격차는 점점 벌어질 수 있다. 그 격차를 줄이려면 그사람보다 몇배는 노력하고 세월이 지나야 줄일 수 있다. 그러므로 첫연봉은 매우 중요하며, 사회에서 보는 나의 가치의 시작임을 말하고 싶다.","categories":[{"name":"Column","slug":"Column","permalink":"https://tuhbm.github.io/categories/Column/"}],"tags":[{"name":"초년생","slug":"초년생","permalink":"https://tuhbm.github.io/tags/%EC%B4%88%EB%85%84%EC%83%9D/"},{"name":"연봉","slug":"연봉","permalink":"https://tuhbm.github.io/tags/%EC%97%B0%EB%B4%89/"},{"name":"월급","slug":"월급","permalink":"https://tuhbm.github.io/tags/%EC%9B%94%EA%B8%89/"},{"name":"격차","slug":"격차","permalink":"https://tuhbm.github.io/tags/%EA%B2%A9%EC%B0%A8/"}]},{"title":"얕은복사(shallow copy)&깊은복사(deep copy)","slug":"copy","date":"2021-03-17T21:45:01.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2021/03/17/copy/","link":"","permalink":"https://tuhbm.github.io/2021/03/17/copy/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의복사 - 원본을 베낌. 원본을 본뜨거나 그대로 옮겨 놓는것","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의복사 - 원본을 베낌. 원본을 본뜨거나 그대로 옮겨 놓는것 자바스크립트에서 복사( a = b)의 방법은 값에 타입에 따라 할당 또는 참조의 형태로 실행된다. 사실 어떠한 값을 변수에 지정시 변수명은 데이터의 메모리 공간에 대한 주소를 가르킨다. 이러한 부분은 데이터의 형태에 따라 복사시 실제 값을 할당하거나, 그 데이터의 값을 참조하는 형태로 복사된다. 원시타입 Number String Boolean Null Undefined 원시타입은 깊은 복사로 해당 값에 대한 메모리에 저장된 데이터를 ‘원본데이터값 자체를 복사한다.’ 라고 생각하면 이해가 쉽다. 그렇기에 새로 복사된 데이터을 직접 조작 및 변경해도 기존의 원본 데이터에는 영향이 없다. 참조타입 Object Symbol 참조타입은 말그대로 해당 메모리에 대한 주소를 참조(해당 주소를 바라본다 정도로 해석)한다고 볼 수 있다. 그렇기에 원본 데이터 또는 복사된 데이터의 값을 조작한다면 같은 메모리의 주소값을 참조하므로 값이 변경된다. 데이터의 타입에 따라 깊은 복사와 얕은 복사가 진행되지만, 참조타입의 데이터도 얕은 복사를 할 수 있는데, 그 방법은 아래와 같다 참조타입의 얕은복사 Object.assign() 메소드 사용 Spread operator 사용 요약얕은 복사(참조타입) = 같은 메모리 주소를 참조하므로 값이 기존 데이터도 변경깊은 복사(원시타입) = 데이터의 값만 복사하므로 변경시 기존 데이터 영향 없음 예시얕은 복사(참조) 123456789let a = 1;let b = a;console.log(a); // 1console.log(b); // 1a = 2;console.log(a) // 2console.log(b) // 1 깊은 복사 12345678910let a = &#123; name: &#x27;Park&#x27;&#125;;let b = a; // 참조console.log(a); //&#123;name: &quot;Park&quot;&#125;console.log(b); //&#123;name: &quot;Park&quot;&#125;a.name = &#x27;Kim&#x27;;console.log(a); //&#123;name: &quot;Kim&quot;&#125;console.log(b); //&#123;name: &quot;Kim&quot;&#125;","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"shallow copy","slug":"shallow-copy","permalink":"https://tuhbm.github.io/tags/shallow-copy/"},{"name":"deep copy","slug":"deep-copy","permalink":"https://tuhbm.github.io/tags/deep-copy/"},{"name":"원시값","slug":"원시값","permalink":"https://tuhbm.github.io/tags/%EC%9B%90%EC%8B%9C%EA%B0%92/"},{"name":"참조값","slug":"참조값","permalink":"https://tuhbm.github.io/tags/%EC%B0%B8%EC%A1%B0%EA%B0%92/"}]},{"title":"API(Application Programming Interface)","slug":"api","date":"2021-03-16T21:45:01.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2021/03/16/api/","link":"","permalink":"https://tuhbm.github.io/2021/03/16/api/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의API(Application Programming Interface 애플리케이션 프로그래밍 인터페이스, 응용 프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의API(Application Programming Interface 애플리케이션 프로그래밍 인터페이스, 응용 프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. 요약API(Application Programming Interface)소프트웨어와 소프트웨어간 상호작용을 통해 기능을 제어 할 수 있도록 만든 인터페이스 입니다. 12인간 &lt;-- x --&gt; 소프트웨어소프트웨어 &lt;-- o --&gt; 소프트웨어 예시 카카오 api(https://developers.kakao.com/) 네이버 api(https://developers.naver.com/main/) 공공데이터포털서비스(https://www.data.go.kr/)","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"application","slug":"application","permalink":"https://tuhbm.github.io/tags/application/"},{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"Interface","slug":"Interface","permalink":"https://tuhbm.github.io/tags/Interface/"},{"name":"애플리케이션","slug":"애플리케이션","permalink":"https://tuhbm.github.io/tags/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"인터페이스","slug":"인터페이스","permalink":"https://tuhbm.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"소프트웨어 상호작용","slug":"소프트웨어-상호작용","permalink":"https://tuhbm.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9/"}]},{"title":"인터페이스(interface)","slug":"interface","date":"2021-03-15T20:58:59.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2021/03/15/interface/","link":"","permalink":"https://tuhbm.github.io/2021/03/15/interface/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의 전기 신호의 변환(變換)으로 중앙 처리 장치와 그 주변 장치를 서로 잇는 부분. 또는, 그 접속 장치. 키보드나 디스플레이 등처럼 사람과 컴퓨터를 연결하는 장치. 소프트웨어끼리 접촉·공통되는 부분. 순화어는 `접속’. 사물과 사물 사이 또는 사물과 인간 사이의 경계에서, 상호 간의 소통을 위해 만들어진 물리적 매개체","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 사전적정의 전기 신호의 변환(變換)으로 중앙 처리 장치와 그 주변 장치를 서로 잇는 부분. 또는, 그 접속 장치. 키보드나 디스플레이 등처럼 사람과 컴퓨터를 연결하는 장치. 소프트웨어끼리 접촉·공통되는 부분. 순화어는 `접속’. 사물과 사물 사이 또는 사물과 인간 사이의 경계에서, 상호 간의 소통을 위해 만들어진 물리적 매개체 요약 쉽게 표현하면 매개체와 매개체의 상호작용이 가능한 접점이나 경계면 또는 매개체를 인터페이스라 표현한다. 예시 USB와 컴퓨터 =&gt; USB 포트 사람과 다리미 =&gt; 다리미손잡이 또는 조작버튼 음료와 사람 =&gt; 사람의 입","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"interface","slug":"interface","permalink":"https://tuhbm.github.io/tags/interface/"},{"name":"매개체","slug":"매개체","permalink":"https://tuhbm.github.io/tags/%EB%A7%A4%EA%B0%9C%EC%B2%B4/"},{"name":"연결고리","slug":"연결고리","permalink":"https://tuhbm.github.io/tags/%EC%97%B0%EA%B2%B0%EA%B3%A0%EB%A6%AC/"},{"name":"접속","slug":"접속","permalink":"https://tuhbm.github.io/tags/%EC%A0%91%EC%86%8D/"},{"name":"접촉","slug":"접촉","permalink":"https://tuhbm.github.io/tags/%EC%A0%91%EC%B4%89/"},{"name":"경계","slug":"경계","permalink":"https://tuhbm.github.io/tags/%EA%B2%BD%EA%B3%84/"}]},{"title":"심플 소프트웨어","slug":"simpleSoftware","date":"2019-11-14T20:28:20.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2019/11/14/simpleSoftware/","link":"","permalink":"https://tuhbm.github.io/2019/11/14/simpleSoftware/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 심플 소프트웨어 한줄평 리뷰읽다 보면 자기 반성을 하게되는 책!","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 심플 소프트웨어 한줄평 리뷰읽다 보면 자기 반성을 하게되는 책! 책정보판매처 : 길원재 : 심플 소프트웨어(코드의 단순성, 가독성, 안정성, 유지보수)저자 : 맥스 카넷-알렉산더역자 : 이미령출간 : 2019-10-30페이지 : 228 쪽가격 : 정가 18,000원 -&gt; 판매가 16,200원(10% off) 상세정보 네이버 북스 소개내 소스코드가 5~10년 후에 후임자 혹은 다른사람에게 보여진다면, 어떤 생각을 할까? 소프트웨어의 패러다임은 계속해서 변하고 있다.객체지향 프로그래밍, 함수형 프로그래밍등 다양한 방법의 프로그래밍 패러다임에 영향을 받지 않는 누가보아도 이해가 쉬운 깔끔한소위말해 가독성이 좋은 안정적인 코드를 위한 심플한 소프트웨어의 코드를 작성하는 방법 이 책에 들어있다. 이직에 대한 뽐뿌가 왔을때 또는 이직 준비 중일때 필수 서적으로 읽어도 되겠다 싶을 정도로 추천을 하고 싶다. 장점 책이 다른 책보다 작다. 단락 전달하고 싶은 이야기를 잘 나누었다. 책 조차 가독성이 좋다. 단점 굳이 꼽은 단점이라면….? 클린코드를 기반으로 해서 매우 유사하다. 후기이책을 읽게 된 계기는 책소개에 쓰여있는 한문장이었다. 100년 뒤에도 유용할 소프트웨어 설계 원칙 &amp; 프로그래머의 바른 길!책을 읽기전에 ‘실제 100년 후에 쓰이는 소프트웨어가 어디있을까?’ 하며 비웃으며 설마했다.하지만 책을 읽으면서 자기반성을 하게되는 내용이었다. 클린코드는 물론 읽었었다. 하지만 그것을 적용하고 있는가? 다시한번 돌아보았다.클린코드의 내용을 기반으로 한 책이지만, 더 쉽고 얇아 이동중에 읽기 편했다. 그렇기에 출근중에 읽으며 어제 내가 작성한 코드를 반성하게 만들었다.아침에 출근길에 읽은 책 내용을 기반으로 모니터에 하나하나 포스트잇에 적어보자.그렇다면 어쩌면 내코드를 100년 후에 쓸수도 있지 않을까….?","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"book","slug":"book","permalink":"https://tuhbm.github.io/tags/book/"},{"name":"review","slug":"review","permalink":"https://tuhbm.github.io/tags/review/"},{"name":"심플","slug":"심플","permalink":"https://tuhbm.github.io/tags/%EC%8B%AC%ED%94%8C/"},{"name":"소프트웨어","slug":"소프트웨어","permalink":"https://tuhbm.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/"},{"name":"software","slug":"software","permalink":"https://tuhbm.github.io/tags/software/"}]},{"title":"프로그래밍 면접 이렇게 준비한다","slug":"book-review-interviewBook","date":"2019-09-15T21:32:20.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/09/15/book-review-interviewBook/","link":"","permalink":"https://tuhbm.github.io/2019/09/15/book-review-interviewBook/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 프로그래밍 면접 이렇게 준비한다 한줄평 리뷰처음 모든 구직자들을 위한 자신의 성향 파악에서 시작하여, 프로그래머로써의 질문에 대한 답을 하는 과정으로 진행 후 전화면접을 지나 최종적으로이력서에 대한 내용까지 1부터 10까지의 내용이 포함되어있는 프로그래머의 구직과정 전반에 대한 모든 내용을 담고 있다.또한 단 한번만 읽고 끝내는 책이 아닌, 두고두고 곱씹어보며 이직에 대한 뽐뿌가 왔을때마다 또는 면접을 준비할 때마다 보면 좋을책이다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 프로그래밍 면접 이렇게 준비한다 한줄평 리뷰처음 모든 구직자들을 위한 자신의 성향 파악에서 시작하여, 프로그래머로써의 질문에 대한 답을 하는 과정으로 진행 후 전화면접을 지나 최종적으로이력서에 대한 내용까지 1부터 10까지의 내용이 포함되어있는 프로그래머의 구직과정 전반에 대한 모든 내용을 담고 있다.또한 단 한번만 읽고 끝내는 책이 아닌, 두고두고 곱씹어보며 이직에 대한 뽐뿌가 왔을때마다 또는 면접을 준비할 때마다 보면 좋을책이다. 책정보판매처 : 한빛미디원재 : 프로그래밍 면접, 이렇게 준비한다(4판)저자 : 존 몽건, 노아 킨들러, 에릭 기게리번 : 서환수출간 : 2019-07-04페이지 : 568 쪽가격 : 정가 28,000원 -&gt; 판매가 25,200원(10% off) 상세정보 한빛미디어 소개구직활동에 있어 전반적인 모든 과정을 총 망라해서 기술하고있다.처음 자신의 성향에 대한 파악을 시작으로, 입사지원절차(회사 선택, 헤드헌터 활용)의 과정을 통해 지원 그후 전화면접 그리고 순차적으로 프로그래머로써 알고있어야하는 기초지식들에 대해설명해주고있다.본인이 알고 있지 못한 지식은 간단하게 책을 통해 습득하고, 검색을 통해 기초역량을 채워 나가면 될것 같다.그 후 이력서를 작성하는 방식까지 자아성찰 및 성향파악을 시작으로 이력서 작성 및 절차를 통해 면접을 보는과정과 면접 내용까지 모든 내용을 설명하고 있다.현재 4판까지 지속적으로 업데이트 되고있다. 이직에 대한 뽐뿌가 왔을때 또는 이직 준비 중일때 필수 서적으로 읽어도 되겠다 싶을 정도로 추천을 하고 싶다. 장점 정말 친절하게도 모든 과정에 대한 친절한 설명, 필수질문목록 및 예상질문등으로 면접준비가 가능하다. 단점 전문적으로 세분화된 프로그래밍 분야까지는 나누어지진 않았으므로, 필요한 분야별 독자의 자체 필터링을 요구한다.하지만 개인적인생각으로 모든부분 빼놓지 않고 보길 바란다. 후기역시 이직이란 쉬운것이 아니라는 것을 다시 한번 깨닫게 해주는 책이었다.또한 나자신을 다시 한번 돌아보게 해주는 책이었다. 목표 설정을 통해 성공적인 이직을 할 수 있도록 디딤들이 될 수 있는 책이었다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"interview","slug":"interview","permalink":"https://tuhbm.github.io/tags/interview/"},{"name":"layout","slug":"layout","permalink":"https://tuhbm.github.io/tags/layout/"},{"name":"book","slug":"book","permalink":"https://tuhbm.github.io/tags/book/"},{"name":"review","slug":"review","permalink":"https://tuhbm.github.io/tags/review/"}]},{"title":"SMACSS","slug":"book-review-smacss","date":"2019-08-21T21:32:20.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/08/21/book-review-smacss/","link":"","permalink":"https://tuhbm.github.io/2019/08/21/book-review-smacss/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 새로운 CSS 레이아웃 한줄평 리뷰css 방법론 중에 한가지인 SMACSS에 대해 설명되어 있다. 기초(Base) 레이아웃(Layout) 모듈(Module) 상태(States) 테마(Theme)위와 같은 구조로 css의 구조를 설정하여, 탄탄한 CSS구조와 유연함을 동시에 잡을 수 있는 장점을 가지고 있다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 새로운 CSS 레이아웃 한줄평 리뷰css 방법론 중에 한가지인 SMACSS에 대해 설명되어 있다. 기초(Base) 레이아웃(Layout) 모듈(Module) 상태(States) 테마(Theme)위와 같은 구조로 css의 구조를 설정하여, 탄탄한 CSS구조와 유연함을 동시에 잡을 수 있는 장점을 가지고 있다. 책정보판매처 : 네이버 북원재 : SMACSS : Scalable and Modular Architecture for CSS저자 : 조나단 스눅역자 : 박소은출간 : 2016-01-20페이지 : 120 쪽가격 : 정가 12,000원 -&gt; 판매가 10,800원(10% off) 상세정보 네이버 북 소개Scalable and Modular Architecture for CSS의 약어이다.위의 단어 해석 그대로 CSS의 확장 가능한 모듈식 아키텍처를 5가지 구조로 나눠 유연함과 정교함을 갖고있다.또한 이책에선 간단한 예제를 통해 설명을 해주고 있다. 장점 다른 CSS의 방법론과의 장단점 비교 및 예제코드를 통해 CSS구조화 방법을 쉽게 이해 할 수 있다. 단점 책의 분량이 적은 만큼 더욱 복잡한 구조에서 어떻게 사용해야 할지에 대한 부분을 참고하려고 했으나, 그정도 설명까지는 없었다. 후기최근 회사 마크업 가이드를 작성하는데 방법론을 익히고 비교 분석하여, 내부 가이드를 작성하기 위해 읽게 되었다.하지만 SMACSS의 장점에 대해서 알게되었으나, 무언가 최근 들어 개발하는 컴포넌트의 형태의 CSS를 작성하는데는 좀 더 명확하게답을 내리기 어려워졌다. 더욱 깊은 고민에 빠지게 만든 SMACSS였다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"layout","slug":"layout","permalink":"https://tuhbm.github.io/tags/layout/"},{"name":"smacss","slug":"smacss","permalink":"https://tuhbm.github.io/tags/smacss/"},{"name":"theme","slug":"theme","permalink":"https://tuhbm.github.io/tags/theme/"},{"name":"base","slug":"base","permalink":"https://tuhbm.github.io/tags/base/"},{"name":"module","slug":"module","permalink":"https://tuhbm.github.io/tags/module/"},{"name":"states","slug":"states","permalink":"https://tuhbm.github.io/tags/states/"}]},{"title":"혼자 공부하는 C언어","slug":"personalClanguage","date":"2019-08-07T22:10:20.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2019/08/07/personalClanguage/","link":"","permalink":"https://tuhbm.github.io/2019/08/07/personalClanguage/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 혼자 공부하는 C언어 한줄평 리뷰어마어마한 두께만큼 배울때 보면 좋은도서다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 혼자 공부하는 C언어 한줄평 리뷰어마어마한 두께만큼 배울때 보면 좋은도서다. 책정보 판매처: 한빛출판네트워크저자 : 서현우출간 : 2019-06-10페이지 : 664 쪽가격 : 정가 24,000원 -&gt; 판매가 21,600원(10% off) 상세정보 네이버 북스 한빛출판네트워크 소개여느 타 C언어 책보다 분량이 적다. 하지만 책의 페이지 수 보다 중요한건 내용이다.정확히 리뷰를 쓰는 이시점에 완독을 하진 못했지만, 그래도 어느정도 이책의 분위기와 이해도는 판단 할 수 있을정도로초보자를 위한 포인트(암기 포인트)를 집어주고 있어 중요내용 체크가 가능하다. 장점 위에 소개에서 말한대로 공부해야할 포인트를 간략하게 나타내는 것이 아니라, 포인트를 집어주어 초보자들이 다시한번 어느부분을 중점적으로 봐야하는지 판단할 수 있다. 단점 읽어도..머리에 남지 않는…C 언어 및 컴퓨터 지식…ㅠㅠ 후기C언어는 프론트엔드 개발자로써 접하기 정말 어려운 언어이다. JAVA는 OOP의 개념 및 TypeScript등을 통해 어느정도 비슷한 점을 느끼면서 읽었는데, C언어 또한 자바스크립트와 비슷한 점을 볼 수 있었다.이는 C를 기반으로 나온 언어이기때문일 것이다. 책을 읽으면서 조금 더 개발자와 가까워지는 느낌을 받았고, 책 제목처럼 혼자 공부하는 초보자를 위한 책이라는 느낌을 받았다.혼자 공부하는 시리즈(파이썬, 자바….등등)을 추천한다. 이 서평은 한빛비디어를 통해 제공받은 서적을 토대로 작성된 리뷰입니다.```","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"book-review","slug":"book-review","permalink":"https://tuhbm.github.io/tags/book-review/"},{"name":"북리뷰","slug":"북리뷰","permalink":"https://tuhbm.github.io/tags/%EB%B6%81%EB%A6%AC%EB%B7%B0/"},{"name":"프로그래머","slug":"프로그래머","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/"},{"name":"비전공자","slug":"비전공자","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90/"},{"name":"major","slug":"major","permalink":"https://tuhbm.github.io/tags/major/"},{"name":"C","slug":"C","permalink":"https://tuhbm.github.io/tags/C/"},{"name":"personal","slug":"personal","permalink":"https://tuhbm.github.io/tags/personal/"}]},{"title":"새로운 CSS 레이아웃","slug":"newLayout","date":"2019-07-28T22:51:20.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2019/07/28/newLayout/","link":"","permalink":"https://tuhbm.github.io/2019/07/28/newLayout/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 새로운 CSS 레이아웃 한줄평 리뷰구형 브라우저를 대응하느라 css3를 사용해보 못한 마크업 방법 중 레이아웃의 분야에 대해 친절히 설명한 책이다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 새로운 CSS 레이아웃 한줄평 리뷰구형 브라우저를 대응하느라 css3를 사용해보 못한 마크업 방법 중 레이아웃의 분야에 대해 친절히 설명한 책이다. 책정보판매처: Yes24저자 : 레이첼 엔드출간 : 20198-05-10페이지 : 172 쪽가격 : 정가 17,000원 -&gt; 판매가 15,300원(10% off) 상세정보 Yes24 소개빠르게 변해가는 웹 서비스 시장에 css3가 등장하며 많은 변화들이 이루어 지고있다. 하지만 레이아웃은 과거의 table로 시작해 float과 position으로 레이아웃을 구성하는 형태는 여전하다. 이제 원래 float과 position을 레이아웃을 위한 css 기법이 아니다. 그리하여 css3에서는 레이아웃을 구성하는 css가 등장하였다. 이책은 그러한 레이아웃에 대한 내용만 기재한 레이아웃을 위한 도서이다. 장점 친절히 예제코드와 실행 화면을 보여주고 이를 설명하며 독자들에게 보다 쉽게 변경된 레이아웃 구성스펙에 대해 설명해주고, 또한 구형브라우저에 대한 대책 등이 기재되어있다. 단점 번역도서이기 때문에 번역시 독자들의 예상 직업도 고려하여, 번역시 그에 해당하는 전문적인 번역이 이루어져야하지만, 이책은 그냥 영어를 한글로 번역만 한 듯한 느낌이 드는 문장들이 꽤 존재하여 책을 읽는도중에 흐름을 끊는다. 후기이책은 구형 브라우저를 대응하느라 많이 접해보지 못한 마크업 개발자들에게 귀감이 되는 책이다. 이책에서는 새로운 레이아웃에 대한 방법인 flex와 grid에 대해 설명하며, 기존 float, position으로 레이아웃을 작업하던 부분에 대한 설명과 그로인해 문제가 되는 것들에 대해 설명한다. 또한 구형 브라우저로 인해 많은 개발자들이 새로운 css방법을 사용하지 못한다는 점을 인지하고, 그에대해 후반에 대책에 대해서도 설명해주고있다. 이책을 읽고 구형 브라우저로 인해 css3에 대해 깊게 공부해야겠다는 생각을 미루어두고 있던 생각을 바뀌게하는 책이었다. 마크업을 하는 개발자라면 필독도서라고 생각한다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"layout","slug":"layout","permalink":"https://tuhbm.github.io/tags/layout/"},{"name":"flex","slug":"flex","permalink":"https://tuhbm.github.io/tags/flex/"},{"name":"float","slug":"float","permalink":"https://tuhbm.github.io/tags/float/"},{"name":"grid","slug":"grid","permalink":"https://tuhbm.github.io/tags/grid/"},{"name":"css3","slug":"css3","permalink":"https://tuhbm.github.io/tags/css3/"}]},{"title":"RxJS 시작하기","slug":"rxjs2","date":"2019-07-14T21:49:08.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2019/07/14/rxjs2/","link":"","permalink":"https://tuhbm.github.io/2019/07/14/rxjs2/","excerpt":"RxJSRxJS 시리즈 포스팅은 Quick Start RxJS를 읽으면서 공부하고 정리한 내용입니다. RxJS 시작하기지난 포스팅인 Rxjs를 시작하기전에편에서 최근 개발트랜드와 Rxjs를 사용해야 하는 원인에 대해 알아보았습니다.최근 개발패턴인 SPA(Single Page Application)는 데이터의 상태를 통해 웹페이지의 View와 데이터가 변경됩니다.그렇기에 RxJS를 통해 상태체크를 통해 데이터의 흐름을 관리하는 라이브러리인 RxJS를 사용해 개발한다고 말씀드렸습니다.실제로 RxJS 공식사이트에서도 &#39;Observable을 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.&#39;이다.간단히 &#39;이벤트용 lodash정도...&#39;라고 써있기도합니다.그러면 이제부터 RxJS를 사용해 개발하는 패턴을 알아보겠습니다.","text":"RxJSRxJS 시리즈 포스팅은 Quick Start RxJS를 읽으면서 공부하고 정리한 내용입니다. RxJS 시작하기지난 포스팅인 Rxjs를 시작하기전에편에서 최근 개발트랜드와 Rxjs를 사용해야 하는 원인에 대해 알아보았습니다.최근 개발패턴인 SPA(Single Page Application)는 데이터의 상태를 통해 웹페이지의 View와 데이터가 변경됩니다.그렇기에 RxJS를 통해 상태체크를 통해 데이터의 흐름을 관리하는 라이브러리인 RxJS를 사용해 개발한다고 말씀드렸습니다.실제로 RxJS 공식사이트에서도 &#39;Observable을 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기 위한 라이브러리이다.&#39;이다.간단히 &#39;이벤트용 lodash정도...&#39;라고 써있기도합니다.그러면 이제부터 RxJS를 사용해 개발하는 패턴을 알아보겠습니다. 설치최근 node를 통해 개발하는 방법인 npm을 통해 설치가 가능합니다. 1npm install rxjs 추가적으로 Typescript와 같이 사용하려면 아래와 같이 설치합니다. 1npm install @reactivex&#x2F;rxjs 시작하기Rxjs를 시작하기에 앞서 JavaScript 코드와 RxJS를 사용한 개발방법에 대해 간단한 코드를 통해 차이를 살펴보겠습니다.먼저 ‘Click’이벤트를 통해 console.log를 실행하는 코드를 살펴보겠습니다. 12345const eventHandler = event =&gt; &#123; console.log(event.currentTarget);&#125;document.addEventListener(&quot;click&quot;, eventHandler); 우리가 흔히 개발하는 JavaScript의 클릭 이벤트입니다.다음으로 RxJS입니다. 123456import &#123; fromEvent &#125; from &#x27;rxjs&#x27;;const click$ = fromEvent(document, &quot;click&quot;); // observableconst observer = event =&gt; &#123; console.log(event.currnetTarget);&#125;click$.subscribe(observer); 비슷한듯 하나 fromtEvent를 통해 이벤트 Observable로 생성하고,observer가 Observable 객체를 구독합니다. Observable는 어떠한 행위를 하는 객체 또는 데이터라고 이해 하시면됩니다.어떠한 동작을 하기 위해 데이터 또는 이벤트를 Observable로 생성하고, 이를 구독하여 어떠한 observer행위를 하여 개발을 진행하는 방식이 RxJS의 개발 패턴입니다. 그렇기에 RxJS개발 패턴중에 가장 먼저 해야하는 것이 Observable을 생성하는 것입니다. 다음 데이터를 다루는 예제를 살펴보겠습니다. 1234567891011121314151617181920212223242526272829const users = [&#123; name: &quot;유비&quot;, birthYear: 161, nationality: &quot;촉&quot;, &#125;, &#123; name: &quot;손권&quot;, birthYear: 182, nationality: &quot;오&quot; &#125;, &#123; name: &quot;관우&quot;, birthYear: 160, nationality: &quot;촉&quot;, &#125;, &#123; name: &quot;장비&quot;, birthYear: 168, nationality: &quot;촉&quot;, &#125;, &#123; name: &quot;조조&quot;, birthYear: 155, nationality: &quot;위&quot; &#125;, &#123; name: &quot;손권&quot;, birthYear: 182, nationality: &quot;오&quot; &#125;].filter(user =&gt; user.nationality === &#x27;촉&#x27;);const log = user =&gt; console.log(user);users.forEach(log); 위 방법은 데이터에서 원하는 값을 골라 새로운 배열을 만들고, 이를 console.log 이벤트를 발생시키는 코드입니다.다음은 RxJS코드입니다. 12345678910111213141516171819202122232425262728293031323334import &#123; from &#125; from &#x27;rxjs&#x27;;import &#123; filter &#125; from &#x27;rxjs.operators&#x27;;const users$ = from([&#123; name: &quot;유비&quot;, birthYear: 161, nationality: &quot;촉&quot;,&#125;, &#123; name: &quot;손권&quot;, birthYear: 182, nationality: &quot;오&quot;&#125;, &#123; name: &quot;관우&quot;, birthYear: 160, nationality: &quot;촉&quot;,&#125;, &#123; name: &quot;장비&quot;, birthYear: 168, nationality: &quot;촉&quot;,&#125;, &#123; name: &quot;조조&quot;, birthYear: 155, nationality: &quot;위&quot;&#125;, &#123; name: &quot;손권&quot;, birthYear: 182, nationality: &quot;오&quot;&#125;]).pipe( filter(user =&gt; user.nationality === &quot;촉&quot;))const observer = user =&gt; console.log(user);users$.subscribe(observer); 먼저 데이터를 from 메소드를 사용하여 Observable객체를 생성합니다.그후 observer가 ‘user$’를 구독하여 실행합니다.(Observable객체의 변수명은 뒤에 $를 붙이는 것을 권장합니다.) 패턴을 보면 obsever객체가 Observable객체를 구독하는 상태 전파를 하기 위해 리액티브 프로그래밍의 패러다임도 녹아있고, 로직오류를 방지하기 위한 함수형 프로그래밍의 패러다임 기법도 사용하고 있습니다. Rxjs의 중요한 개념들을 알아보겠습니다. Observable계속적으로 나오는 Observable은 시간을 축으로 연속적인 데이터를 저장한 객체입니다.또한 이러한 Observable객체를 observer에 전달 하여 처리하는 과정을 스트림이라고 합니다. 오퍼레이터위에서 예제 코드에서 사용하였던, ‘filter’를 오퍼레이터라고합니다. Observable 객체를 생성 또는 조작하는 함수를 오퍼레이터라고 합니다. 이러한 오퍼레이터를 통해 Observable객체를 생성하기도하고, 각각의 Observerbel객체를 서로 연결 또는 분리 합치기도 합니다. 오퍼레이터는 현재의 Observable의 인스턴스를 기반으로 항상 새로운 Observable인스턴스를 반환합니다. RxJS는 다양한 오퍼레이터들을 제공하고 있고, 상황에 맞는 오퍼레이터를 사용 해야합니다.RxJS 오퍼레이터 또한 과거에는 오퍼레이트 사용시 도트체이닝을 사용하여 개발하였으나, Rxjs 6.0부터 지원 도트체이닝을 제공하지 않고, pipe 오퍼레이터만 제공합니다.도트체이닝 사용 시 Observable 객체가 모든 오퍼레이터를 가지고 있어야 하는데, 이는 불필요한 오퍼레이터도 모두 가지고 있어야 하기에 파일 사이즈 증가pipe오퍼레이터 사용 시 webpack을 통해 트리쉐이킹(사용하지 않는 모듈을 번들링 할때 제거)하여 사용됩니다. 12345678910111213/// 도트체이닝 오퍼레이터 예제ajax$ .switchMap(data =&gt; ...) .filter(user =&gt; ...) .map(user =&gt; ...); /// pipe 오퍼레이터 예제ajax$ .pipe( switchMap(data =&gt; ...), filter(user =&gt; ...), map(user =&gt; ...) ); ObserverObservable에 전달된 데이터를 소비하는 주체이며, next, error, complete 함수를 가진 객체입니다. 1234567const observer = &#123; next : x =&gt; console.log(`Observer가 Observable로 받은 데이터: $&#123;x&#125;`), error: err =&gt; console.error(`Observer가 Observable로 받은 에러 데이터: $&#123;error&#125;`), complete: () =&gt; console.log(`Observer가 Observable로 부터 종료 되었다는 알림 메시지`)&#125;click$.subscribe(observer); SubscriptionObservable.prototype.subscribe의 반환값입니다.Subscription 객체는 자원의 해제를 담당하고 더이상 데이터를 전달받고 싶지 않은 경우 unsubscribe 메소드를 호출하여 자원을 해제야합니다.유한한 데이터의 경우 Observable의 자원을 해지할 필요가 없습니다.하지만 이벤트 핸들러 또는 interval를 통해 데이터를 계속 전달 받는 경우 자원해제가 필요합니다. 12345// ...const subscription = currentTarget$.subscribe(observer);// ...subscription.unsubscribe(); RxJS 개발방법이벤트를 Observable로 변환하고 filter 등의 오퍼레이터를 이용하여 데이터를 변경데이터를 처리할 Observer를 만들고 subscribe메소드를 통해 Observerable을 구독한다. 데이터를 Observable로 변경 오퍼레이터를 통해 변경 또는 추출 또는 여러 개의 Observable을 결합 또는 분리 원하는 데이터를 처리할 Observer를 생성 Observable의 subscribe를 통해 Observer를 등록 Observable의 구독을 정지하고 자원을 해제","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"RxJS","slug":"공부/Javascript/RxJS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"https://tuhbm.github.io/tags/RxJS/"},{"name":"스트림","slug":"스트림","permalink":"https://tuhbm.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Observable","slug":"Observable","permalink":"https://tuhbm.github.io/tags/Observable/"},{"name":"observer","slug":"observer","permalink":"https://tuhbm.github.io/tags/observer/"},{"name":"pipe","slug":"pipe","permalink":"https://tuhbm.github.io/tags/pipe/"},{"name":"도트체이닝","slug":"도트체이닝","permalink":"https://tuhbm.github.io/tags/%EB%8F%84%ED%8A%B8%EC%B2%B4%EC%9D%B4%EB%8B%9D/"},{"name":"오퍼레이터","slug":"오퍼레이터","permalink":"https://tuhbm.github.io/tags/%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"subscription","slug":"subscription","permalink":"https://tuhbm.github.io/tags/subscription/"},{"name":"구독","slug":"구독","permalink":"https://tuhbm.github.io/tags/%EA%B5%AC%EB%8F%85/"},{"name":"subscribe","slug":"subscribe","permalink":"https://tuhbm.github.io/tags/subscribe/"}]},{"title":"Rxjs를 시작하기전에...","slug":"rxjs1","date":"2019-06-28T21:49:08.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2019/06/28/rxjs1/","link":"","permalink":"https://tuhbm.github.io/2019/06/28/rxjs1/","excerpt":"RxJSRxJS 시리즈 포스팅은 Quick Start RxJS를 읽으면서 공부하고 정리한 내용입니다. Rxjs를 시작하기전에…개발 트랜드최근 많은 개발자들이 사용하고 있는 SPA(Single Page Application)를 웹 어플리케이션 개발은 상태에 따라 변화하는 상태머신으로 보아도 무방합니다. 과거 개발시 각 기능별로 모든 페이지가 존재했었습니다.","text":"RxJSRxJS 시리즈 포스팅은 Quick Start RxJS를 읽으면서 공부하고 정리한 내용입니다. Rxjs를 시작하기전에…개발 트랜드최근 많은 개발자들이 사용하고 있는 SPA(Single Page Application)를 웹 어플리케이션 개발은 상태에 따라 변화하는 상태머신으로 보아도 무방합니다. 과거 개발시 각 기능별로 모든 페이지가 존재했었습니다. 하지만 최근 SPA개발 방법은 하나의 index페이지를 가지고 있고, 나머지는 각 페이지에 맞는 컴포넌트를 JavaScript로 가지고 있습니다.예를 들어 과거에 게시판같은 경우 리스트의 기능의 페이지인 List.jsp파일을 시작으로 상세페이지인 View.jsp 그리고 쓰기페이지인 Write.jsp까지 각 기능별로 모든 페이지들이 각각 존재했습니다.그러므로 각 페이지에 Gnb라던가 Footer등의 중복된 부분을 모두 가지고 있는 내용이 중복되는 코드를 가지고 있었습니다. 중복된 내용을 코드까지 요청을 하며, 리소스의 낭비가 많이 발생하는 문제점을 컴포넌트의 형태로 필요한 부분만 갈아 끼우는 개발 방식을 통해 자원의 효율적으로 사용하도록 개발을 진행합니다.어떠한 input을 통해 변화된 상태를 감지하여, 컴포넌트를 갈아끼우는 형태의 개발 방식을 사용하고 있습니다. 이처럼 최근 웹 어플리케이션은 상태체크를 통해 컴포넌트의 변화 또는 데이터를 변화시키는 상태머신이라고 볼 수 있습니다.상태머신의 동작 순서는 아래와 같습니다. 12341. 시스템에서 input이 발생2. 프로그램 로직은 input과 현재 프로그램 상태에 따라 행위를 결정3. 프로그램 로직에 결정 따라 프로그램 상태를 변경4. 경우에 따라서 프로그램 로직에서는 output을 발생 위 순서를 레이어의 토글 기능에 적용한다면 아래와 같습니다. 12341. 사용자가 버튼을 클릭2. 웹어플리케이션은 현재 레이어의 상태를 체크3. 현제 레이어의 상태가 열림 이라면 레이어를 닫힘 상태로 변경, 닫힘 상태라면 열림으로 상태변경4. 레이어의 DOMD에 상태에 적용 따라서 크게보면 웹 어플리케이션도 하나의 큰 상태 머신으로 볼 수 있습니다. 오류의 발생원인사용자의 입력에 따라 프로그램이 예상하는 결과를 얻지 못하는 부분을 우리는 프로그램 오류라고 합니다.상태 머신인 웹어플리케이션은 정확한 입력과 로직으로 상태를 관리에 따라 오류의 발생여부가 결정됩니다.오류가 발생하는 원인을 크게 정리하면3가지로 볼 수 있습니다.. 입력오류 상태오류 로직오류 1. 입력오류각 구성요소에게 정확한 입력값을 전달하는 부분은 단순 전달하는 것이라 생각하면 쉬울 수도 있으나, 결코 쉽게 볼 수 없습니다.예를들어 서버로부터 전달받은 데이터를 입력값으로 사용하는 경우 응답값이 정상적인 값일 경우에만 입력값을 전달해야합니다. 또한 사용자로부터 입력을 받았을때 또한 옳바른 값을 전달받아야합니다.비정상적인 값을 데이터로 사용하여 전달한다면, 이는 오류가 발생하는 원인이 될 수 있습니다.그렇기에 외부로 부터 전달받는 경우에 값을 체크해 미리 오류에 대한 처리도 해야 합니다. 2. 상태오류상태 오류가 발생하는 원인은 상태변화를 정확하게 전달하지 못하는 경우 오류가 발생합니다.구성요소간 의존도가 있는경우 B가 A데이터를 기반으로 하는경우 A의 데이터가 변경될때 B의 상태 또는 데이터도 변경되어야합니다.또한 호출 순서가 A의 작업 이후 B 작업 이루어져야한다면 A와 B사이에 상태가 변경되는 어떠한 작업이 진행될때 오류가 발생할 수 있습니다.위의 상황처럼 의존도 또는 호출순서에 따른 상태변경시 오류가 발생 할 수 있습니다. 3. 로직오류개발자가 구현하고자하는 비지니스의 대한 이해도가 떨어지거나 실수로 인해 오류가 발생할 수 있습니다.로직에 관련해 오류가 생기는 문제는 개발자의 개인역량에 의해 발생하는 문제로 TDD(Test Driven Development)를 통해 이러한 문제를 방지 할 수 있습니다.또한 가장 빈번히 발생하는 로직오류는 분기문(if…else if…else, 삼항연산자, switch문) 또는 변수에 따른 오류가 가장 많이 발생합니다.분기가 많을수록 로직에 대한 복잡도가 올라가고, 변수가 많을 수록 의도치 않게 변경해야하는 부분도 많고 제 3자에 의해 변경될 수 있는 오류 발생률이 높아집니다. RxJS를 사용하는 원인과 관계RxJS는 ReactiveX의 자바스크립트 버전의 라이브러리입니다. RxJS는 앞서 살펴본 입력오류, 상태오류, 로직오류로 인해 발생하는 오류들을 효과적으로 처리하기 위한 최적의 라이브러리 입니다.궁극적으로 일관된 방식으로 안전하게 데이터의 흐름을 처리를 도와주는 라이브러리입니다.한마디로 정리하자면 범용데이터의 흐름을 제어하는 솔루션입니다.상태 전파를 하기 위해 리액티브 프로그래밍의 패러다임도 녹아있고, 로직오류를 방지하기 위한 함수형 프로그래밍의 패러다임 기법도 사용하고 있습니다. 지금까지 RxJS를 사용하기전 간단하게 RXJS를 도입하게 되는 배경에 대해 설명드렸습니다.다음 포스팅에서부터 RxJS의 오류방지 흐름등 RxJS의 대해 추가적으로 알아보도록 하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"RxJS","slug":"공부/Javascript/RxJS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"https://tuhbm.github.io/tags/RxJS/"},{"name":"스트림","slug":"스트림","permalink":"https://tuhbm.github.io/tags/%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"입력","slug":"입력","permalink":"https://tuhbm.github.io/tags/%EC%9E%85%EB%A0%A5/"},{"name":"로직","slug":"로직","permalink":"https://tuhbm.github.io/tags/%EB%A1%9C%EC%A7%81/"},{"name":"상태","slug":"상태","permalink":"https://tuhbm.github.io/tags/%EC%83%81%ED%83%9C/"},{"name":"Observable","slug":"Observable","permalink":"https://tuhbm.github.io/tags/Observable/"},{"name":"데이터","slug":"데이터","permalink":"https://tuhbm.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0/"}]},{"title":"게임으로 익히는 코딩 알고리즘","slug":"gameLearningAlgorithm","date":"2019-06-03T21:52:26.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2019/06/03/gameLearningAlgorithm/","link":"","permalink":"https://tuhbm.github.io/2019/06/03/gameLearningAlgorithm/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 게임으로 익히는 코딩 알고리즘 한줄평 리뷰알고리즘을 게임을 통해 보다 쉽고 즐기면서 배울 수 있었다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 게임으로 익히는 코딩 알고리즘 한줄평 리뷰알고리즘을 게임을 통해 보다 쉽고 즐기면서 배울 수 있었다. 책정보판매처: 한빛출판네트워크저자 : 김영기출간 : 2019-05-26페이지 : 320 페이지가격 : 정가 22,000원 -&gt; 판매가 19,800원(10% off) 상세정보 Yes24 한빛출판네트워크 소개프로그래밍을 직업으로 갖고 일하면서, 알고리즘은 개발자의 실력을 알아볼 수 있는 지표로 볼 수 있다. 그렇기에 최근 IT기업에서는 알고리즘 테스트등을 하는 회사들이 많다.하지만 나와같은 초보개발자 그리고 비전공자에게 알고리즘이라는 단어자체가 매우 어렵고 또한 알고리즘적 사고가 잘되지 않는다고 느껴진다.이책은 제목처럼 codingame.com이라는 서비스를 통해 게임을 하며 알고리즘을 자연스럽게 익히는데 도움을 준다. 장점게임을 통해 알고리즘을 자연스럽게 익힐 수 있고, 또한 해설을 통해 막힌 부분을 해소해준다. 단점게임에 대한 해설이 이미 존재하므로 답을 보고 해설을 미리 보게 된다. 후기요즘 알고리즘 책에서는 대부분 파이썬을 이용한 알고리즘을 익히는 부분이 단순 자바스크립트만을 사용하는 나와같은 프론트엔드개발자에게는 조금 이질적으로 느껴졌다.하지만 책을 읽으면서 이전에 잠시 익혔던 파이썬에 대한 기억이 살아났다. 또한 게임을 통해 자연스럽게 알고리즘을 익힌다는 것 자체가 흥미롭고 또한 재미있었다.그리고 직접 해보지는 않았지만 타인과 경쟁하는 부분도 있어 나보다 뛰어난 사람이 훨씬 많다는 점을 다시 깨달았다.재미있기 때문에 여러번 읽어 자연스럽게 알고리즘을 패턴처럼 습득 수 있는 충분한 요소가 존재 책이다. 이 서평은 한빛비디어를 통해 제공받은 서적을 토대로 작성된 리뷰입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://tuhbm.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"book-review","slug":"book-review","permalink":"https://tuhbm.github.io/tags/book-review/"},{"name":"python","slug":"python","permalink":"https://tuhbm.github.io/tags/python/"},{"name":"코딩게임","slug":"코딩게임","permalink":"https://tuhbm.github.io/tags/%EC%BD%94%EB%94%A9%EA%B2%8C%EC%9E%84/"},{"name":"codingame","slug":"codingame","permalink":"https://tuhbm.github.io/tags/codingame/"},{"name":"game","slug":"game","permalink":"https://tuhbm.github.io/tags/game/"},{"name":"learning","slug":"learning","permalink":"https://tuhbm.github.io/tags/learning/"},{"name":"수도코드","slug":"수도코드","permalink":"https://tuhbm.github.io/tags/%EC%88%98%EB%8F%84%EC%BD%94%EB%93%9C/"},{"name":"pseudocode","slug":"pseudocode","permalink":"https://tuhbm.github.io/tags/pseudocode/"}]},{"title":"아키텍처란 무엇인가?","slug":"architecture","date":"2019-04-24T23:20:50.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/04/24/architecture/","link":"","permalink":"https://tuhbm.github.io/2019/04/24/architecture/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 아키텍처(Architecture)개요업무를 진행하면서 듣는 많은 단어들이 있습니다. 그중에 어떤 프로젝트를 시작하기전에 항상 들리는 단어가 있습니다. 바로 아키텍처입니다. 보통 초보개발자가 아키텍처를 구성하는 일은 지극히 드문 케이스입니다. 하지만 저와 같은 ‘초보 개발자들도 도대체 아키텍처가 무엇이길래? 왜 우리한테는 이 업무가 주어지지 않는가?’ 에 대해 생각해 볼 수 있기에 정리를 해보려고 합니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 아키텍처(Architecture)개요업무를 진행하면서 듣는 많은 단어들이 있습니다. 그중에 어떤 프로젝트를 시작하기전에 항상 들리는 단어가 있습니다. 바로 아키텍처입니다. 보통 초보개발자가 아키텍처를 구성하는 일은 지극히 드문 케이스입니다. 하지만 저와 같은 ‘초보 개발자들도 도대체 아키텍처가 무엇이길래? 왜 우리한테는 이 업무가 주어지지 않는가?’ 에 대해 생각해 볼 수 있기에 정리를 해보려고 합니다. 본문먼저 기본적으로 용어에 대해 알아가기 전에 사전등을 살펴보면영어단어 - 아키텍쳐영어단어로써의 아키텍처는 ‘건축학’이라는 뜻입니다. 건축학은 프로그래밍에 많은 영향을 미친 학문입니다.때문에 건축용어를 많이 사용하고있습니다. 심지어 우리는 일정을 계획 할 때도 MM(Man month)라는 희한한 용어를 사용합니다. 다음으로 wiki문서를 살펴보겠습니다. - 시스템아키텍처우리같은 프로그래머는 시스템을 만드는 시스템 아키텍처라는 표현을 사용합니다.내용을 살펴보면, 시스템 목적을 달성하기위해 시스템의 상호작용등의 시스템디자인에 대한 제약 및 설계이다말이 좀 어렵지만, 아래와 같은 내용임을 위키문서를 통해 확인 할 수 있습니다. 시스템 구성 및 동작 원리 시스템 구성요소에 대한 설계 및 구현을 지원하는 수준을 기술 구성 요소 간의 관계 및 외부환경과의 관계 묘사 요구사양 및 시스템 수명주기 고려 시스템의 전체적인 최적화를 목표 한마디로 정리하면, 최적화를 목표로 두고 시스템 구성과 동작원리 그리고 시스템의 구성환경등을 설명 및 설계하는 청사진 또는 설계도 입니다.기본 Computer Science 지식을 기반으로 주변환경등을 고려하여, 최상의 소프트웨어를 구성하는 방법을 연구하고이를 바탕으로 가이드하는 역할을 합니다. 소프트웨어를 구성하는데 가장 기초적이고 핵심적인 부분의 업무이므로, 초보개발자들에게는 맡기지 않는 업무입니다.예를 들어 제대로된 아키텍처를 구성하지 못하고, 중구난방식으로 개발을 진행한다면 빠르고 쉽게 개발을 할 수 있을지 모르겠지만다양한 환경과 변수에 대응하지 못하는 큰 어려움이 있습니다. 쉽게 표현해 제대로된 설계를 하지 않고 주먹구구식으로 지은 건물은 태풍이나 지진과 같은 자연재해 또는 다른 외부 환경에 의해 쉽게 무너질 수 있습니다.그렇기에 견고한 설계과정을 통해 다양한 변수등에 대비해야합니다. 소프트웨어의 개발과정도 마찬가지입니다.정책의 변화, 기존 개발자의 공백과 같은 내부의 환경 변화 뿐만 아닌브라우저의 다양함, 유저의 행동, 사용중인 라이브러리의 버전업 또는 지원중단등 외부환경적인 요인들도 다양하게 고려해야합니다. 또한 최적화된 개발을 위해 프레임워크는 무엇을 사용 할 것이고,어떤 라이브러리를 사용할 것인지 등의 다양한 선택의 과정들도 필요합니다. 그렇기에 주니어가 아닌 다양한 경험과 기반지식을 갖춘 시니어급들에게 아키텍처를 설계하는 업무가 배정됩니다. 결론지금까지 아키텍처는 무엇인가? 아키텍처의 중요성등에 대해 알아보았습니다.현재 저와 같은 주니어 개발자들에게는 아직 기초지식을 더 쌓고 다양한 경험이 필요합니다.아키텍처를 정의하는 업무가 매우 해보고싶은 작업일 수 도 있습니다. 하지만 위에 말씀드린대로 매우 중요한 부분이기에 어설프게 아키텍처를 구성한다면, 어떤 변화에 모래성처럼 무너질 수 있습니다.또한 엄청난 책임감이 필요합니다. 내가 정의한 아키텍처를 통해 팀원들이 개발을 진행 할 것이고, 리더쉽 또한 필요합니다.인고의 과정을 통해 다양한 경험과 지식을 쌓는다면, 언젠가 내가 하기 싫어도 해야하는 시기가 옵니다.그때까지 참고 좀 더 완벽함을 노력합시다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://tuhbm.github.io/tags/architecture/"},{"name":"설계","slug":"설계","permalink":"https://tuhbm.github.io/tags/%EC%84%A4%EA%B3%84/"},{"name":"구조","slug":"구조","permalink":"https://tuhbm.github.io/tags/%EA%B5%AC%EC%A1%B0/"},{"name":"기본","slug":"기본","permalink":"https://tuhbm.github.io/tags/%EA%B8%B0%EB%B3%B8/"}]},{"title":"알고리즘이 욕망하는 것들","slug":"bookAlgorithms","date":"2019-04-17T21:51:20.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/04/17/bookAlgorithms/","link":"","permalink":"https://tuhbm.github.io/2019/04/17/bookAlgorithms/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 알고리즘이 욕망하는 것들(What Algorithms Want) 한줄평 리뷰알고리즘에 대한 공학적인 도서라고 생각하면 대단히 잘못된 생각이다. 매우 어려운 한글로 풀어져 있는 인문학도서이다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 알고리즘이 욕망하는 것들(What Algorithms Want) 한줄평 리뷰알고리즘에 대한 공학적인 도서라고 생각하면 대단히 잘못된 생각이다. 매우 어려운 한글로 풀어져 있는 인문학도서이다. 책정보판매처: 한빛출판네트워크저자 : 에드 핀출간 : 2019-03-26페이지 : 352 쪽가격 : 정가 18,000원 -&gt; 판매가 16,200원(10% off) 상세정보 Yes24 한빛출판네트워크 소개알고리즘이 우리 생활 모든 곳에 자리 잡은 지 오래다. 내 마음을 나보다 더 잘 아는 알고리즘, 하지만 우리는 알고리즘에 관해 얼마만큼 알고 있을까?이 책은 대중 예술과 IT 서비스 및 기업 등 익숙한 사례로 우리 사회에 널리 퍼져 있는 알고리즘의 의미를 탐구한다.알고리즘의 기원부터 알고리즘적 상상력, 알고리즘의 미학까지, 수학 논리로만 생각했던 알고리즘을 인문학적 관점에서 살필 수 있다. 장점 인문학을 접하기 어려운 개발자들이 그나마 흥미있는 알고리즘을 통해 인문학을 접해 볼 수 있다. 단점 인문학 도서답게 공학적인 표현보다는 매우 어려운 단어와 표현을 하므로 이해하기가 어렵다. 후기한줄평에 기입한대로 책제목만 보고 선택했다가 큰 낭패를 본 책이다. 그래도 읽다보면 책에서는 ‘추상적 사고, 해답에 대한 욕망의 추상적 표현’이라고 알고리즘을 말한다.또한 가까운 예를 들어 영화 ‘Her’를 시작으로 넷플릭스, 우버, 비트코인등 현재 인간의 생활에 깊숙히 침투되어있는 사례들을 통해 알고리즘이란 무엇이고, 그를 통해 어떻게 인간의 욕망들을 알고리즘을 통해 표현하고 있는지매우 어려운 인문학적으로 표현하고 있다.하지만 결론적으로 ‘인간의 욕망을 알고리즘을 통해 표현한다’라는 내용으로 이해했다.매우 어려운 표현들이 많아 다시 여러번에 걸쳐 독자의 표현의 의도를 다시 파악해도 될 것 같다. 이 서평은 한빛비디어를 통해 제공받은 서적을 토대로 작성된 리뷰입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://tuhbm.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"욕망","slug":"욕망","permalink":"https://tuhbm.github.io/tags/%EC%9A%95%EB%A7%9D/"},{"name":"넷플릭스","slug":"넷플릭스","permalink":"https://tuhbm.github.io/tags/%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4/"},{"name":"her","slug":"her","permalink":"https://tuhbm.github.io/tags/her/"},{"name":"우버","slug":"우버","permalink":"https://tuhbm.github.io/tags/%EC%9A%B0%EB%B2%84/"},{"name":"book-review","slug":"book-review","permalink":"https://tuhbm.github.io/tags/book-review/"},{"name":"비트코인","slug":"비트코인","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/"},{"name":"netflix","slug":"netflix","permalink":"https://tuhbm.github.io/tags/netflix/"}]},{"title":"개발자도구 - Audits편","slug":"devTools-audits","date":"2019-04-10T22:02:50.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2019/04/10/devTools-audits/","link":"","permalink":"https://tuhbm.github.io/2019/04/10/devTools-audits/","excerpt":"개요웹 개발자라면 이슈가 생겼을 때 보통 브라우저에서 개발자 도구를 열어 코드를 확인하며 어떠한 부분에서 이슈가 발생했는지 확인합니다. 제가 주로 사용하는 개발자도구는 크롬입니다. 개발자도구는 보통 브라우저에 포함된 기능입니다. 심지어 우리의 주적인 IE까지도 개발자도구가 존재합니다. 하지만 저도 개발자도구의 좋은 기능들을 활용하지 못했습니다. 최근 한 세미나에 참여하며, 개발자도구의 활용방법에 대해 배웠습니다. 생각보다 좋은 기능들이 많아 우리가 편리하게 개발을 하는데 도움을 받을 수 있습니다. 이러한 좋은 기능에 대해 기록해보겠습니다. Audits탭Audits탭은 해당 페이지의 전체적인 검사를 하는 기능이 있습니다. Desktop과 Mobile 중 어떤 플랫폼으로 실행을 할 것인지, 통신속도는 어떻게 할것인지 선택도 가능합니다.","text":"개요웹 개발자라면 이슈가 생겼을 때 보통 브라우저에서 개발자 도구를 열어 코드를 확인하며 어떠한 부분에서 이슈가 발생했는지 확인합니다. 제가 주로 사용하는 개발자도구는 크롬입니다. 개발자도구는 보통 브라우저에 포함된 기능입니다. 심지어 우리의 주적인 IE까지도 개발자도구가 존재합니다. 하지만 저도 개발자도구의 좋은 기능들을 활용하지 못했습니다. 최근 한 세미나에 참여하며, 개발자도구의 활용방법에 대해 배웠습니다. 생각보다 좋은 기능들이 많아 우리가 편리하게 개발을 하는데 도움을 받을 수 있습니다. 이러한 좋은 기능에 대해 기록해보겠습니다. Audits탭Audits탭은 해당 페이지의 전체적인 검사를 하는 기능이 있습니다. Desktop과 Mobile 중 어떤 플랫폼으로 실행을 할 것인지, 통신속도는 어떻게 할것인지 선택도 가능합니다. 또한 어떤 부분을 검사하고 싶은지 선택 가능한 항목은 아래와 같습니다. 성능 PWA Best practices 접근성 SEO(검색엔진최적화) 검사 진행시 아래와 같이 각 항목별 점수 및 개선 권고사항들에 대해 기술해줍니다. 또한 View Trace 버튼을 누르면 performance탭으로 이동합니다. Performance단락을 살펴보면 TTI(Time to Interactive) - 유저가 인터렉션(ex:클릭,마우스오버)을 사용할 수 있는 시간이 있는데, 이부분이 보통 유저가 체감가능한 렌더링시점으로 생각하시면 됩니다.보통의 서비스들은 TTI기준을 잡는지 모르지만, 지인을 통해 알아본 쿠팡의 경우 TTI기준을 2초를 기준으로 개발을 하고 있다고 합니다. RAIL 모델로 성능 측정 각 항목에 대한 권장사항을 리스트로 나타내줍니다.또한 권고사항들을 클릭하면 해당 항목에 대한 성능을 높일 수 있는 방법을 제공합니다. 결론Audits탭을 통해 SEO, PWA, 접근성등의 필수는 아니지만 더욱 유저들에게 필요한 부분에 대한 권장사항들에 대한 내용 그리고 Performance 점수등의 여러 점수들을 제공하고, 또한 이러한 부분들에 대한 수정을 권장하는 내용들을 제공하므로써 더욱 나은 웹서비스들을 만들 수 있도록 도와줍니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"ETC","slug":"공부/ETC","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/ETC/"}],"tags":[{"name":"성능최적화","slug":"성능최적화","permalink":"https://tuhbm.github.io/tags/%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"개발자도구","slug":"개발자도구","permalink":"https://tuhbm.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84%EA%B5%AC/"},{"name":"성능","slug":"성능","permalink":"https://tuhbm.github.io/tags/%EC%84%B1%EB%8A%A5/"},{"name":"PWA","slug":"PWA","permalink":"https://tuhbm.github.io/tags/PWA/"},{"name":"BestPractices","slug":"BestPractices","permalink":"https://tuhbm.github.io/tags/BestPractices/"},{"name":"접근성","slug":"접근성","permalink":"https://tuhbm.github.io/tags/%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"TTI","slug":"TTI","permalink":"https://tuhbm.github.io/tags/TTI/"},{"name":"TimeToInteractive","slug":"TimeToInteractive","permalink":"https://tuhbm.github.io/tags/TimeToInteractive/"},{"name":"검색엔진최적화","slug":"검색엔진최적화","permalink":"https://tuhbm.github.io/tags/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94/"}]},{"title":"개발자도구 - Performance편","slug":"devTools-performance","date":"2019-04-02T23:02:50.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2019/04/02/devTools-performance/","link":"","permalink":"https://tuhbm.github.io/2019/04/02/devTools-performance/","excerpt":"개요웹 개발자라면 이슈가 생겼을 때 보통 브라우저에서 개발자 도구를 열어 코드를 확인하며 어떠한 부분에서 이슈가 발생했는지 확인합니다. 제가 주로 사용하는 개발자도구는 크롬입니다. 개발자도구는 보통 브라우저에 포함된 기능입니다. 심지어 우리의 주적인 IE까지도 개발자도구가 존재합니다. 하지만 저도 개발자도구의 좋은 기능들을 활용하지 못했습니다. 최근 한 세미나에 참여하며, 개발자도구의 활용방법에 대해 배웠습니다. 생각보다 좋은 기능들이 많아 우리가 편리하게 개발을 하는데 도움을 받을 수 있습니다. 이러한 좋은 기능에 대해 기록해보겠습니다. Performance탭performance탭은 말 그대로 성능을 측정 할 수 있는 있는 도구입니다.맨위에 녹화 버튼을 눌러 녹화를 시작한 후 새로고침을 통해 페이지의 렌더링을 진행합니다.렌더링이 완료되면 STOP 버튼을 클릭합니다.그렇다면 아래와 같은 그래프 및 랜더링이 진행되는 화면들이 스냅샷으로 확인 가능합니다.","text":"개요웹 개발자라면 이슈가 생겼을 때 보통 브라우저에서 개발자 도구를 열어 코드를 확인하며 어떠한 부분에서 이슈가 발생했는지 확인합니다. 제가 주로 사용하는 개발자도구는 크롬입니다. 개발자도구는 보통 브라우저에 포함된 기능입니다. 심지어 우리의 주적인 IE까지도 개발자도구가 존재합니다. 하지만 저도 개발자도구의 좋은 기능들을 활용하지 못했습니다. 최근 한 세미나에 참여하며, 개발자도구의 활용방법에 대해 배웠습니다. 생각보다 좋은 기능들이 많아 우리가 편리하게 개발을 하는데 도움을 받을 수 있습니다. 이러한 좋은 기능에 대해 기록해보겠습니다. Performance탭performance탭은 말 그대로 성능을 측정 할 수 있는 있는 도구입니다.맨위에 녹화 버튼을 눌러 녹화를 시작한 후 새로고침을 통해 페이지의 렌더링을 진행합니다.렌더링이 완료되면 STOP 버튼을 클릭합니다.그렇다면 아래와 같은 그래프 및 랜더링이 진행되는 화면들이 스냅샷으로 확인 가능합니다. 처음 위와 같이 스냅샷에 이미 렌더링 되어있는 부분이 나온다해도 이상은 없습니다.단. 이걸 보고 싶지 않다면, 녹화버튼을 누르기 전에 Elements탭에서 body태그를 지우고 녹화버튼을 눌러 시작해보면 흰화면부터 시작되는 스냅샷을 확인 할 수 있습니다. 맨위 타임테이블에서는 구간을 선택해서 세부 내용확인이 가능합니다. 또한 창크기를 늘렸다 키웠다하며, 이동도 가능합니다p.s구간 해제는 더블클릭입니다. 상세 기능Frames- 스크린샷으로 화면의 흰 화면부터 렌더링 완료된 화면까지 모든과정을 나타내줍니다. Mainhtml부터 렌더링이 완료되기까지의 요청 및 렌더링의 파일 순서등을 보여줍니다.다른부분과 마찬가지로 마우스 휠을 통해 부분 확대 및 축소가 가능합니다. Timings- DCL, FCP, FMP, L등의 타이밍 순서를 알려줍니다. DCL : DOMContentLoaded 이벤트 FCP : First (Contentful) Paint FMP : First Meaningful Paint Candidate L : Load 이벤트 렌더링의 과정중에 우리가 javascript등으로 DOM 컨트롤을 시작할수있는 부분은 DCL부터 입니다. domContentLoadedEvent HTML과 CSS에 대한 파싱이 끝나는 시점 렌더트리를 구축할 준비가 된 (DOM과 CSSOM이 완료된) 상황 제이쿼리 기준 - $(document).ready(…) 시점 loadEvent HTML 상에 필요한 모든 리소스가 로드된 시점 제이쿼리 기준 - $(window).load(…)시점 performance탭에서 확인 할 수 있는 내용 파싱 순서 FMP시점 스냅샷을 통한 렌더링 순서 performance 탭 외의 진단도구Google PageSpeed Insights - https://developers.google.com/speed/pagespeed/insights/** webpagetest - https://webpagetest.org/ 결론performace탭을 통해 어떠한 파일이 먼저 렌더링되는지를 통해 개발시 진행하고 싶은 렌더링순서를 파악 할 수 있고, 더욱 효율적인 개발이 진행이 가능합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"ETC","slug":"공부/ETC","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/ETC/"}],"tags":[{"name":"성능최적화","slug":"성능최적화","permalink":"https://tuhbm.github.io/tags/%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"개발자도구","slug":"개발자도구","permalink":"https://tuhbm.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84%EA%B5%AC/"},{"name":"performance","slug":"performance","permalink":"https://tuhbm.github.io/tags/performance/"},{"name":"DCL","slug":"DCL","permalink":"https://tuhbm.github.io/tags/DCL/"},{"name":"FCP","slug":"FCP","permalink":"https://tuhbm.github.io/tags/FCP/"},{"name":"FMP","slug":"FMP","permalink":"https://tuhbm.github.io/tags/FMP/"},{"name":"Frames","slug":"Frames","permalink":"https://tuhbm.github.io/tags/Frames/"},{"name":"Timings","slug":"Timings","permalink":"https://tuhbm.github.io/tags/Timings/"},{"name":"domContentLoadedEvent","slug":"domContentLoadedEvent","permalink":"https://tuhbm.github.io/tags/domContentLoadedEvent/"},{"name":"loadEvent","slug":"loadEvent","permalink":"https://tuhbm.github.io/tags/loadEvent/"}]},{"title":"Axios를 사용하여 HTTP요청하기","slug":"axios","date":"2019-03-21T19:02:50.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/03/21/axios/","link":"","permalink":"https://tuhbm.github.io/2019/03/21/axios/","excerpt":"Axios소개Axios는 HTTP통신을 하는데 매우 인기있는 Javascript라이브러리입니다. Axios는 브라우저와 Node.js 플랫폼에서 모두 사용할 수 있습니다. 또한 IE8이상을 포함한 모든 최신 브라우저를 지원합니다. Axios는 Promise를 기반으로하여 async/await문법을 사용하여 XHR요청을 매우 쉽게 할 수 있습니다. Fetch API보다 Axios가 더 좋은 장점은 아래와 같습니다. 구형브라우저를 지원합니다.(Fetch API의 경우는 폴리필이 필요합니다.) 요청을 중단시킬 수 있습니다. 응답 시간 초과를 설정하는 방법이 있습니다. CSRF 보호 기능이 내장되어있다. JSON 데이터 자동변환 Node.js에서의 사용","text":"Axios소개Axios는 HTTP통신을 하는데 매우 인기있는 Javascript라이브러리입니다. Axios는 브라우저와 Node.js 플랫폼에서 모두 사용할 수 있습니다. 또한 IE8이상을 포함한 모든 최신 브라우저를 지원합니다. Axios는 Promise를 기반으로하여 async/await문법을 사용하여 XHR요청을 매우 쉽게 할 수 있습니다. Fetch API보다 Axios가 더 좋은 장점은 아래와 같습니다. 구형브라우저를 지원합니다.(Fetch API의 경우는 폴리필이 필요합니다.) 요청을 중단시킬 수 있습니다. 응답 시간 초과를 설정하는 방법이 있습니다. CSRF 보호 기능이 내장되어있다. JSON 데이터 자동변환 Node.js에서의 사용 설치npm에서 설치1npm install axios yarn에서 설치1yarn add axios 또는 단순하게 CDN을 로드해서 사용 할 수 있습니다. Axios APIaxios객체는 아래와 같이 간단하게 HTTP요청을 할 수 있습니다. 1234567axios(&#123; url: &#x27;https://test/api/cafe/list/today&#x27;, method: &#x27;get&#x27;, data: &#123; foo: &#x27;diary&#x27; &#125;&#125;); 그러나 보기 명확하게 method를 분리하여 사용할 수도 있습니다. axios.get() axios.post() $.ajax()를 분리해 명확하게 사용하는 $.get(), $.post()처럼 사용하는 jQuery와 매우 흡사합니다. Axios가 아직 핫한 라이브러리는 아니지만 HTTP요청에서 사용하는 다양한 method도 제공하고 있습니다. axios.delete() axios.put() axios.patch() axios.options() 그리고 HTTP헤더를 가져와 본문을 삭제하는 방법 또한 제공합니다. GET 요청Axios를 사용하는 편한 방법 중 하나는 moden javascript의 요소인 async/ await 구문을 사용하는 것 입니다. 이 Node.js예제는 Dog APi를 사용하여 모든 Dog의 breed 목록을 가져와 axios.get() 합니다. 12345678910111213141516171819const axios = require(&#x27;axios&#x27;);const getBreeds = async () =&gt; &#123; try &#123; return await axios.get(&#x27;https://dog.ceo/api/breeds/list/all&#x27;); &#125; catch (error) &#123; console.error(error); &#125;&#125;;const countBreeds = async () =&gt; &#123; const breeds = await getBreeds(); if (breeds.data.message) &#123; console.log(`현재 강아지의 수는 $&#123;Object.entries(breeds.data.message).length&#125;입니다.`); &#125;&#125;;countBreeds(); 만약 async / await 구문을 사용하지 않는다면 Promise 구문을 사용 할 수 있습니다. 1234567891011121314151617181920212223const axios = require(&#x27;axios&#x27;);const getBreeds = () =&gt; &#123; try &#123; return axios.get(&#x27;https://dog.ceo/api/breeds/list/all&#x27;); &#125; catch (error) &#123; console.error(error) &#125;&#125;;const countBreeds = () =&gt; &#123; const breeds = getBreeds() .then(response =&gt; &#123; if (response.data.message) &#123; console.log(`현재 강아지의 수는 $&#123;Object.entries(breeds.data.message).length&#125;입니다.`); &#125; &#125;) .catch(error =&gt; &#123; console.log(error); &#125;)&#125;;countBreeds(); GET 요청에 매개 변수 추가GET 응답에는 URL에 매개변수가 포함 될 수 있습니다. https://test.com/?foo=bar Axios를 사용하여 GET 요청시 간단하게 매개변수를 추가 할 수 있습니다. 1axios.get(&#x27;https://test.com/?foo=bar&#x27;); 또는 params옵션에서 추가하여 사용 할 수 있습니다. 12345axios.get(&#x27;https://test.com/&#x27;, &#123; params: &#123; foo: &#x27;bar&#x27; &#125;&#125;); POST 요청 axios.post처럼 POST 요청은 axios.getGET 요청과 같이 거의 같습니다. 1axios.post(&#x27;https://test.com&#x27;); POST 역시 매개변수를 추가하는방법은 GET과 같습니다. 12345axios.post(&#x27;https://test.com/&#x27;, &#123; params: &#123; foo: &#x27;bar&#x27; &#125;&#125;); 마무리axios를 통해 api 통신을 하는 것은 매우 간단하고, 러닝커브 또한 매우 낮습니다. 순수 자바스크립트를 사용하는 것으로도 매우 간단하게 api통신이 가능하지만 위에 말한 것처럼 axios의 장점을 생각하며, 도입을 권장합니다. Good Luck","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"http","slug":"http","permalink":"https://tuhbm.github.io/tags/http/"},{"name":"request","slug":"request","permalink":"https://tuhbm.github.io/tags/request/"},{"name":"get","slug":"get","permalink":"https://tuhbm.github.io/tags/get/"},{"name":"post","slug":"post","permalink":"https://tuhbm.github.io/tags/post/"}]},{"title":"SEO(Search Engine Optimization) 검색 엔진 최적화 3편","slug":"seo3","date":"2019-03-12T23:33:42.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2019/03/12/seo3/","link":"","permalink":"https://tuhbm.github.io/2019/03/12/seo3/","excerpt":"개요지난번 SEO 검색 엔진 최적화 2편에서는 noindex처리와 canonical처리로 색인차단또는 같은 페이지의 paramter값으로 인해 다른 url로 인식되는 문제를 하나의 대표페이지로 지정하여 검색 순위에 대한 문제를 해결해보았습니다. 본문이번 포스팅을 통해 우리의 서비스 페이지를 구글 또는 네이버의 검색 봇이 들어와 검사를 진행하고, 색인도 생성하여 필요한 url등을 가져가고,sitemap.xml등을 확인하여, 키워드에 대한 검색 랭킹을 등록합니다.이러한 봇이 어떻게 우리 페이지를 바라보게 되는지 테스트를 할 수 있는 크롬 extensions을 소개해 드리겠습니다. 사실 우리가 바라보는 웹페이지와 다르게 봇이 보는 우리의 웹사이트는 조금 차이가 있습니다. UI, UX의 디자인적 요소를 바라보는 사람과 달리 봇은 웹사이트의 내용을을 코드로 바라본다고 보시면 될것같습니다.그렇기에 css로 어떻게 표현했는지 이런 것은 바라보지 않습니다.","text":"개요지난번 SEO 검색 엔진 최적화 2편에서는 noindex처리와 canonical처리로 색인차단또는 같은 페이지의 paramter값으로 인해 다른 url로 인식되는 문제를 하나의 대표페이지로 지정하여 검색 순위에 대한 문제를 해결해보았습니다. 본문이번 포스팅을 통해 우리의 서비스 페이지를 구글 또는 네이버의 검색 봇이 들어와 검사를 진행하고, 색인도 생성하여 필요한 url등을 가져가고,sitemap.xml등을 확인하여, 키워드에 대한 검색 랭킹을 등록합니다.이러한 봇이 어떻게 우리 페이지를 바라보게 되는지 테스트를 할 수 있는 크롬 extensions을 소개해 드리겠습니다. 사실 우리가 바라보는 웹페이지와 다르게 봇이 보는 우리의 웹사이트는 조금 차이가 있습니다. UI, UX의 디자인적 요소를 바라보는 사람과 달리 봇은 웹사이트의 내용을을 코드로 바라본다고 보시면 될것같습니다.그렇기에 css로 어떻게 표현했는지 이런 것은 바라보지 않습니다. 예를 들어보면 우리의 google조차 봇이 보는 화면으로 보면 조금 옛날 디자인 같다는 느낌을 받습니다. 이처럼 디자인적 요소보다는 봇이 바라보는 환경은 코드를 통해 구조를 파악하고, 링크를 파악하고, 이페이지에 대한 정보를 확인한다고 이해하셔야 합니다. 다른 테스트 도구가 있을지 모르겠지만..(있다면 댓글로 추천 부탁드립니다.) 제가 사용하는 도구는 크롬 extensions(이제부터 확장프로그램이라고 표현하겠습니다.)인 *User-Agent Switcher for Chrome*입니다. 이 확장프로그램은 우리가 개발하면서 주로 사용하는 크롬의 확장프로그램으로써 크롬을 이용한 웹서핑 또는 개발중에 쉽게 켜고 끄면서 확인이 가능합니다. 우선 확장 프로그램에 추가 하세요. 그렇다면 크롬 주소창에 귀여운 아이콘이 보일겁니다.기본적으로 설정되어있는 브라우저가 보입니다.참고로 이프로그램은 프로그램의 이름처럼 User-Agent를 변경하는 단순한 프로그램입니다.User-Agent의 대한 설명(아직 MDN에 한국어 번역본은 없네요ㅠㅠ)위키의 내용을 확인해보면 아래와같습니다. 123소프트웨어 에이전트가 네트워크 프로토콜 안에서 동작할 때, 문자적 식별 문자열을 피어(peer)에 제출함으로써 종종 자기 자신과 애플리케이션 유형, 운영 체제, 소프트웨어 업체, 소프트웨어 리비전을 식별한다. HTTP,[2] SIP,[1], NNTP[3] 프로토콜에서 이러한 식별 정보는 User-Agent라는 헤더 필드를 통해 전달된다. 웹 크롤러와 같은 봇은 종종 URL이나 이메일 주소를 포함하기도 하며 이로 말미암아 웨마스터가 봇의 운영자와 연락을 취할 수 있다. 간단하게 표현하면, 브라우저별로 네트워크 통신을 할때 request Header에 보내는 고유한 값이라고 표현할 수 있습니다.우리가 서버에 요청을 할때 Header에 보내야하는 필수 항목 이라고 생각하시면 됩니다. 이러한 User-Agent는 우리가 지정 할 수도 있지만, 일반적으로 해당 브라우저에서 request할 때 자동으로 서버야 나는 크롬 브라우저고 몇버전이고 현재 OS는 이거야라고 자동으로 요청값에 들어갑니다.저는 UI개발을 할때 IE의 개발자도구를 켜서 해당 IE버전을 낮춰 확인하는 것도 User-Agent를 변경하여 요청하는 것이라 짐작됩니다. 이처럼 위의 확장프로그램은 User-Agent를 변경해주므로써 서버에 요청한 값으로 적합한 컨텐츠를 내려주도록 하는것입니다. 확장프로그램의 아이콘에 옵션 or 설정부분에 들어가게 되면, New User-agnet name - 설정할 User-Agent의 이름 New User-agnet String - 설정할 User-Agent의 값 Group - 추가될 그룹 Append? - 신경안써도 될 요소 Indicator Flag - 실행된 User-Agent의 깃발(User-Agent변경시 프로그램 아이콘에 표시될 내용) 이렇게 5가지 값을 입력하여 User-agent를 추가 할 수 있습니다. 저는 국내의 대표적인 포탈 사이트 naver와 글로벌 검색엔진인 google의 User-Agent를 추가해 사용하고 있습니다. 12Naver bot User-agnet String - Mozilla/5.0 (compatible; Yeti/1.1; +http://naver.me/spd)Google bot User-agnet String - Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html) 이처럼 두가지 User-Agent만 추가해도 검색 엔진이 보는 화면에 대한 구성이 이렇게 이루어 지고 있다.라는 화면을 충분히 인식할 수 있습니다. 결론지금까지 확장프로그램을 통해 검색엔진 bot이 보는 화면구성을 테스트 하는 방법을 알아보았습니다.bot이 보는 화면으로 인한 테스트도 중요하지만, SEO에 대한 업무를 하면서 가장 느낀건 기본입니다.기본적으로 지켜야하는 html 마크업에 이어 UI에 대한 설계가 가장 중요하다고 느꼈습니다. 기본적인 a태그의 올바른 href값 기재 및 img태그에 alt값등 기본에 충실한 마크업에 meta태그를 통한 정보제공 그리고 하위 호환성에대한 UI설계 등이 가장 기본적인 검색 엔진 최적화 방법입니다.기본을 지키지 않고, 추가적인 기능개발을 통해 개선하겠다.라는 방법은 물론 검색 엔진 최적화는 얻을 수 있겠지만,그에 따른 기능 추가로 인해 코드의 량 및 통신의 횟수 등을 증가시킵니다. 서비스를 하는 회사라면 검색 엔진 최적화도 잡아야 할 요소지만 기본적인 웹사이트의 성능 최적화도 잡아야 한다.라는 느낀점을 끝으로 마무리 하도록 하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"SEO","slug":"공부/SEO","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/SEO/"}],"tags":[{"name":"Search","slug":"Search","permalink":"https://tuhbm.github.io/tags/Search/"},{"name":"Engine","slug":"Engine","permalink":"https://tuhbm.github.io/tags/Engine/"},{"name":"Optimization","slug":"Optimization","permalink":"https://tuhbm.github.io/tags/Optimization/"},{"name":"facebook","slug":"facebook","permalink":"https://tuhbm.github.io/tags/facebook/"},{"name":"twitter","slug":"twitter","permalink":"https://tuhbm.github.io/tags/twitter/"},{"name":"share","slug":"share","permalink":"https://tuhbm.github.io/tags/share/"}]},{"title":"SEO(Search Engine Optimization) 검색 엔진 최적화 2편","slug":"seo2","date":"2019-03-04T23:12:59.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2019/03/04/seo2/","link":"","permalink":"https://tuhbm.github.io/2019/03/04/seo2/","excerpt":"개요지난번 SEO 검색 엔진 최적화 1편에 이어서 업무를 하면서 추가로 알게 된 내용들이 있어, 2편을 작성하게 되었습니다.서비스를 검색에 최대한 효율적이고 빈번히 노출시키는 것이 유저를 유입시키는 점에 있어 SEO(검색 엔진 최적화)작업은 매우 중요하다고 1편에서도 말씀드렸습니다.추가적인 내용을 정리해보겠습니다. noindex먼저 noindex에 간략히 말씀드리면, bot이 페이지를 크롤링할때 검색 색인 생성 차단하는 방법이라고 간략히 설명하겠습니다.접근을 차단하는 다른방법으로는 robots.txt파일을 웹마스터 도구에 등록하므로써 차단하는 방법도 있습니다.하지만 noindex의 경우는 색인은 bot이 색인을 생성하는 부분을 HTTP request에서 noindex header를 반환하여, 검색엔진에 표시가 되지 않게 하는 방법입니다.","text":"개요지난번 SEO 검색 엔진 최적화 1편에 이어서 업무를 하면서 추가로 알게 된 내용들이 있어, 2편을 작성하게 되었습니다.서비스를 검색에 최대한 효율적이고 빈번히 노출시키는 것이 유저를 유입시키는 점에 있어 SEO(검색 엔진 최적화)작업은 매우 중요하다고 1편에서도 말씀드렸습니다.추가적인 내용을 정리해보겠습니다. noindex먼저 noindex에 간략히 말씀드리면, bot이 페이지를 크롤링할때 검색 색인 생성 차단하는 방법이라고 간략히 설명하겠습니다.접근을 차단하는 다른방법으로는 robots.txt파일을 웹마스터 도구에 등록하므로써 차단하는 방법도 있습니다.하지만 noindex의 경우는 색인은 bot이 색인을 생성하는 부분을 HTTP request에서 noindex header를 반환하여, 검색엔진에 표시가 되지 않게 하는 방법입니다. 위에서 말한 단어중 색인이라는 키워드는 크롤러가 페이지방문 페이지의 콘텐츠와 html tag를 분석하여 페이지에 대한 정보를 저장 이순서로 이루어 지는데 2번째 과정에서 만들어지는 정보를 색인이라고 합니다. 이러한 색인의 생성을 차단하여, 연결된 페이지에 상관없이 검색페이지에서 노출을 막는 방법입니다. 사용방법noindex는 head태그에 태그에 추가하여 사용합니다. 1&lt;mata name=&quot;robots&quot; content=&quot;noindex&quot;&gt; 이렇게 메타태그를 적용한다면, 색인생성되는 부분을 막을 수 있습니다. 참고사항으로 noindex를 적용하는 페이지는 robots.txt에 등록되어 있지 않아야합니다. 저는 회사에서 테스트 서버등 각 환경에 있어서 동적으로 현재 도메인의 값을 받아LIVE 되고 있는 환경에만 noindex를 적용하지 않고 테스트 환경에 모두 noindex를 적용하여 사용했었습니다. canonical지난 1편에서도 canonical 관련해서 간략하게 설명했었습니다.이론적으로 알고 있을때와 실제 서비스에 적용하려다 보니 좀더 자세히 조사를 진행해보니, 조금 더 내용이 추가되었습니다.우선 canonial에 대해 조금 더 설명드리자면, 최근 많은 서비스에서 사용하고 있는 SPA(Single Page Application)의 경우 하나의 페이지에서 router값을 변경하므로써 해당 컨텐츠를 랜더링 하고 있습니다.그렇기에 어떻게 접속하느냐에 따라 URL에 붙는 parameter 값이 달라집니다.같은 컨텐츠임에도 불구하고 URL이 다르다는 것입니다. 예를 들어 12345http:&#x2F;&#x2F;www.exemple.com&#x2F;game&#x2F;kr&#x2F;main&#x2F;view&#x2F;2012431?listType&#x3D;2 - 리스트http:&#x2F;&#x2F;www.exemple.com&#x2F;game&#x2F;kr&#x2F;main&#x2F;view&#x2F;2012431?listType&#x3D;3&amp;display_opt&#x3D;usertag_on,html_remove - 카드http:&#x2F;&#x2F;www.exemple.com&#x2F;game&#x2F;kr&#x2F;search&#x2F;list&#x2F;TAG&#x2F;view&#x2F;2012431?listType&#x3D;2&amp;display_opt&#x3D;usertag_on,html_remove&amp;word&#x3D;%EA%B3%B5%EB%9E%B5&amp;searchBoardKey&#x3D;all&amp;direction&#x3D;accuracy - 검색 위의 3가지 URL은 모두 같은 컨텐츠입니다.접근 방법에 따라 뒤에 붙는 parameter값이 달라서 URL이 다를뿐입니다.이처럼 노출되어야 하는 컨텐츠는 하나인데, URL이 여러개라면 검색 봇은 각각의 페이지를 다 다른 페이지로 인식합니다.그렇기에 사용하는 방법이 canonical입니다. canonical을 사용하여, bot에 대표 페이지를 알려주므로써 크롤러가 수집할때 대표페이지 URL만 수집하여 검색 랭킹을 올리는 것입니다. 사용방법canonical역시 head태그에 적용하는데 위 noindex와 는 다르게 link태그를 사용합니다. 1&lt;link rel=&quot;canonical&quot; href=&quot;&#123;대표URL 설정&#125;&quot; /&gt; 이러한 방법으로 사용합니다. 위 url에 적용을 해본다면 1&lt;link rel=&quot;canonical&quot; href=&quot;http://www.exemple.com/game/kr/main/view/2012431&quot; /&gt; 이렇게 적용한다면, 대표 URL을 설정하므로써 컨텐츠의 검색랭킹을 올릴 수 있습니다. 추가적으로 요즘은 해당 접속환경을 랜더링하기 전에 받아 모바일버전과 PC버전을 자동으로 보여주고 있습니다. 이런경우 하나의 컨텐츠의 URL을 모바일과 PC 각각어떻게 연결할 수 있을까요?이런경우 pc에는 alternate를 사용하여 모바일 URL을 연결하고, mobile에는 canonical로 PC의 URL을 입력하여 연결합니다.코드로 설명을 드리면 12345// PC페이지&lt;link rel=&quot;alternate&quot; media=&quot;only screen and (max-width: 640px)&quot; href=&quot;&#123;PC URL&#125;&quot;&gt;// 모바일&lt;link rel=&quot;canonical&quot; href=&quot;&#123;모바일 URL&#125;&quot;&gt; 이렇게 각각 모바일과 PC의 URL을 서로 알려주어 같은 컨텐츠 임을 봇에게 알려주어 검색랭킹을 올릴 수 있습니다. 정리아직 SEO관련해서는 국내 자료가 충분하지 않아 번역기를 돌리면서, 해외자료를 검색하여 자료를 찾아보았습니다.추가적으로 SEO관련 업무를 진행하여 국내에 알려지지 않은 방법들을 포스팅해보도록 하겠습니다. 감사합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"SEO","slug":"공부/SEO","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/SEO/"}],"tags":[{"name":"canonical","slug":"canonical","permalink":"https://tuhbm.github.io/tags/canonical/"},{"name":"noindex","slug":"noindex","permalink":"https://tuhbm.github.io/tags/noindex/"},{"name":"Search","slug":"Search","permalink":"https://tuhbm.github.io/tags/Search/"},{"name":"Engine","slug":"Engine","permalink":"https://tuhbm.github.io/tags/Engine/"},{"name":"Optimization","slug":"Optimization","permalink":"https://tuhbm.github.io/tags/Optimization/"},{"name":"alternate","slug":"alternate","permalink":"https://tuhbm.github.io/tags/alternate/"}]},{"title":"Typescript - 접근 제한자","slug":"accessModifier","date":"2019-02-27T21:37:30.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2019/02/27/accessModifier/","link":"","permalink":"https://tuhbm.github.io/2019/02/27/accessModifier/","excerpt":"[Typescript] - 접근제한자 개요public, private, protected의 접근 제한자는 Typescript 공부를 진행하면서, Java에서 사용하던것은 알겠는데 정확히 무엇인지 인지하지 못해 정리를 하게되었습니다. 많이 보았지만 각각의 제한자는 어떤 범위까지 제한하는지 정리해보겠습니다. 우선 ES6에서부터 class를 통한 객체화가 가능해졌습니다. 그렇기에 상속도 가능해졌습니다. 하지만 Javascript의 상위 개념인 Typescript는 기존 Java와 같이 interface등을 통해 더욱 객체지향프로그래밍에 가까워 졌습니다. 또한 public, private, protected등 접근 제한자도 사용이 가능합니다. Publicpublic은 영어단어 뜻은 공공의, 대중의입니다. 단어처럼 접근 제한이 따로 없습니다. 상속도 가능하고, 외부 객체를 통한 접근도 가능합니다. 예제를 보겠습니다.","text":"[Typescript] - 접근제한자 개요public, private, protected의 접근 제한자는 Typescript 공부를 진행하면서, Java에서 사용하던것은 알겠는데 정확히 무엇인지 인지하지 못해 정리를 하게되었습니다. 많이 보았지만 각각의 제한자는 어떤 범위까지 제한하는지 정리해보겠습니다. 우선 ES6에서부터 class를 통한 객체화가 가능해졌습니다. 그렇기에 상속도 가능해졌습니다. 하지만 Javascript의 상위 개념인 Typescript는 기존 Java와 같이 interface등을 통해 더욱 객체지향프로그래밍에 가까워 졌습니다. 또한 public, private, protected등 접근 제한자도 사용이 가능합니다. Publicpublic은 영어단어 뜻은 공공의, 대중의입니다. 단어처럼 접근 제한이 따로 없습니다. 상속도 가능하고, 외부 객체를 통한 접근도 가능합니다. 예제를 보겠습니다. 1234567891011121314class Base &#123; public defaultAge = 30;&#125;class Member extends Base &#123; age = 1; public getAge() &#123; return this.age + this.defaultAge; &#125;&#125;let member = new Member();console.log(member.getAge()); // 31 위 코드를 보면 부모클래스(Base)에서 자식클래스(Member)로 상속이 가능하고, 또한 멤버변수인 member에서 실행 했을때도 접근이 가능하여 31이 출력됩니다. 이처럼 public은 상속, 외부객체를 통한 접근 모두 가능합니다. protectedprotected도 영어뜻은 보호받은입니다. 단어대로 보면 무언가 보호를 받는것 같습니다. protected는 public처럼 상속은 가능합니다. 하지만 외부객체에서의 접근이 허용되지 않습니다. 예제를 살펴보겠습니다. 123456789101112class Base &#123; protected birthYear = &#x27;1989&#x27;;&#125;class Member extends Base &#123; protected getBirthYear() &#123; return this.birthYear &#125;&#125;let member = new Member();member.getBirthYear(); // Property &#x27;getBirthYear&#x27; is protected and only accessible within class &#x27;Member&#x27; and its subclasses. 위 코드를 보면 부모클래스(Base)에서 자식클래스(Member)로 상속이 가능하지만, 멤버변수인 member에서는 사용 할 수 없음을 알 수 있습니다. 이처럼 protected은 상속은 가능하지만, 외부객체를 통한 접근은 불가능합니다. privateprivate의 영어뜻은 사유의를 뜻을 가지고 있습니다. 사유재산같은 뭔가 공도으로 사용이 어려워보입니다. private은 상속도 불가능하고, 외부 객체에서의 접근도 불가능합니다. 예제를 살펴보겠습니다. 12345678910111213141516171819class Base &#123; private birthYear = &#x27;1989&#x27;;&#125;class Member extends Base &#123; private age = 0; private getBirthYear() &#123; return this.birthYear; // Property &#x27;birthYear&#x27; is private and only accessible within class &#x27;Base&#x27;. &#125; private getAge() &#123; return this.age; &#125;&#125;let member = new Member();member.age(); // Property &#x27;age&#x27; is private and only accessible within class &#x27;Member&#x27;.member.getAge(); // Property &#x27;getAge&#x27; is private and only accessible within class &#x27;Member&#x27;. 위 코드를 보면 부모클래스(Base)에서 자식클래스(Member)로 상속도 불가능하고, 멤버변수인 member에서는 사용 할 수 없음을 알 수 있습니다. private는 상속도 불가능하고, 외부 멤버변수로의 접근도 불가능합니다. 정리정리를 해보면 다음 표처럼 정리가 가능합니다. 접근제한자 특징 상속여부 외부 객체에서의 접근 public public으로 설정된 멤버(멤버변수, 멤버메서드)는 상속 및 접근 가능 가능 가능 protected protected 설정된 멤버는 자식클래스에서 접근 가능 가능 불가능 private private으로 설정된 멤버는 현재클래스에서만 접근 가능 불가능 불가능 이처럼 접근 제한자의 특징을 알아두고, 올바르게 사용하여 개발을 진행하시길 바랍니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Typescript","slug":"공부/Javascript/Typescript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Typescript/"}],"tags":[{"name":"access","slug":"access","permalink":"https://tuhbm.github.io/tags/access/"},{"name":"public","slug":"public","permalink":"https://tuhbm.github.io/tags/public/"},{"name":"private","slug":"private","permalink":"https://tuhbm.github.io/tags/private/"},{"name":"protected","slug":"protected","permalink":"https://tuhbm.github.io/tags/protected/"}]},{"title":"번역 - 자바스크립트 코드 30초 시리즈<Utiltity> 1편","slug":"javascript30secUtiltity","date":"2019-02-22T01:38:48.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2019/02/22/javascript30secUtiltity/","link":"","permalink":"https://tuhbm.github.io/2019/02/22/javascript30secUtiltity/","excerpt":"[Utiltity]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Utiltity편 castArray인자로 받은 값을 배열로 변경합니다.Array.prototype.isArray()를 사용하여 인자로 받은 val을 값을 배열에 넣어 리턴합니다. 1234const castArray = val =&gt; (Array.isArray(val) ? val : [val]);// EXAMPLEScastArray(&#x27;foo&#x27;); // [&#x27;foo&#x27;]castArray([1,2,3,4]); // [1,2,3,4]","text":"[Utiltity]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Utiltity편 castArray인자로 받은 값을 배열로 변경합니다.Array.prototype.isArray()를 사용하여 인자로 받은 val을 값을 배열에 넣어 리턴합니다. 1234const castArray = val =&gt; (Array.isArray(val) ? val : [val]);// EXAMPLEScastArray(&#x27;foo&#x27;); // [&#x27;foo&#x27;]castArray([1,2,3,4]); // [1,2,3,4] cloneRegExp정규식을 복제합니다.new RegExp()를 사용하고 RegExp.source와 RegExp.flags지정된 정규 표현을 복제 할 수 있습니다. 1234const cloneRegExp = regExp =&gt; new RegExp(regExp.source, regExp.flags);// EXAMPLESconst regExp = /lorem ipsum/gi;const regExp2 = cloneRegExp(regExp); // /lorem ipsum/gi coalesceArray.prototype.find()를 사용하여 전달받은 인자값 중에서 null이나 undefined가 아닌 첫번째 값을 리턴합니다. 123const coalesce = (...args) =&gt; args.find(_ =&gt; ![undefined, null].includes(_));// EXAMPLEScoalesce(null, undefined, &#x27;Waldo&#x27;, &#x27;&#x27;, NaN ); // &quot;Waldo&quot; coalesceFactory전달받은 인자를 순회하여 args로 제공한 값(배열)과 일치하는 값을 리턴합니다.Array.prototype.find()을 사용하여 인자값 중 true와 일치하는 첫번째 값을 리턴합니다.아래 예제는 !(부정연산자)를 사용하여, false인 값을 찾습니다. 1234const coalesceFactory = valid =&gt; (...args) =&gt; args.find(valid);// EXAMPLESconst customCoalesce = coalesceFactory(_ =&gt; ![null, undefined, &#x27;&#x27;, NaN].includes(_));customCoalesce(undefined, null, NaN, &#x27;&#x27;, &#x27;Waldo&#x27;); // &quot;Waldo&quot; extendHex3 자리 컬러 코드를 6 자리 컬러 코드로 확장합니다.Array.prototype.map(), String.prototype.split(), Array.prototype.join()을 사용하여 3자리 RGB 컬러 코드는 6자리로 변환합니다.Array.prototype.slice()은 메소드가 시작할때 #을 제거합니다. 1234567891011const extendHex = shortHex =&gt; &#123; return &#x27;#&#x27; + shortHex .slice(shortHex.startsWith(&#x27;#&#x27;) ? 1 : 0) .split(&#x27;&#x27;) .map(x =&gt; x + x) .join(&#x27;&#x27;);&#125;// EXAMPLESextendHex(&#x27;#03f&#x27;); // &#x27;#0033ff&#x27;extendHex(&#x27;05a&#x27;); // &#x27;#0055aa&#x27; getURLParameters현재 URL의 파라미터값을 객체로 반환합니다.String.match()에서 정규표현식을 사용하여 모든 키- 값 쌍을 가져와서 Array.prototype.reduce()로 매핑하고 결합합니다. 123456789const getURLParameters = url =&gt; &#123; return (url.match(/([^?=&amp;]+)(=([^&amp;]*))/g) || []).reduce( (a, v) =&gt; ((a[v.slice(0, v.indexOf(&#x27;=&#x27;))] = v.slice(v.indexOf(&#x27;=&#x27;) + 1)), a), &#123;&#125; );&#125;// EXAMPLESgetURLParameters(&#x27;http://url.com/page?name=Adam&amp;surname=Smith&#x27;); // &#123;name: &#x27;Adam&#x27;, surname: &#x27;Smith&#x27;&#125;getURLParameters(&#x27;google.com&#x27;); // &#123;&#125; hexToRGB인자로 받은 hex 표현된 컬러값을 RGB의 컬러값으로 변환해줍니다. 1234567891011121314151617181920212223const hexToRGB = hex =&gt; &#123; let alpha = false, h = hex.slice(hex.startsWith(&#x27;#&#x27;) ? 1 : 0); if (h.length === 3) h = [...h].map(x =&gt; x + x).join(&#x27;&#x27;); else if (h.length === 8) alpha = true; h = parseInt(h, 16); return ( &#x27;rgb&#x27; + (alpha ? &#x27;a&#x27; : &#x27;&#x27;) + &#x27;(&#x27; + (h &gt;&gt;&gt; (alpha ? 24 : 16)) + &#x27;, &#x27; + ((h &amp; (alpha ? 0x00ff0000 : 0x00ff00)) &gt;&gt;&gt; (alpha ? 16 : 8)) + &#x27;, &#x27; + ((h &amp; (alpha ? 0x0000ff00 : 0x0000ff)) &gt;&gt;&gt; (alpha ? 8 : 0)) + (alpha ? `, $&#123;h &amp; 0x000000ff&#125;` : &#x27;&#x27;) + &#x27;)&#x27; );&#125;;// EXAMPLEShexToRGB(&#x27;#27ae60ff&#x27;); // &#x27;rgba(39, 174, 96, 255)&#x27;hexToRGB(&#x27;27ae60&#x27;); // &#x27;rgb(39, 174, 96)&#x27;hexToRGB(&#x27;#fff&#x27;); // &#x27;rgb(255, 255, 255)&#x27; httpGetXMLHttpRequest웹 API를 사용하여 GET으로 전달될 URL에 대한 요청합니다.onload이벤트를 호출하여 callback으로 responseText값을 제공합니다. 선언된 err함수를 사용하여 onerror처리를 합니다. 세번째로 오류를 error 의 디폴트값으로 기록합니다. 1234567891011121314151617181920const httpGet = (url, callback, err = console.error) =&gt; &#123; const request = new XMLHttpRequest(); request.open(&#x27;GET&#x27;, url, true); request.onload = () =&gt; callback(request.responseText); request.onerror = () =&gt; err(request); request.send();&#125;;// EXAMPLEShttpGet( &#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;, console.log); /*Logs: &#123; &quot;userId&quot;: 1, &quot;id&quot;: 1, &quot;title&quot;: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;, &quot;body&quot;: &quot;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&quot;&#125;*/ httpPostXMLHttpRequest웹 API를 사용하여 POST으로 전달 될 URL에 대한 요청합니다.HTTP요청 header값을 setRequestHeader메소드를 통해 셋팅합니다. onload이벤트를 호출하여 callback으로 responseText값을 제공합니다. 선언된 err함수를 사용하여 onerror처리를 합니다. 제공된 URL로 데이터를 전송하지 않으려면, 세 번째 인수인 data를 생략합니다. 오류를 error 의 디폴트값으로 기록합니다. 12345678910111213141516171819202122232425262728293031323334353637const httpPost = (url, data, callback, err = console.error) =&gt; &#123; const request = new XMLHttpRequest(); request.open(&#x27;POST&#x27;, url, true); request.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/json; charset=utf-8&#x27;); request.onload = () =&gt; callback(request.responseText); request.onerror = () =&gt; err(request); request.send(data);&#125;;EXAMPLESconst newPost = &#123; userId: 1, id: 1337, title: &#x27;Foo&#x27;, body: &#x27;bar bar bar&#x27;&#125;;const data = JSON.stringify(newPost);httpPost( &#x27;https://jsonplaceholder.typicode.com/posts&#x27;, data, console.log); /*Logs: &#123; &quot;userId&quot;: 1, &quot;id&quot;: 1337, &quot;title&quot;: &quot;Foo&quot;, &quot;body&quot;: &quot;bar bar bar&quot;&#125;*/httpPost( &#x27;https://jsonplaceholder.typicode.com/posts&#x27;, null, // does not send a body console.log); /*Logs: &#123; &quot;id&quot;: 101&#125;*/ randomHexColorCode임의의 16 진수 색상 코드를 생성합니다.Math.random로 무작위 24 비트(6x4bits)의 16 진수를 생성하는 데 사용 합니다. toString(16)사용하여 16 진수 문자열로 변환하십시오. 123456const randomHexColorCode = () =&gt; &#123; let n = (Math.random() * 0xfffff * 1000000).toString(16); return &#x27;#&#x27; + n.slice(0, 6);&#125;;// EXAMPLESrandomHexColorCode(); // &quot;#e34155&quot; RGBToHexRGB 구성 요소의 값을 색상 코드로 변환합니다.주어진 RGB 매개 변수를 비트 시프트 연산자 (&lt;&lt;)를 사용하여 16 진수 문자열을 toString(16)변환한 다음 String.padStart(6,&#39;0&#39;)으로 6 자리 16 진수 값을 가져옵니다. 123const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#x27;0&#x27;);// EXAMPLESRGBToHex(255, 165, 1); // &#x27;ffa501&#x27; toDecimalMarktoLocaleString()부동 소수점 산술을 소수점 표시 형식 으로 변환하는 데 사용 합니다 . 문자열에 쉼표로 구분 된 숫자를 만듭니다. 123const toDecimalMark = num =&gt; num.toLocaleString(&#x27;en-US&#x27;);// EXAMPLEStoDecimalMark(12305030388.9087); // &quot;12,305,030,388.909&quot; validateNumber인자값이 정수인지 확인하여, true또는 false를 리턴합니다.!isNaN메서드에 parseFloat한 인자값을 넣어 NaN이 아닌 정수값을 확인하고, isFinite 메서드를 실행하여 유한한 숫자인지 확인하고, `Number메서드를 통해 강제로 지정한 숫자인지를 확인합니다. 123const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// EXAMPLESvalidateNumber(&#x27;10&#x27;); // true 지금까지 코드 30초 시리즈 Utility편 이었습니다. 업무 또는 공부를 진행하면서 util함수처럼 공통으로 사용 할 만한 함수들을 통하여 더욱 좋은 개발을 진행해 보세요. 이상입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"transform","slug":"transform","permalink":"https://tuhbm.github.io/tags/transform/"},{"name":"30sec","slug":"30sec","permalink":"https://tuhbm.github.io/tags/30sec/"},{"name":"js","slug":"js","permalink":"https://tuhbm.github.io/tags/js/"},{"name":"Utiltity","slug":"Utiltity","permalink":"https://tuhbm.github.io/tags/Utiltity/"}]},{"title":"번역 - 자바스크립트 코드 30초 시리즈<Date> 1편","slug":"javascript30secDate","date":"2019-02-17T01:38:48.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2019/02/17/javascript30secDate/","link":"","permalink":"https://tuhbm.github.io/2019/02/17/javascript30secDate/","excerpt":"[Date]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Date편 ###dayOfYearDate객체에서 새해로부터 몇번째 날인지 가져옵니다.new Date()를 하고 Date.prototype.getFullYear()를 사용하여, 해당 연도의 첫날의 Date객체에서 인자로 받은 date를 뺀 값을 milliseconds로 나누워 결과를 얻습니다.Math.floor()으로 결과를 정수로 적절하게 반올림하여 사용하세요. 12345const dayOfYear = date =&gt; &#123; return Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24); &#125;// EXAMPLESdayOfYear(new Date()); // 272","text":"[Date]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Date편 ###dayOfYearDate객체에서 새해로부터 몇번째 날인지 가져옵니다.new Date()를 하고 Date.prototype.getFullYear()를 사용하여, 해당 연도의 첫날의 Date객체에서 인자로 받은 date를 뺀 값을 milliseconds로 나누워 결과를 얻습니다.Math.floor()으로 결과를 정수로 적절하게 반올림하여 사용하세요. 12345const dayOfYear = date =&gt; &#123; return Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24); &#125;// EXAMPLESdayOfYear(new Date()); // 272 formatDuration주어진 milliseconds 숫자를 사람이 읽을 수 있는 형식을 반환합니다. 인수로 받은 ms을 값으로 나누어 day, hour, minute, second, millisecond에 해당하는 각각의 값을 구합니다. Object.entries()와 Array.prototype.filter()를 함께 사용하여 0이 아닌 값을 유지합니다. Array.prototype.map()를 사용하여 각 값에 대한 적절한 문자열이 들어갈 수 있도록 합니다. String.prototype.join()을 사용하여 값을 합치도록 합니다. 1234567891011121314151617const formatDuration = ms =&gt; &#123; if (ms &lt; 0) ms = -ms; const time = &#123; day: Math.floor(ms / 86400000), hour: Math.floor(ms / 3600000) % 24, minute: Math.floor(ms / 60000) % 60, second: Math.floor(ms / 1000) % 60, millisecond: Math.floor(ms) % 1000 &#125;; return Object.entries(time) .filter(val =&gt; val[1] !== 0) .map(([key, val]) =&gt; `$&#123;val&#125; $&#123;key&#125;$&#123;val !== 1 ? &#x27;s&#x27; : &#x27;&#x27;&#125;`) .join(&#x27;, &#x27;);&#125;;// EXAMPLESformatDuration(1001); // &#x27;1 second, 1 millisecond&#x27;formatDuration(34325055574); // &#x27;397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds&#x27; getColonTimeFromDateDate 객체에서 HH:MM:SS 형식의 문자열을 반환합니다. Date.prototype.toTimeString() 및 String.prototype.sliice()를 사용하여 인자로 받은 날짜의 HH:MM:SS 부분을 구합니다. 123const getColonTimeFromDate = date =&gt; date.toTimeString().slice(0, 8);// EXAMPLESgetColonTimeFromDate(new Date()); // &quot;23:31:58&quot; getDaysDiffBetweenDates두개의 날짜를 인자로 받아 첫번째로 받은 값과 두번째로 받은 값의 차이(일 단위)를 반환합니다. 12345const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; &#123; return (dateFinal - dateInitial) / (1000 * 3600 * 24); &#125;// EXAMPLESgetDaysDiffBetweenDates(new Date(&#x27;2019-02-12&#x27;), new Date(&#x27;2019-02-21&#x27;)); // 9 getMeridiemSuffixOfInteger숫자 정수를 받아 오전과 오후를 구분한 시간으로 반환됩니다. %나누기 연산자로 조건부 검사를 사용하여 정수를 오전과 오후로 구분한 값이 있는 12시간 형태의 값으로 변환합니다. 123456789101112const getMeridiemSuffixOfInteger = num =&gt; &#123; if(num &gt; 24) &#123; throw new Error(&#x27;num 값이 너무 큽니다.&#x27;); &#125; return num === 0 || num === 24 ? 12 + &#x27;am&#x27; : num === 12 ? 12 + &#x27;pm&#x27; : num &lt; 12 ? (num % 12) + &#x27;am&#x27; : (num % 12) + &#x27;pm&#x27;;&#125; isAfterDate두 날짜를 받아 연산자(&gt;)를 사용하여 앞에 받은 날짜A가 두번째 날짜B 보다 뒤의 날짜인지 확인합니다. 123const isAfterDate = (dateA, dateB) =&gt; dateA &gt; dateB;// EXAMPLESisAfterDate(new Date(2019, 02, 21), new Date(2019, 02, 20)); // true isBeforeDate두 날짜를 받아 연산자(&lt;)를 사용하여 앞에 받은 날짜A가 두번째 날짜B 보다 앞의 날짜인지 확인합니다. 123const isBeforeDate = (dateA, dateB) =&gt; dateA &lt; dateB;// EXAMPLESisBeforeDate(new Date(2019, 02, 20), new Date(2019, 02, 21)); // true isSameDateDate.prototype.toISOString()를 사용하여 첫 번째 날짜A와 두 번째 날짜B가 동일한 지 확인합니다. 엄격한 검사 ( ===)를 사용합니다. 123const isSameDate = (dateA, dateB) =&gt; dateA.toISOString() === dateB.toISOString();// EXAMPLESisSameDate(new Date(2019, 02, 17), new Date(2019, 02, 17)); // true maxDate여러 개의 날짜를 인자로 받아 그 중 가장 최대 날짜(늦은날짜)를 리턴해줍니다. Math.max.apply()를 사용하여 최대 날짜 값을 찾고, new Date()를 사용하여Date객체로 변환하여 리턴합니다. 123456789const maxDate = (...dates) =&gt; new Date(Math.max.apply(null, ...dates));// EXAMPLESconst array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2019, 1, 17)];maxDate(array); // Sun Feb 17 2019 00:00:00 GMT+0900 (한국 표준시) minDate여러 개의 날짜를 인자로 받아 그 중 가장 최소 값(빠른날짜)를 리턴해줍니다. Math.min.apply()를 사용하여 최소 날짜 값을 찾고, new Date()를 사용하여Date객체로 변환하여 리턴합니다. 123456789const minDate = (...dates) =&gt; new Date(Math.min.apply(null, ...dates));// EXAMPLESconst array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9)];minDate(array); // Sat Jan 09 2016 00:00:00 GMT+0900 (한국 표준시) tomorrow1234567const tomorrow = () =&gt; &#123; let t = new Date(); t.setDate(t.getDate() + 1); return t.toString();&#125;;EXAMPLEStomorrow(); // Mon Feb 18 2019 01:34:01 GMT+0900 (한국 표준시) 지금까지 코드 30초 시리즈 Date편 이었습니다. 앞서 서론에서 말한 것과 같이 업무를 진행하면서 util함수처럼 공통으로 사용 할 만한 함수들을 소개하였습니다. 또는 조금 쉽게 가져가서 사용할 수 있는 메소드들을 앞으로도 소개드리겠습니다. 이상입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"transform","slug":"transform","permalink":"https://tuhbm.github.io/tags/transform/"},{"name":"30sec","slug":"30sec","permalink":"https://tuhbm.github.io/tags/30sec/"},{"name":"js","slug":"js","permalink":"https://tuhbm.github.io/tags/js/"},{"name":"date","slug":"date","permalink":"https://tuhbm.github.io/tags/date/"}]},{"title":"번역 - 자바스크립트 코드 30초 시리즈<Array> 1편","slug":"javascript30secArray1","date":"2019-02-10T01:38:48.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2019/02/10/javascript30secArray1/","link":"","permalink":"https://tuhbm.github.io/2019/02/10/javascript30secArray1/","excerpt":"[Array 1편]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Array편 all제공된 조건부 함수가 컬렉션의 모든 요소에 대해 true를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.Array.prototype.every()를 사용하여 컬렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다. 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오. 1234const all = (arr, fn = Boolean) =&gt; arr.every(fn);// EXAMPLESall([4, 2, 3], x =&gt; x &gt; 1); // trueall([1, 2, 3]); // true","text":"[Array 1편]코드 30초 시리즈 개요기능을 직접 한땀 한땀 개발하는 것은 개발자로써 매우 중요한 업무입니다.하지만 모든 기능을 미리 만들어 놓고 util함수 처럼 사용한다고 하면 어떨까요?코드 30초만 있다면 빠르게 필요한 기능을 찾아 개발 할 수 있습니다.어떠한 라이브러리도 사용하지않고 오로지 ES6로만 작성되어 있습니다.이제 필요한 코드 찾아 사용하세요.코드 30초 시리즈는 https://30secondsofcode.org/index를 기반으로 번역 &amp; 정리하였습니다. Array편 all제공된 조건부 함수가 컬렉션의 모든 요소에 대해 true를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.Array.prototype.every()를 사용하여 컬렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다. 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오. 1234const all = (arr, fn = Boolean) =&gt; arr.every(fn);// EXAMPLESall([4, 2, 3], x =&gt; x &gt; 1); // trueall([1, 2, 3]); // true allEqual배열의 모든 요소가 같은지 확인하십시오.Array.prototype.every()를 사용하여 배열의 모든 요소가 첫 번째 요소와 동일한 지 확인합니다. 1234const allEqual = arr =&gt; arr.every(val =&gt; val === arr[0]);// EXAMPLESallEqual([1, 2, 3, 4, 5, 6]); // falseallEqual([1, 1, 1, 1]); // true any제공된 조건부 함수가 컬렉션의 적어도 하나의 요소에 대해 true를 반환하면 true를 반환하고 그렇지 않으면 false를 반환합니다.Array.prototype.some()을 사용하여 콜렉션의 모든 요소가 fn에 따라 true를 반환하는지 테스트합니다. 부울을 기본값으로 사용하려면 두 번째 인수 fn을 생략하십시오. 1234const any = (arr, fn = Boolean) =&gt; arr.some(fn);// EXAMPLESany([0, 1, 2, 0], x =&gt; x &gt;= 2); // trueany([0, 0, 1, 0]); // true arrayToCSV2D 배열을 쉼표로 구분 된 값 comma-separated values(CSV) 문자열로 변환합니다.Array.prototype.map() 및 Array.prototype.join(구분 기호)을 사용하여 개별 1D 배열 (행)을 문자열로 결합합니다. Array.prototype.join( &#39;\\ n&#39;)을 사용하여 모든 행을 CSV 문자열로 결합하여 각 행을 개행 문자로 분리합니다. 2번째의 인수 delimiter를 생략해, 디폴트 단락 문자 ‘,’를 사용합니다. 123456const arrayToCSV = (arr, delimiter = &#x27;,&#x27;) =&gt; &#123; return arr.map(v =&gt; v.map(x =&gt; ` &#x27;$&#123;x&#125;&#x27; `).join(delimiter)).join(&#x27;\\n&#x27;);&#125;// EXAMPLESarrayToCSV([[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]]); // &quot; &#x27;a&#x27;,&#x27;b&#x27;\\n&#x27;c&#x27;,&#x27;d&#x27; &quot;arrayToCSV([[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]], &#x27;;&#x27;); // &quot;&#x27;a&#x27;;&#x27;b&#x27;\\n&#x27;c&#x27;;&#x27;d&#x27;&quot; bifurcate값을 두 그룹으로 나눕니다. 필터의 요소가 truey이면 컬렉션의 해당 요소가 첫 번째 그룹에 속합니다. 그렇지 않으면 두 번째 그룹에 속합니다.Array.prototype.reduce() 및 Array.prototype.push()를 사용하여 필터를 기반으로 그룹에 요소를 추가합니다. 12345const bifurcate = (arr, filter) =&gt; &#123; return arr.reduce((acc, val, i) =&gt; (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]);&#125;// EXAMPLESbifurcate([&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;], [true, true, false, true]); // [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ] bifurcateBy입력 컬렉션의 요소가 속한 그룹을 지정하는 조건부 함수에 따라 값을 두 그룹으로 나눕니다. 콜백 함수가 truthy 값을 리턴하면 콜렉션 요소는 첫번째 그룹에 속합니다. 그렇지 않으면 두 번째 그룹에 속합니다.각 요소에 대해 fn이 반환 한 값을 기반으로 Array.prototype.reduce() 및 Array.prototype.push()를 사용하여 그룹에 요소를 추가합니다. 12345const bifurcateBy = (arr, fn) =&gt; &#123; return arr.reduce((acc, val, i) =&gt; (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []]);&#125;// EXAMPLESbifurcateBy([&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;], x =&gt; x[0] === &#x27;b&#x27;); // [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ] chunk배열을 지정된 크기의 더 작은 배열로 채웁니다.Array.from()을 사용하여 생성 될 청크의 수에 맞는 새 배열을 만듭니다.Array.prototype.slice()를 사용하여 새 배열의 각 요소를 청크에 크기의 길이로 매핑합니다.원래 배열을 균등하게 분할 할 수없는 경우 최종 청크에는 나머지 요소가 포함됩니다. 12345678const chunk = (arr, size) =&gt; &#123; return Array.from(&#123; length: Math.ceil(arr.length / size) &#125;, (v, i) =&gt; arr.slice(i * size, i * size + size) );&#125;// EXAMPLESchunk([1, 2, 3, 4, 5], 2); // [[1,2],[3,4],[5]]chunk([1, 2, 3, 4, 5], 3); // [[1,2,3],[4,5]] compact배열에서 거짓 값을 제거합니다.Array.prototype.filter()를 사용하여, falsey값(false, null, 0, “”, 정의되지 않음 및 NaN)을 필터링합니다. 123const compact = arr =&gt; arr.filter(Boolean);// EXAMPLEScompact([0, 1, false, 2, &#x27;&#x27;, 3, &#x27;a&#x27;, &#x27;e&#x27; * 23, NaN, &#x27;s&#x27;, 34]); // [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ] countOccurrences배열에있는 값의 발생을 계산합니다.Array.prototype.reduce()를 사용하여 배열 내부의 특정 값을 만날 때마다 카운터를 증가시킵니다. 12345const countOccurrences &#x3D; (arr, val) &#x3D;&gt; arr.reduce((a, v) &#x3D;&gt; (v &#x3D;&#x3D;&#x3D; val ? a + 1 : a), 0);&#x2F;&#x2F; EXAMPLEScountOccurrences([1, 1, 2, 1, 2, 3], 1); &#x2F;&#x2F; 3countOccurrences([1, 1, 2, 1, 2, 3], 2); &#x2F;&#x2F; 2countOccurrences([1, 1, 2, 1, 2, 3], 3); &#x2F;&#x2F; 1 deepFlattenDeep은 배열을 평평하게합니다.재귀를 사용하십시오. 배열을 평평하게하려면 Array.prototype.concat()에 빈 배열 ([])과 스프레드 연산자 (...)를 사용합니다. 배열 인 각 요소를 재귀 적으로 병합합니다. 123const deepFlatten = arr =&gt; [].concat(...arr.map(v =&gt; (Array.isArray(v) ? deepFlatten(v) : v)));// EXAMPLESdeepFlatten([1, [2], [[3], 4], 5]); // [1,2,3,4,5] difference2개의 배열의 차이를 돌려줍니다.b에서 Set을 만든 다음 a에 Array.prototype.filter()를 사용하여 b에 포함되지 않은 값만 유지합니다. 123456const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x));&#125;;// EXAMPLESdifference([1, 2, 3], [1, 2, 4]); // [3] drop왼쪽부터 n개만큼 제거된 새 배열을 반환합니다.Array.prototype.slice()를 사용하여 왼쪽에서 지정된 수만큼 slice합니다. 12345const drop = (arr, n = 1) =&gt; arr.slice(n);// EXAMPLESdrop([1, 2, 3]); // [2,3]drop([1, 2, 3], 2); // [3]drop([1, 2, 3], 5); // [] dropRight오른쪽부터 n개만큼 제거된 새 배열을 반환합니다.Array.prototype.slice()를 사용하여 왼쪽에서 지정된 수만큼 slice합니다. 12345const dropRight = (arr, n = 1) =&gt; arr.slice(0, -n);// EXAMPLESdropRight([1, 2, 3]); // [1,2]dropRight([1, 2, 3], 2); // [1]dropRight([1, 2, 3], 5); // [] dropRightWhile전달 된 함수가 true를 반환 될 때까지 배열의 끝에서부터 제거하고, 배열의 나머지를 반환합니다.Array.prototype.slice()를 사용하여 함수에서 반환 된 값이 true가 될 때까지 배열의 끝부터 값을 제거 나머지 요소를 반환합니다. 123456const dropRightWhile = (arr, func) =&gt; &#123; while (arr.length &gt; 0 &amp;&amp; !func(arr[arr.length - 1])) arr = arr.slice(0, -1); return arr;&#125;;// EXAMPLESdropRightWhile([1, 2, 3, 4], n =&gt; n &lt; 3); // [1, 2] dropWhile전달 된 함수가 true를 반환 될 때까지 배열의 처음에서부터 제거하고, 배열의 나머지를 반환합니다.Array.prototype.slice()를 사용하여 함수에서 반환 된 값이 true가 될 때까지 배열의 처음부터 값을 제거 나머지 요소를 반환합니다. 123456const dropWhile = (arr, func) =&gt; &#123; while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr = arr.slice(1); return arr;&#125;;// EXAMPLESdropWhile([1, 2, 3, 4], n =&gt; n &gt;= 3); // [3,4] everyNth배열에서 모든 n의 배수 번째 값을 반환합니다.Array.prototype.filter()를 사용하여 지정된 배열에서 모든 n의 배수 번째 값을 포함한 새 배열을 만듭니다. 1234const everyNth = (arr, nth) =&gt; arr.filter((e, i) =&gt; i % nth === nth - 1);//EXAMPLESeveryNth([1, 2, 3, 4, 5, 6], 2); // [ 2, 4, 6 ]everyNth([1, 2, 3, 4, 5, 6], 3); // [ 3, 6 ] filterFalsy배열의 거짓 값을 필터링합니다.Array.prototype.filter()을 사용하여, truey 값만 포함하는 배열을 가져옵니다. 123const filterFalsy = arr =&gt; arr.filter(Boolean);/// EXAMPLESfilterFalsy([&#x27;&#x27;, true, &#123;&#125;, false, &#x27;sample&#x27;, 1, 0]); // [true, &#123;&#125;, &#x27;sample&#x27;, 1] filterNonUnique배열의 고유하지 않은 값을 필터링합니다.Array.prototype.filter()고유 한 값만 포함하는 배열에 사용 합니다. 12345const filterNonUnique = arr =&gt; &#123; return arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));&#125;// EXAMPLESfilterNonUnique([1, 2, 2, 3, 4, 4, 5]); // [1, 3, 5] filterNonUniqueBy인자의 값으로 받은 비교 함수를 기반으로 배열의 고유하지 않은 값을 필터링합니다.fn값으로 받은 인자인 비교 함수를 기반으로 고유 한 값만 포함하는 배열의 경우 Array.prototype.filter()와 Array.prototype.every()를 사용하십시오.비교 함수는 네 개의 인수를 취합니다 : 비교되는 두 요소의 값과 그 인덱스. 12345678910111213const filterNonUniqueBy = (arr, fn) =&gt; arr.filter((v, i) =&gt; arr.every((x, j) =&gt; (i === j) === fn(v, x, i, j)));// EXAMPLESfilterNonUniqueBy( [ &#123; id: 0, value: &#x27;a&#x27; &#125;, &#123; id: 1, value: &#x27;b&#x27; &#125;, &#123; id: 2, value: &#x27;c&#x27; &#125;, &#123; id: 1, value: &#x27;d&#x27; &#125;, &#123; id: 0, value: &#x27;e&#x27; &#125; ], (a, b) =&gt; a.id == b.id); // [ &#123; id: 2, value: &#x27;c&#x27; &#125; ] flatten지정된 뎁스까지 배열을 병합합니다.재귀를 사용하여 depth각 깊이마다 1 씩 감소시킵니다. Array.prototype.reduce()및 Array.prototype.concat()을 사용 하여 값과 배열을 병합합니다. 기본 재귀의 depth는 1로 설정합니다.두 번째 인수는 생략한다면 1만큼의 depth만 플랫합니다. 12345const flatten = (arr, depth = 1) =&gt; arr.reduce((a, v) =&gt; a.concat(depth &gt; 1 &amp;&amp; Array.isArray(v) ? flatten(v, depth - 1) : v), []);// EXAMPLESflatten([1, [2], 3, 4]); // [1, 2, 3, 4]flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8] head리스트의 첫번째 값을 리턴합니다.arr[0]을 사용하여 전달된 배열의 첫 번째 값을 반환합니다. 12345const head = arr =&gt; arr[0];// EXAMPLEShead([1, 2, 3]); // 1head([[1, 2, 3], 4, 5]) // [1, 2, 3]head([&#123;&#x27;a&#x27;: 1,&#x27;b&#x27;: 2,&#x27;c&#x27;: 3&#125;, 4, 5]) //&#123;a: 1, b: 2, c: 3&#125; last리스트의 마지막 값을 리턴합니다.arr.length - 1를 사용하여 전달된 배열의 마지막 값을 반환합니다. 12345const last = arr =&gt; arr[arr.length - 1];//EXAMPLESlast([1, 2, 3]); // 3last([1, 2, [3, 4, 5]]); // [3, 4, 5]last([1, 2, &#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 4, &#x27;c&#x27;: 5&#125;]) // &#123;a: 3, b: 4, c: 5&#125; indexOfAll배열의 값 중 val과 일치하는 모든 값의 인덱스를 반환합니다 . val의 값이 없으면 []이 반환됩니다.Array.prototype.reduce()를 사용하여 val와 일치하는 값을 저장, 루프를 통해 배열의 인덱스를 반환해줍니다. 1234const indexOfAll &#x3D; (arr, val) &#x3D;&gt; arr.reduce((acc, el, i) &#x3D;&gt; (el &#x3D;&#x3D;&#x3D; val ? [...acc, i] : acc), []);&#x2F;&#x2F; EXAMPLESindexOfAll([1, 2, 3, 1, 2, 3], 1); &#x2F;&#x2F; [0,3]indexOfAll([1, 2, 3], 4); &#x2F;&#x2F; [] 1편을 마치며…코드 30초 시리즈를 https://30secondsofcode.org/index 살펴보면, 내용이 매우 많다는것을 알 수 있습니다.현재 Array에 대한 부분을 진행하고 있음에도 아직 반도 번역하지 못했습니다.앞으로도 꾸준히 진행하도록 하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"transform","slug":"transform","permalink":"https://tuhbm.github.io/tags/transform/"},{"name":"30sec","slug":"30sec","permalink":"https://tuhbm.github.io/tags/30sec/"},{"name":"js","slug":"js","permalink":"https://tuhbm.github.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://tuhbm.github.io/tags/array/"}]},{"title":"번역 - OOCSS, BEM, SMACSS를 사용하여 CSS 구조를 효과적으로 구성하는 방법","slug":"cssArchitecture","date":"2018-12-09T02:04:10.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/12/09/cssArchitecture/","link":"","permalink":"https://tuhbm.github.io/2018/12/09/cssArchitecture/","excerpt":"OOCSS, BEM, SMACSS를 사용하여 CSS 구조를 효과적으로 구성하는 방법필자는 레고 블록을 매우 좋아하는 장난감으로 아주 많았습니다.레고블록은 저의 첫번째 창의적인 작품이었습니다. 그것들은 무엇이든 생각하는대로 조립이 가능했습니다.나는 그 당시 왜 그렇게 레고를 좋아했는지 몰랐습니다.하지만 스타워즈 팔콘을 만들어보면 색깔 및 7000여조각이 각 조각별로 어떻게 완벽하게 맞아 떨어지는지를 보여주었습니다. 이런식으로 처리가 된다면 조직화되어 HTML은 더 작아지고, CSS는 훨씬 관리하기 쉬워져 프론트엔드 개발속도가 빨라지게 됩니다. 이번 글에서는 CSS 구조를 레고블록처럼 동작하게하여 HTML / CSS 블록으로 구성하는 방법을 설명합니다. CSS 방법론중에 세가지 모듈화 방법을 소개하겠습니다.이 방법론은 우리가 이해하고, 유지하고, 재사용하기 쉽게 컴포넌트화 하는데 도움이 될 것입니다. 저는 당신이 사용하고 있는 프론트엔드 프레임워크에 상관없이 이러한 방법들이 당신의 일하는 방식의 일부가 될꺼라고 확신합니다.당신이 이 방법론들을 사용한다면 확신합니다.","text":"OOCSS, BEM, SMACSS를 사용하여 CSS 구조를 효과적으로 구성하는 방법필자는 레고 블록을 매우 좋아하는 장난감으로 아주 많았습니다.레고블록은 저의 첫번째 창의적인 작품이었습니다. 그것들은 무엇이든 생각하는대로 조립이 가능했습니다.나는 그 당시 왜 그렇게 레고를 좋아했는지 몰랐습니다.하지만 스타워즈 팔콘을 만들어보면 색깔 및 7000여조각이 각 조각별로 어떻게 완벽하게 맞아 떨어지는지를 보여주었습니다. 이런식으로 처리가 된다면 조직화되어 HTML은 더 작아지고, CSS는 훨씬 관리하기 쉬워져 프론트엔드 개발속도가 빨라지게 됩니다. 이번 글에서는 CSS 구조를 레고블록처럼 동작하게하여 HTML / CSS 블록으로 구성하는 방법을 설명합니다. CSS 방법론중에 세가지 모듈화 방법을 소개하겠습니다.이 방법론은 우리가 이해하고, 유지하고, 재사용하기 쉽게 컴포넌트화 하는데 도움이 될 것입니다. 저는 당신이 사용하고 있는 프론트엔드 프레임워크에 상관없이 이러한 방법들이 당신의 일하는 방식의 일부가 될꺼라고 확신합니다.당신이 이 방법론들을 사용한다면 확신합니다. OOCSS OOCSS (Object Oriented CSS)은 모든 인터페이스 디자인 및 개발을 개선하기 위한 개념의 기반입니다.이것은 가능하면 최대한 재사용되어야 컴포넌트로써 좋은 역할을 한다는 것을 알려줍니다. OOCSS는 객체지향 프로그래밍과 마찬가지로 유연하고 잘 동작하도록 재사용 가능한 컴포넌트를 구성하는것에 중점을 두고 있습니다.이러한부분은 단일책임원, 관심사 분리 및 중복배제과 같은 기본 프로그래밍 원칙을 포함합니다. 또한 필수 UX 및 그래픽 디자인의 체크 요소인 일관성 검사를 합니다. 인터페이스 전반적으로 유사한 버튼의 디자인을 통일화 하면, 사용자는 익숙해하고 새로운 페이지에서 더욱 직관적으로 느낍니다.OOCCS를 사용하여 코드를 재사용하면 코드의 중복이 제거 되므로써 더 빠르고 쉽게 만들 수 있습니다. Nicole Sullivan의 2010년 포스팅 글에서는 미디어 객체의 OOCSS를 적용한 장점에 대해 설명했습니다.이글의 주요 내용은 HTML과 CSS 모두를 코드블록 형태로 패턴화하고 추상화하는 내용입니다. 다음은 Nicole의 미디어 객체의 예제입니다. 12345678910111213&lt;div class=&quot;media&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;img&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;div class=&quot;bd&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.media &#123;...&#125; .media .img &#123;...&#125; .media .img img &#123;...&#125; .media .imgExt &#123;...&#125; .bd &#123;...&#125;&lt;/style&gt; 보시면 아시겠지만, 컴포넌트를 캡슐화하여 CSS의 다른곳에서도 스타일을 적절히 사용합니다.밀단 미디어 컴포넌트를 배치하면 모든 코드는 일관적으로 동작해야합니다. BEMBEM은 Yandex가 만든 OOCSS 원칙을 구체적으로 적용한 것입니다. 이방법의 의미는 crazy complicated framework에서 Block, element, Modifier 입니다.Nicolas Gallagher가 가장 인기있는 BEM 명명규칙을 단순화 했습니다.이러한 버전은은 이미 대부분의 요구를 충족합니다. 이전 코드의 예제에 BEM 네임 스페이스를 적용해보겠습니다. 1234567891011121314151617181920&lt;div class=&quot;media media--inverted&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;media__image-wrapper&quot;&gt; &lt;img class=&quot;media__image&quot; src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;div class=&quot;media__content&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.media &#123;...&#125;.media--inverter &#123;...&#125;.media__image-wrapper &#123;...&#125;.media__image &#123;...&#125;.media__content &#123;...&#125;// With SASS - which will output the code above.media &#123; ... &amp;--inverter &#123;...&#125; &amp;__image-wrapper &#123;...&#125; &amp;__image &#123;...&#125; &amp;__content &#123;...&#125; &#125;&lt;/style&gt; BEM에서 한가지 중요한 점은 특이성 제어입니다. 위에서 언급한 명명 규칙을 사용하여 우리는 .class단일 선택자 [0 0 1 0]로 우리의 특이성을 자동으로 무너트립니다.계단식 특이성이 너무 복잡하다는 사실을 알게 되면, 아래와 같은 사항을 명심하세요. 항상 .class 단일 선택기를 사용하세요. 다음 몇 단락은 위해 당신이 먼저 [0 0 1 0]의 의미를 이해한다고 가정하겠습니다.만약 이해하지못했다면 먼저 읽으세요. css의 특이성은 좀 어렵지만 일단 이해하면 꽤 빨리 활용 할 수 있습니다. BEM의 명명규칙에 따라 .class를 사용하여 [0 0 1 0]가 된다면 우리는 이미 90%의 스타일을 보유하게 됩니다.이것만으로도 우리는 작업이 편해질 것입니다. 그렇다면 우리는 @imports의 파싱 순서가 중요합니다.그렇기에 @imports순서에 대해 주의를 기울여주세요. 구성요소가 각페이지에 있다면 [0 0 1 0]인 상황에서 body에 ID를 추가하여 페이지에 대한 CSS를 지정 할 수 있습니다.해당 ID를 사용하여 적용 범위를 지정하면 [0 1 1 0]로 코드의 스타일 순서에 관계없이 훨씬 높은 특이성을 발휘합니다. 참고: 두개의 서로 다른 페이지에서 동일한 재정의를 사용해야 하는 경우에는 &amp;--modifier를 사용하여 추상화 하는 것이 좋습니다. 위와 같은 재정의는 적어야합니다.필자가 사용하는 방식은 SMACSS 과 Atomic Design by Brad Frost의 개념을 기반으로 합니다. SMACSSSMACSS는 Yahoo와 Spotify에서 근무한 Jonathan Snook이 대규모의 프로젝트 CSS 코드의 베이스 및 팀워크를 염두해서 만든 Scalable and Modular Architecture의 약자입니다.조나단은 SMACSS 참고서에서 몇가지 깔끔한 아이디어와 CSS 파일 구조 모범 사례를 제시했습니다. SMACSS 두번째 수정버전은 구성 요소와 React Craze가 출시되기 오래 전인 2012 년입니다.나에게 SMACSS의 가장 흥미로운 부분은 랩퍼와 컨테이너를 사용하여 컴포넌트를 완벽하게 적합하게 만드는 것입니다. 이러한 기술은 컴포넌트 방식의 기본 요소입니다. 레고 블록을 기억하세요.그러나 이러한 기술은 CSS 속성을 작성할때 컴포넌트가 서로 상호작용하는 방식을 방해하지 않도록 많은 규칙을 필요로 합니다. CSS 컴포넌트 모듈성 이론123.block .block__element .block__slot 기본적으로 .block에는 float:left또는 margin-top:20px같은 기본 css속성을 갖지 않습니다.이러한 부분은 class가 하나 이상의 경우 일관성 없이 동작하는 것을 방해가 될 수 있다. 내가 유용하다고 생각하는 또 다른 최고의 SMACSS 연습은 컨테이너 또는 슬롯의 개념이다.이것은 Vue.js의 &lt;slot&gt;처럼 작동합니다. 컴포넌트의 변경 공간을 만들고, 우리가 속성을 추가했을때 내부의 컴포넌트가 변경됩니다.여기서 우리는 padding과 같은 속성을 .block__continer에 추가하지 않습니다. padding을 추가하면 내부의 컴포넌트가 방해받습니다.우리는 그런걸 원하지 않습니다. CSS 아키텍처의 베스트 프랙티스는 이미 CSS를 모듈화되고 “올바르게 작동”하게 만드는 것입니다.우리가 사용하는 프레임 워크와 독립적인 HTML 및 CSS 작성에 대한 컴포넌트 접근 방식을 적용 하는것입니다.SMACSS는 CSS 속성을 구성하는 방법 이상의 것입니다. SMACSS의 주요 장점은 모듈성 입니다.이 가이드 라인을 따르면 HTML / CSS가 이미 주요 JS 프레임 워크에서 구현 될 수 있습니다. 개념적 구조를 따르기 때문입니다. 프레임 워크에 독립적인 모듈 CSS나의 목표: 체계적이고 유지 보수가 잘되는 CSS 나는 이방법론의 더 좋은 인터페이스를 연구합니다. 현대적인 인터페이스를 위해서는 각 컴포넌트를 격리시켜 효과적으로 구축 할 수 있어야합니다.많은 프레임워크와 무관하게 컴포넌트를 개발하는 최소한의 요구사항을 확인 하려고 노력합니다. OOCSS 및 웹 구성 요소의 개념은 스타일링과 거의 동일합니다.독립적인 인터페이스 컴포넌트를 만드는 것은 지금까지 우리가 생각해 낸 최고의 솔루션이며 수백 개의 기사가 있습니다. BEM은보다 전통적인 설정에서 작업 할 때 특히 유용합니다.이 환경에서는 해당 컴포넌트의 스타일을 범위 지정하고 요소에 컨텍스트 정보를 추가하는 두 가지 용도로 사용됩니다.하지만 이제는 익숙해지기 때문에 React 나 Vue 에서도 BEM 클래스 이름을 사용하게됩니다 . SMACSS의 용기와 포장재를 똑똑하게 사용하면 컴포넌트가 서로 잘 작동하고 어느 곳에서나 적합해집니다.또한 우수한 CSS 파일 구성은 디자인처럼 사용이 더 간단합니다.대규모 프로젝트의 경우이 기능은 매력처럼 작동합니다. OOCSS와 BEM &amp; SMACSS를 함께 사용하면 스택이나 프레임 워크에 관계없이 스파게티 코드 작별에 도움이됩니다! 출처이 글은 Medium의 laudio Mendonca의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://tuhbm.github.io/tags/architecture/"},{"name":"OOCSS","slug":"OOCSS","permalink":"https://tuhbm.github.io/tags/OOCSS/"},{"name":"BEM","slug":"BEM","permalink":"https://tuhbm.github.io/tags/BEM/"},{"name":"SMACSS","slug":"SMACSS","permalink":"https://tuhbm.github.io/tags/SMACSS/"},{"name":"style","slug":"style","permalink":"https://tuhbm.github.io/tags/style/"},{"name":"css","slug":"css","permalink":"https://tuhbm.github.io/tags/css/"}]},{"title":"번역 - 자바스크립트 분해(destructuring)","slug":"javascriptDestructuring","date":"2018-12-01T16:02:03.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/12/01/javascriptDestructuring/","link":"","permalink":"https://tuhbm.github.io/2018/12/01/javascriptDestructuring/","excerpt":"자바스크립트 객체와 배열 분해(destructuring) destructuring은 배열 및 객체의 값으로 변수를 생성하는 강력한 방법입니다.이 방법은 코드를 더 간결하게 만드는 방법입니다. 다만 destructuring은 ES2015(ES6)의 일부이며 모든 브라우저와 호환되지 않습니다.모든 사용자에게 완전한 호환성을 보장하기 위해 babel, typescript 또는 코드를 ES5로 컴파일하는 모든 것을 사용할 것을 권장합니다. 배열 분해(destructuring)배열의 값을 별도의 변수에 할당하려는 경우, destructuring을 통해 간단하고 깨끗하게 할당 할 수 있습니다.인덱스나 루프를 사용할 필요가 없습니다!","text":"자바스크립트 객체와 배열 분해(destructuring) destructuring은 배열 및 객체의 값으로 변수를 생성하는 강력한 방법입니다.이 방법은 코드를 더 간결하게 만드는 방법입니다. 다만 destructuring은 ES2015(ES6)의 일부이며 모든 브라우저와 호환되지 않습니다.모든 사용자에게 완전한 호환성을 보장하기 위해 babel, typescript 또는 코드를 ES5로 컴파일하는 모든 것을 사용할 것을 권장합니다. 배열 분해(destructuring)배열의 값을 별도의 변수에 할당하려는 경우, destructuring을 통해 간단하고 깨끗하게 할당 할 수 있습니다.인덱스나 루프를 사용할 필요가 없습니다! 아래 예제에 4개의 값을 4개의 변수에 할당하려는 경우 다음과 같이 배열을 destructuring을 사용할 수 있습니다. 1234567const organizations = [&#x27;Pyke&#x27;, &#x27;Black Sun&#x27;, &#x27;Kanjiklub&#x27;, &#x27;Crimson Dawn&#x27;];const [firstGang, secondGang, thirdGang, fourthGang] = organizations;console.log(firstGang); // Outputs &#x27;Pyke&#x27;console.log(secondGang); // Outputs &#x27;Black Sun&#x27;console.log(thirdGang); // Outputs &#x27;Kanjiklub&#x27;console.log(fourthGang); // Outputs &#x27;Crimson Dawn&#x27; 변수 vs 값 은 위치는 여기에서 중요합니다. 첫 번째 새 변수는 항상 배열의 첫 번째 값을 상속합니다. 하지만 처음 두 값만 변수로, 나머지는 배열로 만들면 어떻게 될까요? 매우 간단합니다. 123456const organizations = [&#x27;Pyke&#x27;, &#x27;Black Sun&#x27;, &#x27;Kanjiklub&#x27;, &#x27;Crimson Dawn&#x27;];const [firstGang, secondGang, ...theRest] = organizations;console.log(firstGang); // Outputs &#x27;Pyke&#x27;console.log(secondGang); // Outputs &#x27;Black Sun&#x27;console.log(theRest); // Outputs [&#x27;Kanjiklub&#x27;, &#x27;Crimson Dawn&#x27;] 원하는 경우 기본값을 설정할 수도 있습니다!이렇게 하면 전달된 어레이의 값이 충분하지 않더라도 모든 변수의 값이 정의됩니다! 12345678910const organizations = [&#x27;Pyke&#x27;, &#x27;Black Sun&#x27;];const [ firstGang = &#x27;First Order&#x27;, secondGang = &#x27;Resistance&#x27;, thirdGang = &#x27;New Republic&#x27;] = organizations;console.log(firstGang); // Outputs &#x27;Pyke&#x27;console.log(secondGang); // Outputs &#x27;Black Sun&#x27;console.log(thirdGang); // Outputs &#x27;New Republic&#x27; 일반적인 사례지금은 당장 이러한 방법을 언제 사용할지 궁굼 할 것입니다. 이러한 사례들은 도대체 언제 사용하나요?실제로 많은 곳에서 사용 할 수 있습니다. 예를 들어 블로그 게시물이 배열로 있지만 다른 게시물과 다르게 첫번째 게시물을 조작하고 싶다면,이러한 경우 destructuring을 사용하여, 첫번째 게시물과 나머지 게시물을 두개의 변수로 나눌 수 있습니다. 1const [starPost, ... otherPosts] = blogPosts; 또는 배열의 처음 게시물 새가지만 메인에 노출하기위해 필요하다면, 세개의 변수를 선언하여 저장하면 됩니다. 1const [post1, post2, post3] = blogPosts; 객체 분해(destructuring)destructuring을 사용하여 객체의 값을 변수에 할당 할 수도 있습니다. 배열에서 사용했을때의 방법과 매우 유사합니다. 12345678910const planet = &#123; name: &#x27;Hosnian Prime&#x27;, faction: &#x27;New Republic&#x27;, weather: &#x27;Temperate&#x27;&#125;;const &#123; name, faction, weather &#125; = planet;console.log(name); // Outputs &#x27;Hosnian Prime&#x27;console.log(faction); // Outputs &#x27;New Republic&#x27;console.log(weather); // Outputs &#x27;Temperate&#x27; 위의 예제에서 볼 수 있듯이, 우리는 객체의 키의 이름과 같은 이름을 변수에 사용했습니다.그러나 키와 이름이 다른 변수를 정의할 수 있습니다. 방법은 아래와 같습니다. 1234567891011121314const planet = &#123; name: &#x27;Hosnian Prime&#x27;, faction: &#x27;New Republic&#x27;, weather: &#x27;Temperate&#x27;&#125;;const &#123; name: system, faction: team, weather: conditions&#125; = planet;console.log(system); // Outputs &#x27;Hosnian Prime&#x27;console.log(team); // Outputs &#x27;New Republic&#x27;console.log(conditions); // Outputs &#x27;Temperate&#x27; 배열과 마찬가지로 기본값을 설정할 수도 있습니다. 123456789101112const planet = &#123; name: &#x27;Hosnian Prime&#x27;&#125;;const &#123; name = &#x27;Unknown planet&#x27;, faction = &#x27;Unknown faction&#x27;, weather = &#x27;Unknown conditions&#x27;&#125; = planet;console.log(name); // Outputs &#x27;Hosnian Prime&#x27;console.log(faction); // Outputs &#x27;Unknown faction&#x27;console.log(weather); // Outputs &#x27;Unknown conditions&#x27; 일반적인 사례객체에서 하나 이상의 값만 필요로 하면 그동안 우리는 객체의이름.키이름을 사용하여 접근하였습니다.하지만 우리는 destructuring을 통해 매우 간단하게 새 변수에 저장하면됩니다.(코드가 매우 간결하게 유지됩니다.) 그러나 객체 destructuring의 가장 주요한 기능은 옵션에 대한 처리입니다.기본값을 사용하여 옵션을 처리하는 함수가 있다고 가정하면 다음과 같은 간단한 방법으로 옵션을 처리할 수 있습니다. 12345678910111213function shipGenerator(options = &#123;&#125;) &#123; const &#123; cannons = 4, engines = 2, crew = 10 &#125; = options; // Default options return `This ship has $&#123;cannons&#125; cannons, $&#123;engines&#125; engines, and $&#123;crew&#125; crew members.`;&#125;console.log(shipGenerator(&#123; engines: 10, crew: 20 &#125;)); // Outputs &#x27;This ship has 4 cannons, 10 engines and 20 crew members.&#x27;console.log(shipGenerator(&#123; cannons: 0 &#125;)); // Outputs &#x27;This ship has 0 cannons, 2 engines and 10 crew members.&#x27;console.log(shipGenerator()); // Outputs &#x27;This ship has 4 cannons, 2 engines and 10 crew members.&#x27; 위에서 본것처럼 option = &#123;&#125;을 인수로 쓰면 아무것도 전달되지 않았을 경우 기본적으로 빈 객체의 값을 사용하도록 지정하였습니다. 그후 우리는 destructuring를 사용하여 기본 옵션값을 오버라이드(override)를 계속 하며 사용합니다. 우리가 만든 함수는 간단하게 cannons의 값을 변경하며 사용하였습니다. destructuring사용을 다른사람에게 권장하세요.당신은 destructuring과 같은 멋진 방법을 프로젝트에서 사용하였나요? 아래 댓글을 통해 의견을 남겨 동료 개발자들을 돕고 소통하세요~! 그리고 지속적인 코딩을 하세요~! :) 출처이 글은 Medium의 AJ Meyghani의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"array","slug":"array","permalink":"https://tuhbm.github.io/tags/array/"},{"name":"object","slug":"object","permalink":"https://tuhbm.github.io/tags/object/"},{"name":"destructuring","slug":"destructuring","permalink":"https://tuhbm.github.io/tags/destructuring/"}]},{"title":"번역 - 비동기 자바스크립트의 간단한 참고서 3편","slug":"async03","date":"2018-11-24T17:18:14.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2018/11/24/async03/","link":"","permalink":"https://tuhbm.github.io/2018/11/24/async03/","excerpt":"비동기 자바스크립트의 간단한 참고서 3편지난시간 1편에서 동기와 비동기에 대해 배우고, callback을 통해 비동기 통신을 해보았습니다.2편에서는 callback이 아닌 Promise을 알아보고 정적메소드를 알아보았습니다.이번시간에는 Promise를 순서대로 진행해보고, 실습을 진행해 보겠습니다. Promise순서대로 실행하기만약 두 개의 비동기 작업을 순서대로 실행하려면 다음과 같은 패턴을 따라야합니다. 12345678910111213141516const promiseChain = task1() .then(function(task1Result) &#123; return task2(); &#125;) .then(function(task2Result) &#123; return task3(); &#125;) .then(function(task3Result)&#123; return task4(); &#125;) .then(function(task4Result) &#123; console.log(&#x27;done&#x27;, task4Result); &#125;) .catch(function(err) &#123; console.log(&#x27;Error&#x27;, err); &#125;);","text":"비동기 자바스크립트의 간단한 참고서 3편지난시간 1편에서 동기와 비동기에 대해 배우고, callback을 통해 비동기 통신을 해보았습니다.2편에서는 callback이 아닌 Promise을 알아보고 정적메소드를 알아보았습니다.이번시간에는 Promise를 순서대로 진행해보고, 실습을 진행해 보겠습니다. Promise순서대로 실행하기만약 두 개의 비동기 작업을 순서대로 실행하려면 다음과 같은 패턴을 따라야합니다. 12345678910111213141516const promiseChain = task1() .then(function(task1Result) &#123; return task2(); &#125;) .then(function(task2Result) &#123; return task3(); &#125;) .then(function(task3Result)&#123; return task4(); &#125;) .then(function(task4Result) &#123; console.log(&#x27;done&#x27;, task4Result); &#125;) .catch(function(err) &#123; console.log(&#x27;Error&#x27;, err); &#125;); Promise 체이닝은 Promise를 반환하는 첫번째 작업을 호출하며 시작합니다.이후에 then메소드를 통해 연결 유지할 수 있는 Promise를 반환하며 호출을 연결합니다.이패턴을 언제 사용하는지 예를 들어보겠습니다. 우리는 유효하지 않은 무작위의 문자가 들어있는 텍스트 파일이 있다고 가정해보겠습니다. 이러한 문제를 해결하려면 우선 파일의 내용으 읽어야합니다.그런 다음 유효하지 않은 문자를 제거하고 그 결과를 다른 파일에 기록해야합니다. Promise를 반환하는 각 연산에 대한 함수가 있다고 가정하면,아래와 같이 Promise 체이닝을 사용할 수 있습니다. 1234567891011121314// code/promise/promise-in-sequence.jsconst promiseChain = readFile(&#x27;example.txt&#x27;) .then(function(content) &#123; return removeInvalidChracters(content); &#125;) .then(function(cleanContent) &#123; return writeToFile(&#x27;./clean-file.txt&#x27;, cleanContent); &#125;) .then(function() &#123; console.log(&#x27;done&#x27;); &#125;) .catch(function(error) &#123; console.log(error); &#125;); 위의 코드는 Promise 체이닝을 사용하여 작업이 시작되어 각 작업이 원하는 순서대로 수행되고 완료됩니다.각각의 .then메소드를 사용한 블록({})에서는 return을 통해 값을 반환해야합니다. 그렇지 않으면 의도한 순서대로 실행되지 않습니다.그래서 then메소드를 사용한 각각의 블록({})에서 비동기 함수를 호출하여 올바른 순서대로 실행합니다.아래는 항상 피해야 하는 코드의 예입니다. 1234567getUserData () .then (info =&gt; &#123; authenticate (info) .then (authResult =&gt; &#123; doSomething (authResult); &#125;); &#125;); 위와 같은 방식은 적절하지 못한 방법입니다.위의 방법 대신 적절한 체인을 통해 연결하여 사용하고, 각단계마다 값을 return해야 합니다.아래와 같은 방법으로 말이죠! 123getUserData () .then (info =&gt; authenticate (info)) .then (authResult =&gt; doSomething (authResult)) 위 코드에서는 한줄로 블록({})없이 화살표 함수를 사용했기 때문에 오른쪽의 =&gt; 다음에 암시적으로 값이 return됩니다. 동시 Promise 실행하기Promise를 반환하는 비동기 함수를 호출하면 해당 작업이 비동기적으로 실행된다고 가정해 볼 수 있습니다.따라서 각행에서 각각의 함수를 하나씩 호출하면, 사실각 각 작업을 동시에 실행합니다. 1234567function runAll() &#123; const p1 = taskA(); const p2 = taskB(); const p3 = taskC();&#125;runAll(); 이후 모든 작업이 끝났을때 무언가 하고 싶다면 Promise.all을 다음코드 처럼 사용 수 있습니다. 1234567891011// code/promises/run-all.jsfunction runAll() &#123; const p1 = taskA(); const p2 = taskB(); const p3 = taskC(); return Promise.all([p1, p2, p3]);&#125;runAll() .then(d =&gt; console.log(d, &#x27;all done&#x27;)) .catch(e =&gt; console.log(e)); 이제 동시적으로 실행해되는 Promise를 결합하는 방법에 대해 살펴 보겠습니다. Promise의 결합동시적으로 실행해야 하는 작업을 진행해보겠습니다. 비동기적으로 저작해야하는 파일이 있다고 가정해보겠습니다.3개의 다른파일에 A,B,C,D의 작업을 순서대로 수행해보겠습니다. 처리순서는 신경쓰지 않아도 됩니다. A,B,C,D순서대로 발생됩니다.이를 실행하기 위한 순서는 아래와 같습니다. Promise List 작성 각각의 Promise 작업 A,B,C,D 순서대로 실행 Promise.all을 통해 모든 Promise 실행. 앞서 언급대로 all은 Promise를 동시에 처리하는 메소드 입니다.1234567891011121314const files = [&#x27;a.txt&#x27;, &#x27;b.txt&#x27;, &#x27;c.txt&#x27;];function performInOrder(file) &#123; const promise = taskA(file) .then(taskB) .then(taskC) .then(taskD); return promise;&#125;const operations = files.map(performInOrder);const result = Promise.all(operations);result.then(d =&gt; console.log(d)).catch(e =&gt; console.log(e)); 앞선 가정이 아닌 실제 실행할 수 있는 a.txt, b.txt, c.txt를 가공하는 코드를 작성해 보겠습니다.2편에서 소개했던 util.promisify를 사용해 보겠습니다. 12345678910111213141516171819// code/promises/read-write-multiple-files/main.jsconst fs = require(&#x27;fs&#x27;);const util = require(&#x27;util&#x27;);const readFile = util.promisify(fs.readFile);const writeFile = util.promisify(fs.writeFile);const copyFile = (file) =&gt; (content) =&gt; (writeFile(file + &#x27;-copy.txt&#x27;, content));const replaceContent = input =&gt; (Promise.resolve(input.replace(/-/g, &#x27;zzzz&#x27;)));const processEachInOrder = file =&gt; &#123; return readFile(file, &#x27;utf-8&#x27;) .then(replaceContent) .then(copyFile(file));&#125;const files = [&#x27;./a.txt&#x27;, &#x27;./b.txt&#x27;, &#x27;./c.txt&#x27;];const promises = files.map(processEachInOrder);Promise.all(promises) .then(d =&gt; console.log(d)) .catch(e =&gt; console.log(e)); 이러한 처리는 입력 크기가 큰 경우에 CPU에 많은 부담을 줄 수 있습니다. 더 좋은 방법은 동시에 처리되는 작업의 수를 제한하는 것입니다.비동기 라이브러리는 한 번에 처리되는 비동기 작업의 수를 제한하는 qeueue 메소드가있어, CPU의 추가 부하를 줄일 수 있습니다. 연습문제디렉토리(1뎁스)의 파일을 읽고 output이라는 폴더에 복사하는 스크립트를 작성하시오.힌트1 이전의 예제를 이용하시오.힌트2 폴더내용을 읽고 util.stat메소드를 사용하여 항목이 파일인지 확인 후 폴더를 만들고 각 파일을 읽고 폴더에 작성합니다.해결방법Promise.all을 사용하여 읽고 쓰기를 처리하는 Promise 반환하는 방법입니다. 1234567891011121314151617181920212223242526272829303132333435363738// code/promises/exercise/main.js/* List the content of the folder, filter out the files only then copy to the output folder. */const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const util = require(&#x27;util&#x27;);const readFile = util.promisify(fs.readFile);const writeFile = util.promisify(fs.writeFile);const readdir = util.promisify(fs.readdir);const stat = util.promisify(fs.stat);const mkdir = util.promisify(fs.mkdir);const outputFolder = &#x27;./output&#x27;;function isFile(f) &#123; return stat(f).then(d =&gt; d.isFile() ? f : &#x27;&#x27;);&#125;function filterFiles(list) &#123; return Promise.all(list.map(isFile)) .then(files =&gt; files.filter(v =&gt; v));&#125;function readWrite(result) &#123; const files = result[1]; return Promise.all(files.map(f =&gt; &#123; return readFile(f) .then(content =&gt; writeFile(path.join(outputFolder, f), content)); &#125;));&#125;const getFiles = readdir(&#x27;./&#x27;).then(filterFiles);Promise.all([mkdir(outputFolder), getFiles]) .then(readWrite) .then(_ =&gt; console.log(&#x27;done!&#x27;)) .catch(e =&gt; console.log(e)); 지금까지 Promise를 동시 실행하고 실습해보았습니다.다음글에서는 좀 더 나아가 제너레이터에 대해 알아보겠습니다. 출처이 글은 Medium의 AJ Meyghani의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://tuhbm.github.io/tags/promise/"},{"name":"all","slug":"all","permalink":"https://tuhbm.github.io/tags/all/"},{"name":"method","slug":"method","permalink":"https://tuhbm.github.io/tags/method/"},{"name":"동기","slug":"동기","permalink":"https://tuhbm.github.io/tags/%EB%8F%99%EA%B8%B0/"},{"name":"비동기","slug":"비동기","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"synchronous","slug":"synchronous","permalink":"https://tuhbm.github.io/tags/synchronous/"},{"name":"asynchronous","slug":"asynchronous","permalink":"https://tuhbm.github.io/tags/asynchronous/"},{"name":"return","slug":"return","permalink":"https://tuhbm.github.io/tags/return/"},{"name":"then","slug":"then","permalink":"https://tuhbm.github.io/tags/then/"}]},{"title":"번역 - 비동기 자바스크립트의 간단한 참고서 2편","slug":"async02","date":"2018-11-14T21:31:06.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2018/11/14/async02/","link":"","permalink":"https://tuhbm.github.io/2018/11/14/async02/","excerpt":"비동기 자바스크립트의 간단한 참고서 2편지난시간 1편에서 동기와 비동기에 대해 배우고, callback을 통해 비동기 통신을 해보았습니다.이번시간에는 callback이 아닌 Promise을 알아보고 이를 통해 비동기 작업을 진행하는 방법을 알아보겠습니다. Promises12Promise는 아마도 자바 스크립트로 비동기 프로그래밍에서 가장 중요한 추상적인 개념 일 것입니다. Promise는 다른 많은 비동기 추상적인 개념을 위한 토대를 마련하기 때문에 이 섹션을 반드시 주의 깊게 읽으십시오. Promise는 미래의 특정 시점에서 실행될 때 성공하거나 실패할 수 있는 비동기 작업의 결과를 나타내는 개체입니다. 예를 들어 API 서버에 요청을 할 때 api 호출의 결과를 나타내는 약속을 반환할 수 있습니다.api 호출은 성공할 수도 있고 성공하지 못할 수도 있지만 결국에는 사용할 수있는 promise 객체를 얻게됩니다. 아래의 함수는 api 호출을 수행하고 그 결과를 promise 형식으로 반환합니다. 123456// code/promises/axios-example.jsconst axios = require(&#x27;axios&#x27;); // Afunction getDataFromServer() &#123; const result = axios.get(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;); // B return result; // C&#125; A 행 axios에서 promise 기반 http 클라이언트 인 모듈을 로드합니다. B 행에서 우리는 axios api의 endpoint에서 GET 요청을하고 그 결과를 result 상수로 저장합니다. C 행에서 우리는 promise를 리턴합니다.","text":"비동기 자바스크립트의 간단한 참고서 2편지난시간 1편에서 동기와 비동기에 대해 배우고, callback을 통해 비동기 통신을 해보았습니다.이번시간에는 callback이 아닌 Promise을 알아보고 이를 통해 비동기 작업을 진행하는 방법을 알아보겠습니다. Promises12Promise는 아마도 자바 스크립트로 비동기 프로그래밍에서 가장 중요한 추상적인 개념 일 것입니다. Promise는 다른 많은 비동기 추상적인 개념을 위한 토대를 마련하기 때문에 이 섹션을 반드시 주의 깊게 읽으십시오. Promise는 미래의 특정 시점에서 실행될 때 성공하거나 실패할 수 있는 비동기 작업의 결과를 나타내는 개체입니다. 예를 들어 API 서버에 요청을 할 때 api 호출의 결과를 나타내는 약속을 반환할 수 있습니다.api 호출은 성공할 수도 있고 성공하지 못할 수도 있지만 결국에는 사용할 수있는 promise 객체를 얻게됩니다. 아래의 함수는 api 호출을 수행하고 그 결과를 promise 형식으로 반환합니다. 123456// code/promises/axios-example.jsconst axios = require(&#x27;axios&#x27;); // Afunction getDataFromServer() &#123; const result = axios.get(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;); // B return result; // C&#125; A 행 axios에서 promise 기반 http 클라이언트 인 모듈을 로드합니다. B 행에서 우리는 axios api의 endpoint에서 GET 요청을하고 그 결과를 result 상수로 저장합니다. C 행에서 우리는 promise를 리턴합니다. 이제 함수를 호출하고 결과에 접근하여 오류를 캐치 할 수 있습니다.1234567getDataFromServer() .then(function(response) &#123; console.log(response); &#125;) .catch(function(error) &#123; console.log(error); &#125;); 모든 Promise에는 then과 catch 메서드를 가지고있습니다. then메소드는 실행 후 성공한 결과를 캡쳐하고, catch메서드의 경우 실행에 실패한 경우 사용된다.then과 `catch 모두 단일 인자의 콜백 함수를 사용하여 결과를 캡처합니다. 또한이 두 방법 모두 메서드 체인을 연결할 수 있는 Promise을 반환한다는 점에 주목할 필요가 있습니다. 다음은 Promise를 반환 할 수 있는 비동기 작업의 몇 가지 예입니다. 파일의 내용 읽기 : 반환 된 Promise에는 파일의 내용이 포함됩니다. 디렉토리 내용 나열 : 반환 된 Promise에는 파일 목록이 포함됩니다. csv 파일 구문 분석 : 반환 된 Promise에는 구문 분석 된 내용이 포함됩니다 데이터베이스에 대해 일부 쿼리 실행 : 반환 된 Promise에는 쿼리 결과가 포함됩니다. 아래 그림은 Promise의 상태를 요약 한 것입니다. Promise의 이점Promise는 다른 언어로 존재했으며 콜백 메커니즘에 대한 추상화를 제공하기 위해 JavaScript에 도입되었습니다. 콜백은 비동기식 작업을 처리하는 주요 메커니즘이지만, 작업하기가 지루하거나 매우 복잡해질 수 있습니다.Promise는 콜백 및 비동기 작업 작업을 단순화하기 위해 JavaScript에서 구현되었습니다. Promise 만들기우리는 글로벌 생성자를 사용하여 Promise를 만들 수 있습니다. 1const myPromise = new Promise(); 글로벌 생성자는 두개의 인자로 콜백 함수를 사용합니다. 첫 번째 인자는 비동기 작업 결과를 성공하여 값을 캡처하는데 사용되며 두 번째 인자는 오류가 났을때 사용됩니다. 1234567const myPromise = new Promise(function(resolve, reject) &#123; if(someError) &#123; reject(new Error(someError)); &#125; else &#123; resolve(&#x27;ok&#x27;); &#125;&#125;); 그리고 앞서 말했듯이 then 메서드는 약속을 해결할 때 사용하고, 오류를 처리할때 catch 메서드를 사용 할 수 있습니다. 1234567myPromise .then(function(result) &#123; console.log(result); &#125;) .catch(function(error) &#123; console.log(error); &#125;); 모든 비동기식 작업을 promise로 처리할 수 있습니다. 예를 들어, fs.readFile메소드는 파일의 내용을 비동기 적으로 읽는 메소드입니다.fs.readFile방법은 다음과 같이 사용됩니다. 123456fs.readFile(&#x27;some-file.txt&#x27;, &#x27;utf-8&#x27;, function(error, content) &#123; if(error) &#123; return console.log(error); &#125; console.log(content);&#125;); fs.readFile로 이를 파일의 내용을 읽고, Promise를 통해 사용하거나 오류가 있는 경우 거부하는 readFile함수를 만들 수 있습니다. 123456789101112131415// code/promises/wrap-readfile1.jsconst fs = require(&#x27;fs&#x27;);function readFile(file, format) &#123; format = format || &#x27;utf-8&#x27;; function handler(resolve, reject) &#123; fs.readFile(file, format, function(err, content) &#123; if(err) &#123; return reject(err); &#125; return resolve(content); &#125;); &#125; const promise = new Promise(handler); return promise;&#125; 동일한 기능의 코드로 이처럼 간결하게 작성할 수 있습니다. 12345678910// code/promises/wrap-readfile2.jsconst fs = require(&#x27;fs&#x27;);function readFile(file, format = &#x27;utf-8&#x27;) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(file, format, (err, content) =&gt; &#123; if(err) return reject(err); resolve(content); &#125;); &#125;);&#125; 이제 함수를 호출하고 then메서드로 결과를 가져오고 catch메서드로 오류를 처리할 수 있습니다. 1234readFile(&#x27;./example.txt&#x27;) .then(content =&gt; console.log(content)) .catch(err =&gt; console.log(err)); Node8에서 소개 된 방법인 util.promisify메서드를 사용하여 더 간결하게 우리는 위의 코드를 작성할 수 있습니다 . 12345678// code/promises/promisify-example.jsconst fs = require(&#x27;fs&#x27;);const util = require(&#x27;util&#x27;);const readFile = util.promisify(fs.readFile);readFile(&#x27;./example.txt&#x27;, &#x27;utf-8&#x27;) .then(content =&gt; console.log(content)) .catch(err =&gt; console.log(err)); util.promisify메서드는 Node에서 콜백 규칙을 따르고 Promise-based 버전을 반환하는 함수를 사용합니다.당신은 이제 왜 모든 메서드를 Promise-based로 하지 않는지 궁굼해 할 수 있습니다. Promise는 콜백보다 높은 수준의 추상화이기 때문에 로우 레벨의 노드 메소드는 Promise 기반이 아닙니다.비동기식 운영을 처리하기 위해 Promise와 같은 높은 추상화가 필요한지 결정하는 것은 프로그래머에게 달려 있습니다. Promise 정적 메서드Promise 생성자는 자주 사용하는 몇가지 유용한 정적인 메소드들을 가지고 있습니다.모든 코드는 여기 code/promises/static-methods.js 스니펫이 있습니다.주목할만한 것들은 다음과 같습니다. Promise.resolve: 승인된 Promise 객체 사용 12345function getData() &#123; return Promise.resolve(&#x27;some data&#x27;);&#125;getData() .then(d =&gt; console.log(d)); Promise.reject: 거절 Promise 객체 사용 12345function rejectPromise() &#123; return Promise.reject(new Error(&#x27;something went wrong&#x27;));&#125;rejectPromise() .catch(e =&gt; console.log(e)); Promise.all: 여러개의 승인된 Promise 객체를 사용 1234567const p1 = Promise.resolve(&#x27;v1&#x27;);const p2 = Promise.resolve(&#x27;v2&#x27;);const p3 = Promise.resolve(&#x27;v3&#x27;);const all = Promise.all([p1, p2, p3]);all.then(values =&gt; console.log(values[0], values[1], values[2])); Promise.all은 Promise 객체의 배열을 무작위 순서로 평가하고, 그들 모두 해결 될때까지 “대기”합니다.배열에 있는 모든 값을 제출한 순서대로 모든 Promise객체를 반환하지만, 처리된 순서는 반환하지 않습니다. Promise.all은 순서대로 Promise를 처리하지 않고 원하는 순서대로 평가하게 된다는 것을 기억하세요. 지금까지 Promise에 대해 알아보았습니다.다음글에서 순서대로 Promise를 실행 및 좀 더 실습을 해보겠습니다. 출처이 글은 Medium의 AJ Meyghani의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://tuhbm.github.io/tags/promise/"},{"name":"resolve","slug":"resolve","permalink":"https://tuhbm.github.io/tags/resolve/"},{"name":"reject","slug":"reject","permalink":"https://tuhbm.github.io/tags/reject/"},{"name":"all","slug":"all","permalink":"https://tuhbm.github.io/tags/all/"},{"name":"method","slug":"method","permalink":"https://tuhbm.github.io/tags/method/"},{"name":"동기","slug":"동기","permalink":"https://tuhbm.github.io/tags/%EB%8F%99%EA%B8%B0/"},{"name":"비동기","slug":"비동기","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"synchronous","slug":"synchronous","permalink":"https://tuhbm.github.io/tags/synchronous/"},{"name":"asynchronous","slug":"asynchronous","permalink":"https://tuhbm.github.io/tags/asynchronous/"}]},{"title":"번역 - 비동기 자바스크립트의 간단한 참고서 1편","slug":"async01","date":"2018-11-05T21:45:03.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2018/11/05/async01/","link":"","permalink":"https://tuhbm.github.io/2018/11/05/async01/","excerpt":"비동기 자바스크립트의 간단한 참고서JavaScript로 비동기 프로그래밍 배우기 JavaScript의 비동기 특성은 많은 사람들을 혼란스럽게 할 수있는 언어 측면 중 하나입니다. 그러나 기본 비동기 구문을 잘 이해하면 언어에 대한 많은 혼란을 줄일 수 있습니다. 이 가이드의 목표는 JavaScript로 비동기 프로그래밍을 소개합니다. 그리고 깨끗하고 유지 보수가 가능한 비동기 코드를 작성하는 데 필요한 기술을 제공하는 것입니다. 동기식 및 비동기식 실행 모델과 그 차이점을 살펴 보는 것으로 시작합니다. 그런 다음 콜백 기능에 대해 자세히 알아보고 비동기 작업 결과를 캡처하는 데 어떻게 사용되는지 조사하겠습니다. 그런 다음, promise에 대해 알아보고 콜백 기능을 추상화하여 비동기 흐름을 단순화하는 방법에 대해 알아보겠습니다.또한 제너레이터를 살펴보고 비동기 흐름에 어떻게 사용할 수 있는지 알아보겠습니다. 끝으로 async 함수를 살펴보고 비동기 작업을 더욱 단순화하기 위해 promise와 함께 사용할 수있는 방법을 보여줍니다. 예제코드이 가이드의 모든 코드 예는 Gitlab에서 확인할 수 있습니다.https://gitlab.com/aj_meyghani/asyncjs-code-examples 당신은 Repository를 복제하거나 zip 파일로 다운로드 할 수 있습니다. 기타 간단한 참고서다른 간단한 참고서를 확인해보세요 JavaScript Functions JavaScript Prototypes 소개JavaScript에서 비동기 프로그래밍을 처음 접한 경우 다음 코드를 보고 놀랄 수 있습니다.","text":"비동기 자바스크립트의 간단한 참고서JavaScript로 비동기 프로그래밍 배우기 JavaScript의 비동기 특성은 많은 사람들을 혼란스럽게 할 수있는 언어 측면 중 하나입니다. 그러나 기본 비동기 구문을 잘 이해하면 언어에 대한 많은 혼란을 줄일 수 있습니다. 이 가이드의 목표는 JavaScript로 비동기 프로그래밍을 소개합니다. 그리고 깨끗하고 유지 보수가 가능한 비동기 코드를 작성하는 데 필요한 기술을 제공하는 것입니다. 동기식 및 비동기식 실행 모델과 그 차이점을 살펴 보는 것으로 시작합니다. 그런 다음 콜백 기능에 대해 자세히 알아보고 비동기 작업 결과를 캡처하는 데 어떻게 사용되는지 조사하겠습니다. 그런 다음, promise에 대해 알아보고 콜백 기능을 추상화하여 비동기 흐름을 단순화하는 방법에 대해 알아보겠습니다.또한 제너레이터를 살펴보고 비동기 흐름에 어떻게 사용할 수 있는지 알아보겠습니다. 끝으로 async 함수를 살펴보고 비동기 작업을 더욱 단순화하기 위해 promise와 함께 사용할 수있는 방법을 보여줍니다. 예제코드이 가이드의 모든 코드 예는 Gitlab에서 확인할 수 있습니다.https://gitlab.com/aj_meyghani/asyncjs-code-examples 당신은 Repository를 복제하거나 zip 파일로 다운로드 할 수 있습니다. 기타 간단한 참고서다른 간단한 참고서를 확인해보세요 JavaScript Functions JavaScript Prototypes 소개JavaScript에서 비동기 프로그래밍을 처음 접한 경우 다음 코드를 보고 놀랄 수 있습니다. 12setTimeout(() =&gt; console.log(&#x27;1&#x27;), 0);console.log(&#x27;2&#x27;); 위 코드의 출력은 무엇이라고 생각하십니까? 당신은 1과 2를 말하고 싶지만 정답은 2이고 그 다음은 1입니다.이제에서는 JavaScript에서 사용되는 비동기 모델에 대해 살펴보고 위의 코드가 2와 1을 출력되는 이유를 설명합니다. 동기 vs 비동기우리는 일상에서 작업을 할 때 비동기식으로 할 가능성이 높습니다. 실행의 동기 모델과 비동기식 모델 간의 차이를 보여 주는 비유를 살펴보겠습니다. 할 일 목록에서 할일이 3개가 있다고 가정해보겠습니다. 빨래하기 장보기 저녁밥하기 동기식 모델의 경우 다음 할일으로 이동하기 전에 각 작업을 완료해야 합니다. 즉 장보기 전에 빨래를 끝마쳐야합니다. 만약 세탁기가 고장난 경우 장보기를 할 수 없습니다. 세번째 할 일도 똑같이 적용됩니다. 장보기를 끝내야만 저녁밥을 할 수 있습니다. 비동기 모델을 사용하면 각 작업이 다음 작업으로 이동하기를 마칠 때까지 기다릴 필요가 없습니다. 세탁기를 돌리고 그동안 장보기를 할 수 있습니다. 장보기를 끝내고 돌아오면 빨래가 끝날 것입니다. 그후 옷을 말려야 한다면 건조기에 넣고 옷을 말리는 동안 저녁을 만들 수 있습니다. 이것은 기본적으로 동기식 및 비동기식 실행 모델 간의 주요 차이점입니다. 동기식 모델에서 다음 작업으로 이동하기 전에 각 작업이 완료될 때까지 기다려야 합니다. 그러나 비동기식 모델에서는 작업을 효율적으로 수행 할 수 있게 일정을 계획 세울 수 있으며, 앞선 작업이 완료 될 때까지 기다릴 필요가 없습니다. 다음으로 이벤트 루프를 살펴보고 JavaScript가 비동기 작업을 처리하는 방법을 알아봅니다. 이벤트 루프앞서 보았던 코드를 살표 보겠습니다. 12setTimeout(() =&gt; console.log(&#x27;1&#x27;), 0); //Aconsole.log(&#x27;2&#x27;); //B A 행에서 setTimeout 메소드를 호출하면 콜백 함수 () =&gt; console.log(‘1’)*가 대기열인 큐에 푸시됩니다. 앞으로 큐라고만 쓰겠습니다.그 다음, B 행에서 *console.log(2)*가 스택에 push되며, 즉시 호출되어 콘솔에 *2를 출력합니다. console.log(2)*를 호출하면 스택이 비어 있고 JavaScript가 큐로 이동하여 큐에 있는 항목을 스택으로 이동하여 실행합니다. 그 후 콜백함수인 *() =&gt; console.log(‘1’)*가 실행되어 *1이 출력됩니다. 이 흐름을 관리하는 메커니즘을 이벤트 루프라고합니다. 이벤트 루프는 스택과 큐의 항목을보고 올바른 순서로 실행을 예약하는 역할을 합니다. 아래 그림에서 실행될 스택에 세 가지 작업이 있습니다. 작업이 완료되면 큐에서 두 개의 작업(예: 콜백 기능)을 선택하고 실행할 스택에 배치됩니다. 간단한 설명하면, 이벤트 루프는 현재 실행될 수 있는 일과 나중에 실행되어야하는 일을 결정합니다. 콜백 함수비동기 컨텍스트에서 콜백 함수에 대해 이야기하기 전에 함수가 다른 함수로 전달되는 방법을 배우는 것이 중요합니다.예제를 보고 자바 스크립트의 모든 값처럼 함수를 전달하는 방법을 살펴보겠습니다. 12let name = &#x27;Tom&#x27;;hello(name); 위 코드에서 name이라는 변수를 선언하고 문자열을 할당합니다. 그런 다음 인자로 hello 함수에 전달합니다. 함수를 사용하여 똑같은 작업을 수행 할 수 있습니다. name을 함수로 정의하고 hello로 전달할 수 있습니다. 12let name = () =&gt; &#x27;Tom&#x27;;hello(name); 기술적으로 다른 함수로 전달 되었기 때문에 콜백 함수이지만, 비동기 작업의 컨텍스트에서 콜백 함수가 무엇인지 확인해 봅시다. 비동기 컨텍스트에서 콜백 함수는 비동기 작업이 완료되면 JavaScript에서 호출하는 일반적인 JavaScript 함수입니다. 일반적으로 각 Node에서 설정된 콜백 함수는 두 개의 인자를 사용합니다. 첫 번째는 오류를 캡처하고 두 번째는 결과를 캡처합니다. 콜백 함수의 이름을 지정하거나 익명으로 지정할 수도 있습니다.Node의 fs.readFile을 사용하여 파일의 내용을 비동기 적으로 읽는 방법을 보여주는 간단한 예제를 살펴 보겠습니다. 123456const fs = require(&#x27;fs&#x27;);const handleReading = (err, content) =&gt; &#123;2if(err) throw new Error(err);2return console.log(content);&#125;;fs.readFile(&#x27;./my-file.txt&#x27;, &#x27;utf-8&#x27;, handleReading); fs 모듈에는 readFile이라는 메서드가 있습니다. 이메서드는 두 개의 필수 인자가 필요합니다. 첫 번째 인자는 파일 경로이며, 마지막 인자는 콜백 함수입니다. 위의 코드에서 콜백 함수는 두 개의 인자를 취하는 handleReading입니다. 첫 번째로 잠재적 오류를 포착하고 두 번째로 내용을 캡처합니다. 다음은 원격 API 서버에 GET 요청을 보내는 https 모듈의 또 다른 예입니다. 1234567891011121314// code/callbacks/http-example.jsconst https = require(&#x27;https&#x27;);const url = &#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;;https.get(url, (response) =&gt; &#123;2response.setEncoding(&#x27;utf-8&#x27;);2let body = &#x27;&#x27;;2response.on(&#x27;data&#x27;, (d) =&gt; &#123;22body += d;2&#125;);2response.on(&#x27;end&#x27;, (x) =&gt; &#123;22console.log(body);2&#125;);&#125;); get 메소드를 호출하면 JavaScript에 의해 요청이 예약됩니다. 결과를 사용할 수 있으면 JavaScript에서 기능을 호출하여 결과를 제공합니다. 비동기 결과 “반환”비동기 작업을 수행 할 때 단순히 return명령문을 사용한다고 해서 결과값을 얻을 수는 없습니다. 비동기 호출의 결과를 가지는 함수가 있다고 가정 해 보겠습니다. 변수를 생성하고 비동기 콜백에 변수를 설정하여 값을 반환하여도 외부에서 함수의 결과를 얻을 수 없습니다. 12345678function getData(optioins) &#123;2var finalResult;2asyncTask(options, function(err, result) &#123;22finalResult = result;2&#125;);2return finalResult;&#125;getData(); // returns undefined 위 코드에서 실행해보면 getData함수가 즉시 실행되고 반환 값은 undefined가 나옵니다. 함수를 호출할때 finalResult에는 아무것도 설정되지 않았기 때문입니다. 함수가 실행이 된 후 콜백 함수가 실행되어 나중에 finalRsult값이 설정되기 때문입니다. 비동기 콜백의 값을 전달하는 방법은 외부 함수에 콜백의 값을 전달해야합니다. 1234567function getDate(options, callback) &#123;2asyncTask(options, callback);&#125;getData(&#123;&#125;, function(err, result) &#123;2if(err) return console.log(err);2return console.log(result);&#125;); 위 코드에서는 getDate의 두번째 인자로 콜백함수를 사용하도록 정의 되어있습니다. getData에서 콜백 함수를 두번째 인자로 사용한다고 callback이라는 이름을 명시하였습니다. 비동기 순서대로 수행서로 의존하는 비동기 태스크가 두 개인 경우 다른 태스크의 콜백 내에서 각 태스크를 호출해야합니다. 예를 들어 파일 내용을 복사해야하는 경우 다른 파일에 쓰기 전에 먼저 파일의 내용을 읽어야합니다. 이 때문에 콜백 writeFile내에서 readFile메서드를 호출해야합니다. 123456789101112const fs = require(&#x27;fs&#x27;);fs.redFile(&#x27;file.txt&#x27;, &#x27;utf-8&#x27;, function readContent(err, content) &#123;2if(err) &#123;22return console.log(err);2&#125;2fs.writeFile(&#x27;copy.txt&#x27;, content, function(err) &#123;22if(err) &#123;222return console.log(err);22&#125;22return console.log(&#x27;done&#x27;);2&#125;);&#125;); 서로 의존하는 많은 비동기 작업이 있으면 코드가 지저분해질 수 있습니다.(콜백지옥) 이러한 경우 혼란을 피하기 위해 각각 콜백 함수의 이름을 지정하고 별도로 정의하는 방법이 좋습니다. 12345678910111213141516const fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;file.txt&#x27;, &#x27;utf-8&#x27;, readCb);function readCb(err, content) &#123;2if(err) &#123;22return console.log(err);2&#125;2return fs.writeFile(&#x27;copy.txt&#x27;, content, writeCb);&#125;function writeCb(err) &#123;2if(err) &#123;22return console.log(err);2&#125;2return console.log(&#x27;Done&#x27;);&#125; 위 코드에서는 별도로 readCb와 writeCb로 두개의 콜백함수를 정의하였습니다. 위코드가 무조건으로 좋은코드다 라고 말할 순 없지만 여러 종속성이 있는 작업의 경우 각각의 정의된 콜백함수를 사용하면 많은 수고를 덜어 줄 수 있습니다. 연습: 간단한 콜백compute라는 두개의 조건을 부합하는 함수를 정의해보세요. 정수 배열 전달 된 배열에서 작동하는 콜백 함수 예를 들어, 다음코드는 6을 반환합니다.(addAll 함수가 정의되어 있다고 가정합니다.) 1const result = compute([1, 2, 3], addAll); 해결책가능한 해결책은 첫 번째 인자가 정수 배열인지 확인한 후 다음을 사용하여 콜백 함수를 호출하는 것입니다 args. 12345678910// code/callbacks/exercises/simple-callback.jsfunction compute(nums, fn) &#123;2if(!Array.isArray(nums)) return NaN;2const isAnyNotInteger = nums.some(v =&gt; !Number.isInteger(v));2if(isAnyNotInteger) &#123;22console.log(isAnyNotInteger)22return NaN;2&#125;2return fn(nums);&#125; 연습: 비동기 콜백 순서대로 수행이번 연습에서는 GET http호출을 통해 응답결과를 파일내용에 추가하고, 그 내용을 다른파일에서도 추가하여 사용합니다.연습은 이순서로 진행하겠습니다. 게시물의 제목을 얻기 위한 GET http 요청 파일 내용 읽기 파일 내용에 게시물 제목 추가 결과 파일에 추가 해결책이번 연습에서는 콜백을 사용하여, 작업을 수행하는 연습입니다. Promise 세션에서는 Promise를 사용하여 비동기 결과를 수집하고 동시 작업을 하는방법을 살펴보겠지만 지금은 콜백결과에 의존하여 작업을 수행하겠습니다. 123456789101112131415161718192021222324// code/callbacks/exercises/read-write/main.jsconst fs = require(&#x27;fs&#x27;);const request = require(&#x27;request&#x27;);const url = &#x27;https://jsonplaceholder.typicode.com/posts/2&#x27;;request.get(url, handleResponse);function handleResponse(err, resp, body) &#123;2if(err) throw new Error;2const post = JSON.parse(body);2const title = post.title;2fs.readFile(&#x27;./file.txt&#x27;, &#x27;utf-8&#x27;, readFile(title));&#125;const readFile = title =&gt; (err, content) =&gt; &#123;2if(err) throw new Error(err);2const result = title + content;2fs.writeFile(&#x27;./result.txt&#x27;, result , writeResult);&#125;function writeResult(err) &#123;2if(err) throw new Error(err);2console.log(&#x27;done&#x27;);&#125; 다음시간에는 Promise를 사용하여 비동기로 기능구현을 해보겠습니다. 출처이 글은 Medium의 AJ Meyghani의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"동기","slug":"동기","permalink":"https://tuhbm.github.io/tags/%EB%8F%99%EA%B8%B0/"},{"name":"비동기","slug":"비동기","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"synchronous","slug":"synchronous","permalink":"https://tuhbm.github.io/tags/synchronous/"},{"name":"asynchronous","slug":"asynchronous","permalink":"https://tuhbm.github.io/tags/asynchronous/"},{"name":"callback","slug":"callback","permalink":"https://tuhbm.github.io/tags/callback/"}]},{"title":"번역 - css의 DOM을 가운데 정렬하는 다양한 방법","slug":"cssAlignCenter","date":"2018-10-31T19:56:08.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/10/31/cssAlignCenter/","link":"","permalink":"https://tuhbm.github.io/2018/10/31/cssAlignCenter/","excerpt":"CSS에서 스타일을 중심으로 배치하는 방법 솔직하게 말해봅시다. 때때로 우리의 코딩 경력 전반에 걸쳐 우리는 CSS의 중심에 좌절감을 나타 냈습니다(Google 또는 스택 오버 플로우에서 div 내에서 div를 가운데에 배치하는 방법을 찾는 방법).이 작업은 가장 간단한 작업 중 하나일 수 있지만 페이지에 더 많은 요소와 스타일을 추가하면 빠르게 혼란이 올 수 있습니다.이것이 꽤 흔한 문제이기 때문에, 저는 이 가이드에서 CSS를 중심으로 하는 방법을 정리했습니다.또한 CodePen에서 만든 각 예제와 함께 코드/링크도 포함했습니다. 원한다면 마음대로 포크, 공유 또는 복사하세요! 여기에서 저의 CodePen을 보세요. 더 이상 고민 말고, 그것에 대해 이야기합시다!","text":"CSS에서 스타일을 중심으로 배치하는 방법 솔직하게 말해봅시다. 때때로 우리의 코딩 경력 전반에 걸쳐 우리는 CSS의 중심에 좌절감을 나타 냈습니다(Google 또는 스택 오버 플로우에서 div 내에서 div를 가운데에 배치하는 방법을 찾는 방법).이 작업은 가장 간단한 작업 중 하나일 수 있지만 페이지에 더 많은 요소와 스타일을 추가하면 빠르게 혼란이 올 수 있습니다.이것이 꽤 흔한 문제이기 때문에, 저는 이 가이드에서 CSS를 중심으로 하는 방법을 정리했습니다.또한 CodePen에서 만든 각 예제와 함께 코드/링크도 포함했습니다. 원한다면 마음대로 포크, 공유 또는 복사하세요! 여기에서 저의 CodePen을 보세요. 더 이상 고민 말고, 그것에 대해 이야기합시다! Codepen예제 Text-Align 사용text-align: Center를 사용하는 방법은 가운데 정렬 방법 중에서 가장 일반적인 방법입니다. 주로 HTML 페이지의 텍스트를 중앙에 배치하기 위해 사용되지만, div을 중앙에 배치하기 위해서도 사용할 수 있습니다. 이 방법의 특징 : div 요소를 부모 요소(일반적으로 wraper 또는 container라고도 함)와 가운데 맞추려는 내용으로 묶습니다. 부모 요소에 text-align: center설정 그런 다음 내부 div를 display: inline-block으로 설정합니다. 예제(codepen)에서 파란색 사각형 예제에서 상위에 “blue-square-container”라는 클래스의 부모 div로 묶습니다. 파란색 사각형을 중앙에 배치하려면 상위 요소를 만들고 파란색 사각형을 인라인 블록으로 설정해야 했습니다. 이는 기본적으로 div의 표시 속성이 블록으로 설정되어 있기 때문에 페이지의 전체 너비에 적용된다는 의미입니다. 파란색 사각형의 display 속성을 inline-block으로 지정하면 width(100px)가 파란색 사각형에만 적용 됩니다. 상위 요소 내에 display 속성이 inline-block인 여러 하위 요소(이 예에서는 파란색 사각형)를 추가하면 모든 요소가 중앙에 배치됩니다. Margin Auto 사용중앙정렬의 또 다른 일반적인 방법은 margin: auto 를 사용하는 것입니다. 이 방법을 사용하면 부모 요소가 필요하지 않습니다.넓이가 정해진 노란색 상자에 margin: 0 auto를 적용하기만 하면 됩니다.margin: 0 auto는 위쪽 여백과 아래쪽 여백을 0으로 설정하고 왼쪽 여백과 오른쪽 여백을 자동으로 설정하는 것을 의미합니다.100px 너비를 정의하지 않으면 브라우저가 노란색 상자를 가운데에 맞추는 데 필요한 왼쪽 및 오른쪽 여백을 렌더링 할 수 없으므로 중요합니다.너비를 설정하면 브라우저가 노란색 상자의 양쪽에 여백을 자동으로 계산합니다.“0” 부분은 위쪽 및 아래쪽 여백에 대해 설정할 수 있습니다. 또 다른 재밋는 방법은 margin을 왼쪽은 auto로 설정하는 방법입니다.그러면 div를 페이지의 오른쪽 또는 왼쪽으로 밀어 넣을 수 있습니다(시도해보세요).예제: margin: 0 auto 0 0 Absolute Positioning 사용요소를 position을 absolute를 설정하면 기본적으로 페이지에 원하는 요소의 위치를 배치 할 수 있습니다. 그러나 한 가지 단점이 있습니다.position: absolute는 페이지에서 element의 flow을 제거합니다.(element의 배치 flow) 왜 이것이 중요할까요? 요소를 잘못 사용하면 요소가 겹칠 수 있으므로 중요합니다. 처음 두 가지 방법으로 했던 것처럼 요소를 페이지에 수평으로 놓으려면 다음 세 가지를 기억해야 합니다. 요소의 position 속성을 absolute로 설정합니다. 요소에 *left: 50 %*를 적용합니다. 마이너스하세요. 요소 너비의 절반만큼 margin-left을 설정 margin-left: -50px 이 예에서 우리는 녹색 사각형을 사용합니다. 다른 예제와 같은 크기이므로 너비는 100px입니다. “position : absolute”를 입력하고 “left : 50 %”를 녹색 사각형에 적용했습니다. 그러면 브라우저에서 왼쪽 가장자리를 오른쪽으로 50 % 이동합니다. 그러나 현재상태에선 녹색 사각형의 왼쪽 가장자리가 중간에 오는것이 아니라 녹색 사각형 가운데가 페이지 가운데에 오도록하고 싶습니다. 우리를 마지막 단계로 margin의 공간을 없애기 위해, 우리는 녹색 사각형의 너비의 절반 왼쪽 여백을 마이너스로 적용합니다.이번 예제는 -50px입니다. Transform/Translate 사용Codepen 예제 지금까지는 DOM을 수평으로 배치하는 것만 초점을 맞추었지만, 페이지 중앙에 뭔가를 넣고 싶다면 어떻게해야할까요?이번 예제인 빨간색 사각형은 가로와 세로 모두 중앙에 배치합니다. 이 방법에서도 *position: absolute”와 “left: 50 %”를 사용하지만 요소에 두 개의 속성을 추가로 적용했습니다. top 속성을 *50%*로 설정함으로써, 브라우저 중앙에 빨간색 사각형의 위쪽 가장자리를 수직으로 정렬합니다. 하지만 앞의 예에서와 같이, 가장자리들이 중앙에 정렬되는 것을 원치 않습니다. 우리는 사각형의 중심이 페이지 중앙에 맞추기를 원합니다. 여기서 우리는 transform이라는 새로운 속성을 적용합니다. transform에는 translating(변환), rotate(회전), scaling(크기조정) 애니메이션 같은 많은 멋진 것들이 있습니다.하지만 이 예제에서는translate을 사용할 것입니다. transform 속성을 *transform: translate (-50%, -50%)*으로 작성합니다. 우리의 빨간 사각형은 가로와 세로 모두 중앙에 위치 했습니다! 저는 이 방법이 마음에 듭니다. 요소의 폭이나 높이에 상관없이 항상 페이지 중앙에 있기 때문입니다. 이 방법은 반응형 설계에 자주 사용되며, position:absolute 방법처럼 여백이 정의될 필요가 없습니다. Flexbox 방법Codepen 예제 Flexbox에 익숙하지 않아도 괜찮습니다!Flexbox는 페이지에 요소를 정렬하고, 배치하는 효율적인 방법을 제공하는 레이아웃 속성입니다. Flexbox 학습에 관심이 있다면 Flexbox Froggy(매우 권장)는 재미 있고 배우기 쉬운 방법입니다.p.s 물론 Flexbox를 배우는 데 사용 된 것입니다.^^ Flexbox를 사용하여 수평 및 수직을 중앙에 정렬하는 네 가지 단계는 다음과 같습니다. HTML, body 및 부모 컨테이너의 높이가 100%이어야합니다. 부모 컨테이너에서 display를 flex로 설정 부모 컨테이너에 align-items: center 설정 부모 컨테이너에 * justify-content: center* 설정 부모에서 display를 flex로 설정하면 플렉스 컨테이너로 정의됩니다. align-items을 center로 설정하면 children 또는 flex 항목을 부모 내에서 세로 중앙에 배치됩니다.Justify-content는 같은 방식으로 작동하지만 예제의 경우 가로 방향으로 작동합니다. 저는 반응형작업에도 좋고 여백 계산도 필요 없기 때문에 이 방법을 사용하는 것을 좋아합니다. 이 게시물이 유익하고 도움이 되었기를 바랍니다.당신의 의견을 듣고 싶습니다! 읽어 주셔서 감사합니다! :) 출처이 글은 Medium의 Stephen Sun의 포스팅 글을 번역한 것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"}],"tags":[{"name":"align center","slug":"align-center","permalink":"https://tuhbm.github.io/tags/align-center/"},{"name":"absolute","slug":"absolute","permalink":"https://tuhbm.github.io/tags/absolute/"},{"name":"flex","slug":"flex","permalink":"https://tuhbm.github.io/tags/flex/"},{"name":"transform","slug":"transform","permalink":"https://tuhbm.github.io/tags/transform/"},{"name":"translate","slug":"translate","permalink":"https://tuhbm.github.io/tags/translate/"}]},{"title":"번역 - Vue 2 + Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 5편","slug":"vue-firebase5","date":"2018-10-30T20:06:19.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2018/10/30/vue-firebase5/","link":"","permalink":"https://tuhbm.github.io/2018/10/30/vue-firebase5/","excerpt":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.3편에선 vue-router를 사용해 컴포넌트간 이동을 진행해보았습니다.4편에서는 firebase를 연결하고 회원가입&amp;로그인을 진행해 보겠습니다. 마지막으로 firebase에 가입된 데이터에 인증을 통해 페이지 접속이 가능하도록 해보겠습니다. 스텝4 인증 후 앱 접속4.1 router에 meta 추가이제 인증을 받았습니다! 하지만 아무 일도 일어나지 않습니다. 사용자를 인증 한 경우에만 응용 프로그램으로 접근 가능하도록 사용자를 리다이렉션시켜야합니다. 우리는 앱에서 인증 후 이동 될 컴포넌트가 Hello 컴포넌트라고 정의 하였습니다. Vue 애플리케이션에서 이를 구현하기 위해 vue-router의 메타 필드를 사용할 수 있습니다. 메타 필드는 경로에 설정할 수있는 추가 정보입니다. 메타에 대한 자세한 내용을 보려면 여기에서 vue-router 설명서를 확인하십시오.https://router.vuejs.org/en/advanced/meta.html 이 예제에서 사용할 Hello 뷰에 메타 필드를 추가해 보겠습니다.이 메타는 requiresAuth라고하며 Hello 컴포넌트에 인증이 필요함을 알립니다. 모든 컴포넌트에 경로가 존재하며, 기본 디폴트 페이지의 앱 기본경로를 재정의해야합니다.","text":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.3편에선 vue-router를 사용해 컴포넌트간 이동을 진행해보았습니다.4편에서는 firebase를 연결하고 회원가입&amp;로그인을 진행해 보겠습니다. 마지막으로 firebase에 가입된 데이터에 인증을 통해 페이지 접속이 가능하도록 해보겠습니다. 스텝4 인증 후 앱 접속4.1 router에 meta 추가이제 인증을 받았습니다! 하지만 아무 일도 일어나지 않습니다. 사용자를 인증 한 경우에만 응용 프로그램으로 접근 가능하도록 사용자를 리다이렉션시켜야합니다. 우리는 앱에서 인증 후 이동 될 컴포넌트가 Hello 컴포넌트라고 정의 하였습니다. Vue 애플리케이션에서 이를 구현하기 위해 vue-router의 메타 필드를 사용할 수 있습니다. 메타 필드는 경로에 설정할 수있는 추가 정보입니다. 메타에 대한 자세한 내용을 보려면 여기에서 vue-router 설명서를 확인하십시오.https://router.vuejs.org/en/advanced/meta.html 이 예제에서 사용할 Hello 뷰에 메타 필드를 추가해 보겠습니다.이 메타는 requiresAuth라고하며 Hello 컴포넌트에 인증이 필요함을 알립니다. 모든 컴포넌트에 경로가 존재하며, 기본 디폴트 페이지의 앱 기본경로를 재정의해야합니다. __path : ‘*’__를 사용하여 존재하지 않는 모든 경로를 로그인 컴포넌트로 리다이렉션합니다.사용자가 인증 된 경우 사용자가 로그인하면 로그인 페이지에 접근 없이 자동으로 Hello 컴포넌트로 리다이렉션됩니다.이제 잘못된 URL을 입력하면 로그인 컴포넌트로 리다이렉션되는 것을 볼 수 있습니다. 4.2 사용자 인증 시 경로 재연결이제 모든 준비가 되었으므로 사용자가 Firebase에서 인증되었는지 확인해야 합니다.Firebase는 현재 사용자를 찾기 위한 함수를 제공합니다 : firebase.auth (). currentUser 이 함수는 currentUser 속성을 사용하여 현재 로그인 한 사용자를 다시 보냅니다. 사용자가 로그인하지 않은 경우 currentUser의 값은 null입니다. 앞 부분에서는 메타 필드를 경로에 설정하여 어떤 컴포넌트에 인증에 필요한지를 알 수 있습니다.이제 각 컴포넌트에 접속하기 전에 사용자가 인증되었는지, 접속하려는 컴포넌트에 인증이 필요한지 확인해야 합니다. 그렇게하기 위해 우리는 vue-router의 네비게이션 가드를 사용할 것입니다. 1234567네비게이션 가드이름에서 알 수 있듯이 vue-router가 제공하는 네비게이션 가드는 주로 리다이렉트나 취소하여 vue-router를 보호하는 데 사용됩니다.경로 탐색 프로세스에 연결하는 방법에는 globally, per-route, or in-component(전역, 경로 별 또는 구성 요소)가 있습니다.vue-router 설명서&lt;https://router.vuejs.org/en/advanced/navigation-guards.html&gt; 이 예에서는 global navigation guard인 beforeEach를 사용하려고합니다. src/router/index.js 파일에서 구현하겠습니다. beforeEach 함수는 to, from 및 next의 세 매개 변수를 사용하며 탐색이 실행 될 때마다 호출됩니다. to 매개 변수는 탐색중인 대상 Route 객체입니다.from 매개 변수는 탐색되는 현재 경로입니다.next 매개 변수는 다음 이동을 하기 위해 호출해야하는 함수이며, 탐색을 리다이렉션하거나 중단하기위한 argument를 사용할 수 있습니다.자세한 내용은 설명서 참조. beforeEach 함수에서 Firebase의 currentUser를 다시 얻고, 우리가 이동하고자하는 라우트에 requireAuth meta가 있는지 확인하여 인증이 필요한지 확인합니다. requiresAuth 메타를 다시 얻는 방법을 이해하려면 먼저 라우트 구성의 각 라우트 오브젝트를 라우트 레코드라고 부른다.이 튜토리얼에서는 중첩 된 경로가 없지만 경로 레코드는 중첩 될 수 있습니다. 따라서 경로가 일치하면 두 개 이상의 경로 레코드와 잠재적으로 일치 할 수 있습니다. 경로와 일치하는 모든 경로 레코드는 $route 객체(네비게이션 가드의 객체 경로)에 $route.matched Array로 표시됩니다. 따라서 $route.matched를 반복하여 경로 레코드의 메타 필드를 확인해야합니다. 그래서, 우리의 네비게이션 가드 전역 함수에서, to 객체를 라우팅하기 위해서, matched Array가 requiresAuth 메타와 함께 몇개의 레코드 (우리의 경우 하나의 레코드)를 가지고 있는지 검색합니다. 그런 다음 네비게이션 규칙을 정의했습니다. 탐색 경로에 인증이 필요하고 현재 로그인 한 사용자가없는 경우 로그인 컴포넌트로 리다이렉션됩니다. 로그인 한 사용자가있어서 탐색 경로가 인증을 필요로하지 않는 경우 우리는 Hello 컴포넌트로 리디렉션합니다. 그렇지 않으면, 우리는 탐색을 진행합니다. 이제 사용자가 인증 된 경우에만 앱에 접근 할 수 있습니다. 이전 단계에서 이미 로그인 했으므로 네비게이션 가드 구현을 기반으로 페이지를 다시로드하는 경우 Hello 컴포넌트로 리다이렉션해야합니다. 페이지를 다시로드 해 봅시다. 아무것도 일어나지 않습니다. 여전히 로그인 컴포넌트가 보여지고 있습니다. 왜 그럴까요….? 간단히 말하면 우리 앱의 라이프 사이클의 네비게이션 가드 beforeEach은 Firebase 초기화가 끝나기 전 실행됩니다. 그래서 우리가 처음 앱을로드 할 때, Firebase 모듈의 초기화가 완료하지 않았기 때문에 firebase.auth (). currentUser가 null을 반환합니다. 첫 번째로드 이후에 SingUp 컴포넌트로 이동하려고하면 리다이렉션이 발생하고 Hello컴포넌트로 끝납니다. 이러한 상황을 피하고 리다이렉션이 앱의 첫 번째로드에서 직접 발생하는지 확인하려면 어떻게 해야할까요? Firebase를 사용하면 Auth 객체에 관찰자를 설정할 수 있습니다. 따라서 현재 사용자를 얻을 때 Auth 객체가 초기화 등의 중간 상태에 있지 않도록 할 수 있습니다. 이 관찰자를 OnAuthStateChanged라고 합니다.(관찰자에 대한 자세한 내용은 Firebase 설명서에서 확인할 수 있습니다.)https://firebase.google.com/docs/auth/web/manage-users#get_a_users_profile 따라서 OnAuthStateChanged 관찰자에 콜백을 설정하여 Firebase가 초기화되었음을 확인할 때만 Vue 앱을 초기화할 수 있습니다. src/main.js 파일을 다음과 같이 변경합니다. 이제 Firebase Auth 객체를 사용할 준비가 된 경우에만 앱을 초기화합니다. 페이지를 새로 고치거나 url에서 로그인 또는 SignUp 컴포넌트로 접근하려고하면 리다이렉션이 작동하는 것을 볼 수 있습니다! 4.3 Login/SignUp 앱에서 로그 아웃 한 후 리다이렉션이제 인증 시스템이 생겼으므로 로그인 후에 또는 새로운 사용자가 생겼을 때에도 사용자를 리다이렉션해야합니다.또한 Firebase에서 로그아웃도 할 수 있어야합니다. 로그아웃하려면 Hello 컴포넌트에 버튼을 추가하고 Firebase에서 로그아웃 할 이벤트를 추가해야합니다. signInWithEmailAndPassword와 createUserWithEmailAndPassword와 같이 Firebase는 Promise이라는 을 반환하는 singOut기능을 제공합니다.SignOut 기능이 실행되면 앱이 로그인 컴포넌트로 리디렉션됩니다. 이제 logOut버튼을 클릭하면 Firebase에서 로그아웃 한 다음 _Login_컴포넌트로 돌아갑니다.Firebase에서 로그 아웃했는지 확인하기 위해 페이지를 새로고침을 하거나 Hello컴포넌트에 접근가능합니다. 이제 로그인을 다시 시작하겠습니다.로그인하기 전에 앱의 인증 부분으로 리다이렉션 할 수 있도록 코드를 변경해 보겠습니다. 이제 로그인을 시도하면 Hello 컴포넌트로 리다이렉션되어야합니다. SignUp 컴포넌트도 수정해보겠습니다.이제 새 계정을 만든 후에 사용자는 Hello컴포넌트로 리다이렉션됩니다. 여러분은 signInWithEmailAndPassword, createUserWithEmailAndPassword 및 signOut에서 콜백 함수를 ES6 화살표 함수로 바꾸 었다는 사실을 알아 차렸나요?왜 변경했을까요? 간단하게 메소드 정의 (function name () {})*은 자기 자신이 컨텍스트를 가지고 있기 때문입니다.메소드 정의를 사용했다면 콜백 내의 *this.$router에 접근 할 수 없습니다.부모 메소드가 객체를 변수에 캡슐화하여 액세스해야합니다. ES6 화살표 함수를 사용하면 * this *는 어휘 적이므로이 컨텍스트를 자체적으로 만들지 않습니다.대신,this는 둘러싼 맥락에서 본래의 의미를 가지고 있습니다. ES6 화살표 함수를 사용하면this. $ router에 접근하여 리다이렉션을 할 수 있습니다. 마치면서이제 Firebase 인증 시스템을 사용하는 작은 Vue 앱이 생겼습니다!모든 출처는 Github : github.com/CaptainYouz/vue-firebase-tutorial에서 확인할 수 있습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue-router","slug":"vue-router","permalink":"https://tuhbm.github.io/tags/vue-router/"},{"name":"router-link","slug":"router-link","permalink":"https://tuhbm.github.io/tags/router-link/"}]},{"title":"번역 - Vue 2 + Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 4편","slug":"vue-firebase4","date":"2018-10-22T22:01:25.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2018/10/22/vue-firebase4/","link":"","permalink":"https://tuhbm.github.io/2018/10/22/vue-firebase4/","excerpt":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.3편에선 vue-router를 사용해 컴포넌트간 이동을 진행해보았습니다. 이번편에서는 firebase를 연결하고 회원가입&amp;로그인을 진행해 보겠습니다. 스텝3 firebase 사용우리의 프론트 엔드 애플리케이션을 준비가 되었습니다. 인증 시스템을 사용할 수 있도록 Firebase를 구현합시다! 3.1 Firebase에서 새로운 프로젝트 만들기Firebase를 사용하려면, 먼저 firebase 콘솔에 새로운 프로젝트를 생성해야합니다.가입된 계정이 없으면 계정을 만든 다음으로 이동하십시오.&lt;console.firebase.google.com&gt; Add project - 프로젝트추가 를 클릭하세요. 새 프로젝트를 만드는 팝업이 활성화됩니다.그리고 원하는 이름을 정하세요. 나는 vue-firebase-tutorial 라고 정했습니다.","text":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.3편에선 vue-router를 사용해 컴포넌트간 이동을 진행해보았습니다. 이번편에서는 firebase를 연결하고 회원가입&amp;로그인을 진행해 보겠습니다. 스텝3 firebase 사용우리의 프론트 엔드 애플리케이션을 준비가 되었습니다. 인증 시스템을 사용할 수 있도록 Firebase를 구현합시다! 3.1 Firebase에서 새로운 프로젝트 만들기Firebase를 사용하려면, 먼저 firebase 콘솔에 새로운 프로젝트를 생성해야합니다.가입된 계정이 없으면 계정을 만든 다음으로 이동하십시오.&lt;console.firebase.google.com&gt; Add project - 프로젝트추가 를 클릭하세요. 새 프로젝트를 만드는 팝업이 활성화됩니다.그리고 원하는 이름을 정하세요. 나는 vue-firebase-tutorial 라고 정했습니다. 그후 프로젝트의 콘솔 페이지에 접속합니다. 축하합니다! 당신의 Firebase 프로젝트가 생성되었습니다.이제 우리의 프로그램에 그것을 적용하려면 웹 어플리케이션에 Firebase 추가를 클릭하세요. 웹의 아이콘을 클릭하면 코드 스니펫이있는 팝업이 나타납니다. 두번째 script 내부의 코드를 복사합니다.다음과 같은 코드입니다. 123456789let config = &#123; apiKey: &quot;YOUR_API_KEY&quot;, authDomain: &quot;YOUR_PROJECT_ID.firebaseapp.com&quot;, databaseURL: &quot;https://YOUR_PROJECT_ID.firebaseio.com&quot;, projectId: &quot;YOUR_PROJECT_ID&quot;, storageBucket: &quot;YOUR_PROJECT_ID.appspot.com&quot;, messagingSenderId: &quot;YOUR_MESSAGING_SEND_ID&quot;&#125;;firebase.initializeApp(config); 이제 vue 프로젝트로 돌아가 보겠습니다. Firebase 모듈을 프로젝트에 추가해야합니다.다음과 같이 터미널에 코드를 작성하여 추가합니다. 1$ npm install ——save firebase 설치가 끝나면 Firebase 모듈을 앱의 모듈로 추가하겠습니다. main.js 파일을 열고 앞서 복사 한 설정 코드로 Firebase를 초기화하겠습니다. 튜토리얼의 단순성을 위해, Firebase 구성을 main.js 파일에 넣었지만, 실무에서는 특정파일에 구성합니다. Firebase에서 가입신청을 받을 준비가되었습니다! 3.2 SignUp 컴포넌트에서 Firebase에 사용자 생성SignUp 컴포넌트에서 Firebase에서 사용자를 생성하는 데 필요한 것을 구현합시다.새로운 사용자를 만들려면 컴포넌트에 입력폼에서 email과 password를 받아야합니다.이를 위해 Vue2의 v-model 지시문을 사용합니다. 1234v-model 지정 문을 사용하여 입력양식 및 텍스트 영역 요소에 양방향 데이터 바인딩을 만들 수 있습니다. input type에 따라 요소를 업데이트하는 올바른 방법을 자동으로 선택합니다. 놀랍게도, v-model은 기본적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하기 위해 사람이 이해 하고 표현하기 쉽게 디자인된 프로그래밍 언어 문법입니다. 하지만 몇 가지 주요 사례 경우에는 특별한 주의하셔야합니다.Vue2 문서:&lt;https://vuejs.org/v2/guide/forms.html&gt; 생성하려는 새 사용자의 전자 메일과 암호를 검색한 후 createUserWithEmailAndPassword라는 Firebase 기능을 사용할 것입니다.이 Firebase 기능은 이름이 말하는 것과 똑같은 일을합니다. 전자 메일과 암호로 새로운 사용자를 만듭니다. Firebase 공식 문서에서이 함수에 대해 더 많이 알 수 있습니다.https://firebase.google.com/docs/reference/js/firebase.auth.Auth#createUserWithEmailAndPassword SignUp 컴포넌트에 모든 것을 추가합시다. createUserWithEmailAndPassword 함수는 onResolve 및 onReject 콜백과 함께 Firebase의 Promise를 반환합니다.https://firebase.google.com/docs/reference/js/firebase.Promise 일단 우리는 기능의 결과를 경고창으로 표시해보겠습니다. 이제 유저를 생성해보겠습니다. 제대로 작동하지 않는 이유는 무엇일까요? 에러 메시지를 살펴보겠습니다. 1234The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.(해당 로그인 공급자는이 Firebase 프로젝트에 대해 비활성화되어 있습니다. Auth섹션의 로그인 방법 탭에서 Firebase 콘솔에서 활성화하십시오.) 새로운 사용자를 생성 할 수있게하려면 Firebase의 로그인 공급자를 활성화해야합니다.3.1 단계에서 생성 한 프로젝트의 Firebase 콘솔로 돌아가 봅시다. Authentication - 인증 부분에는 SIGN-IN METHOD라는 탭이 있습니다. 이렇게 이메일/비밀번호 공급자를 활성화하면됩니다. 이제 다시 vue앱에서 사용자 가입을 해보겠습니다. 정상 가입이 되었습니다. 축하합니다. 지금 당신의 Firebase프로젝트에 새로운 사용자를 등록했습니다. 가입완료를 정확하게 확인하기 위해 firebase 콘솔에서 Authentication 부분을 살펴보고 사용자 목록을 볼 수 있습니다.방금 만든 사용자가 목록에 있어야합니다. 3.3 새로운 사용자와의 로그인이제 새로운 사용자를 만들었으므로이 사용자로 로그인 해 봅시다!(Firebase에 새로운 사용자를 성공적으로 만들면 자동으로 사용자가 응용 프로그램에 로그인하지만,이 예에서는 로그인보기에서 다시 로그인하게됩니다.) Login 컴포넌트로 이동해봅시다. 로그인을 시도한 사용자의 이메일과 비밀번호를 다시 받아서이 사용자를 Firebase에 로그인해야합니다.이 컴포넌트는 SignUp 컴포넌트처럼 보이지만 변경 사항은 우리가 호출 할 함수입니다. Firebase에서 사용자를 로그인하려면 Firebase에서 제공하는 signInWithEmailAndPassword 함수를 사용합니다. 이메일과 암호를 매개 변수로 사용하고 Firebase의 Promise를 반환합니다. 이제 새로 가입한 유저정보로 로그인해보겠습니다. 로그인 성공! 이제 이 사용자는 Firebase에서 인증된 사용자입니다! 지금까지 firebase 사용 및 User 가입 &amp; 로그인을 해보았습니다.다음 포스팅에서는 마지막으로 firebase의 인증기능을 통해 이번 주제를 마무리해보도록 하겠습니다. 출처해당 글은 medium에 Anas Mammeri의 포스팅 글을 번역한것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue-router","slug":"vue-router","permalink":"https://tuhbm.github.io/tags/vue-router/"},{"name":"router-link","slug":"router-link","permalink":"https://tuhbm.github.io/tags/router-link/"}]},{"title":"번역 - Vue 2 + Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 3편","slug":"vue-firebase3","date":"2018-10-20T14:20:32.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2018/10/20/vue-firebase3/","link":"","permalink":"https://tuhbm.github.io/2018/10/20/vue-firebase3/","excerpt":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.이제 vue-router를 사용해 컴포넌트간 이동을 진행해보도록 하겠습니다. 스텝2 컴포넌트에서 컴포넌트의 이동우리가 정의한 앱 구조를 살펴보면 Login 컴포넌트에서 SignUp컴포넌트로 이동하고 두 컴포넌트에서 Hello 컴포넌트로 이동할 수 있습니다.어떻게 해야할까요? 우리는 router-link라는 vue-router 구성 요소를 사용할 것입니다. 12345678910&lt;router-link&gt;는 라우터를 사용하는 앱에서 사용자가 이동하기 위한 구성 요소입니다. 목표 위치는 to라는 prop으로 지정됩니다.기본적으로 올바른 href로 &lt;a&gt; 태그로 렌더링되지만 tag의 prop으로 구성할 수 있습니다.&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt;또한 대상 경로가 활성화되어 있으면 링크가 자동으로 활성화된 CSS 클래스를 가져옵니다.vue-router 설명서&lt;https://router.vuejs.org/en/api/router-link.html&gt;","text":"지난 앞선 포스팅에서 1편에서는 기본 이론을 알고,2편에선 컴포넌트를 각각 구성해보고, vue-router에 대한 이론을 알아보았습니다.이제 vue-router를 사용해 컴포넌트간 이동을 진행해보도록 하겠습니다. 스텝2 컴포넌트에서 컴포넌트의 이동우리가 정의한 앱 구조를 살펴보면 Login 컴포넌트에서 SignUp컴포넌트로 이동하고 두 컴포넌트에서 Hello 컴포넌트로 이동할 수 있습니다.어떻게 해야할까요? 우리는 router-link라는 vue-router 구성 요소를 사용할 것입니다. 12345678910&lt;router-link&gt;는 라우터를 사용하는 앱에서 사용자가 이동하기 위한 구성 요소입니다. 목표 위치는 to라는 prop으로 지정됩니다.기본적으로 올바른 href로 &lt;a&gt; 태그로 렌더링되지만 tag의 prop으로 구성할 수 있습니다.&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt;또한 대상 경로가 활성화되어 있으면 링크가 자동으로 활성화된 CSS 클래스를 가져옵니다.vue-router 설명서&lt;https://router.vuejs.org/en/api/router-link.html&gt; 이제 Login 및 SignUp 컴포넌에서 router-link를 사용하여 두 가지 컴포넌트끼리 이동 할 수 구현 하겠습니다. 이제 방금 만든 링크를 사용하여 두 컴포넌트 사이를 이동 할 수 있습니다. 마지막으로 Login/SignUp 컴포넌트에서 Hello컴포넌트로 이동시켜야합니다.현재 구현된 코드가 없으므로, 인증확인 확인 없이 Connection 버튼을 클릭할 때 Hello 컴포넌로 간단히 리다이렉션 시킬 것입니다. 라우터 링크를 사용하면 구성 요소의 html부분에서 이동을 위한 값을 탐색이 이루어집니다.그러나 우리는 계획에따라 경로를 이용하려 합니다.이렇게 하기위해선 Connection 버튼을 클릭할때 vue.js의 v-on메소드를 통해 이벤트를 바인딩하여 처리 할 수 있습니다. 123456이벤트 바인딩우리는 v-on 지시문을 사용하여 DOM 이벤트를 수신하고, 호출하였을때 JavaScript를 실행할 수 있습니다.Vue2 문서: &lt;https://vuejs.org/v2/guide/events.html#Listening-to-Events&gt; 우리는 이벤트를 바인딩하고 클릭하여 실행합니다. 지금은 Connection 버튼을 클릭하여 이벤트가 발생해서 Hello 컴포넌트로 이동합니다. 각 컴포넌트 사이를 프로그래밍 방식으로 이동하려면 vue-router에는 앱에서 사용할 수 있는 메소드들이 있습니다.이러한 메소드에 대한 자세한 내용은 vue-router의 설명서를 참조하세요.https://router.vuejs.org/en/essentials/navigation.html 이 예제에서는 사용자가 로그인하면 Hello 컴포넌트를 시작 경로로 사용하기 때문에 replace 메소드를 사용하려고합니다. 로그인 컴포넌트를 변경하여 구현해 보겠습니다. 우리는 login 함수안에 *this.$router.replace(‘hello’) 가 있는 것을 볼 수 있습니다. 왜 우리는 router에 접근할때 this 를 함께 사용할까요? main.js 파일을 살펴보면, router객체가 Vue 앱에 삽입되어있는 것을 알 수 있습니다.이러한 방법은 우리가 어플리케이션의 모든 컴포넌트를 쉽게 접근 할 수 있는 방법입니다. 또한 우리는 ‘hello’ 로 접근하지만 아직 hello에 대한 경로가 없습니다. Hello 컴포넌트의 ‘/‘ 라는 기본 경로는 앱을 실행시켰을 때에 접속합니다.사용자가 인증을 완료한 후 Hello 컴포넌트에 접근해야 하므로 /hello 경로에 접근했을 할 때 Hello 컴포넌트에 접근 할 수 있도록 경로를 추가해야 합니다. 이제 Login 컴포넌트에서 연결 버튼을 클릭하면 Hello 컴포넌트로 리디렉션됩니다. 지금까지 router-link를 통해 컴포넌트에서의 이동 및 이벤트를 작성해서 실행해 보았습니다.다음 포스팅에서는 firebase를 실습해보도록 하겠습니다. 출처해당 글은 medium에 Anas Mammeri의 포스팅 글을 번역한것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"컴포넌트","slug":"컴포넌트","permalink":"https://tuhbm.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue-router","slug":"vue-router","permalink":"https://tuhbm.github.io/tags/vue-router/"},{"name":"to","slug":"to","permalink":"https://tuhbm.github.io/tags/to/"},{"name":"compontent","slug":"compontent","permalink":"https://tuhbm.github.io/tags/compontent/"},{"name":"router-link","slug":"router-link","permalink":"https://tuhbm.github.io/tags/router-link/"}]},{"title":"번역 - Vue 2 + Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 2편","slug":"vue-firebase2","date":"2018-10-20T14:20:24.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2018/10/20/vue-firebase2/","link":"","permalink":"https://tuhbm.github.io/2018/10/20/vue-firebase2/","excerpt":"코드 작성하기!지난 포스팅에서 우리는 vue에 대해 알아보고 실습을 위한 이론 및 프로젝트를 생성해 보았습니다.이번시간에는 코드를 작성하면서 vue-router 실습을 진행해 보겠습니다. 우리의 미래 App 아키텍처우리의 APP은 인증없이 접근 할 수 있는 2개의 View(로그인보기 및 가입보기)와 인증을 통해서만 접근 할 수 있는 1개의 뷰 View (Hello보기)로 총 3개의 View로 구성됩니다. 로그인이 성공적으로 완료되거나 새 계정을 만든 후에는 앱의 인증 된 부분 Hello의 View로 리다이렉션됩니다. 스텝1. 로그인과 회원가입1-1 로그인 ViewLogin 컴포넌트를 만들어봅시다. src / components 아래에 Login이라는 새로운 Vue 구성 요소를 만듭니다. 일단 컴포넌트는 단순히 제목, 두 개의 input 필드, 버튼 그리고 간단한 문장으로 구성됩니다. 이제 컴포넌트가 생성되었습니다! 하지만이 새로운 컴포넌트를 우리 앱에 어떻게 보여 줄 수 있을까요?음… 우리는 vue-router를 사용할것입니다. 기억하시나요? 우리는 Vue-cli로 앱을 초기 구성할때 이미 vue-router를 설치했습니다.","text":"코드 작성하기!지난 포스팅에서 우리는 vue에 대해 알아보고 실습을 위한 이론 및 프로젝트를 생성해 보았습니다.이번시간에는 코드를 작성하면서 vue-router 실습을 진행해 보겠습니다. 우리의 미래 App 아키텍처우리의 APP은 인증없이 접근 할 수 있는 2개의 View(로그인보기 및 가입보기)와 인증을 통해서만 접근 할 수 있는 1개의 뷰 View (Hello보기)로 총 3개의 View로 구성됩니다. 로그인이 성공적으로 완료되거나 새 계정을 만든 후에는 앱의 인증 된 부분 Hello의 View로 리다이렉션됩니다. 스텝1. 로그인과 회원가입1-1 로그인 ViewLogin 컴포넌트를 만들어봅시다. src / components 아래에 Login이라는 새로운 Vue 구성 요소를 만듭니다. 일단 컴포넌트는 단순히 제목, 두 개의 input 필드, 버튼 그리고 간단한 문장으로 구성됩니다. 이제 컴포넌트가 생성되었습니다! 하지만이 새로운 컴포넌트를 우리 앱에 어떻게 보여 줄 수 있을까요?음… 우리는 vue-router를 사용할것입니다. 기억하시나요? 우리는 Vue-cli로 앱을 초기 구성할때 이미 vue-router를 설치했습니다. Vue-router 무엇인가? 12345vue-router는 Vue.js의 공식 라우터입니다. Vue와 깊은 관계입니다. Vue.js를 사용하여, Javscript만으로 SPA(Single Page Applications)을 쉽게 만들 수 있습니다.Vue.js + vue-router를 사용하여 SPA(Single Page Applications)을 만드는 것은 매우 간단합니다. Vue.js를 통해 우리는 이미 컴포넌트로 애플리케이션을 구성하고 있습니다. vue-router를 사용 할 때, 우리가해야 할 일은 우리의 구성 요소를 route에 매핑하고 vue-router가 어디서 렌더링할지 알려주는 것입니다.vue-router 설명서 &lt;https://github.com/vuejs/vue-route&gt; 이제 방금 만든 새로운 로그인 컴포넌트를 앱 라우터에 추가해 보겠습니다. src/roubter/index.js 파일을 열고 다음과 같이 로그인 구성 요소를 라우터에 추가합니다. 그런 다음 브라우저 URL을 http://localhost:8080/#/login으로 변경하면 방금 만든 로그인 컴포넌트가 브라우저에 표시됩니다. 1url중간에 #을 제거하고싶다면 router에 mode를 history 모드로 지정하면됩니다. mode:history 로그인 컴포넌트의 html템플릿에 이미지를 넣지 않았는데도 Vue 로고가있는 왜 있을까요? App.vue 파일을 열면 App 컴포넌트의 템플릿은 다음과 같습니다.App 컴포넌트는 앱의 주요 구성 요소이며 처음 렌더링됩니다. Vue 로고 이미지와 router-view라는 html템플릿에 들어 있습니다. router-view는 vue-router의 구성 요소입니다. 123&lt;router-view&gt;는 지정된 경로에 대해 일치하는 컴포넌트를 렌더링하는 기능의 구성 요소입니다. &lt;router-view&gt;에서 렌더링 된 컴포넌트에는 동일한 위치에 대한 컴포넌트를 포함시킬 수 있습니다. vue-router 설명서 &lt;https://router.vuejs.org/en/api/router-view.html&gt; http://localhost:8080/#/login에 요청을 받으면 vue-router는 router-view 구성 요소 내의 router/index.js에 정의 된 경로 /Login의 첨부 된 구성 요소를 렌더링합니다. App 컴포넌트에는 템플릿에 Vue.js 로고의 이미지가 포함되어 있으므로 표시 할 수도 있습니다. 로그인 컴포넌트에 스타일을 추가해 보겠습니다. Login.vue 파일의 style 요소 안에 이러한 스타일을 추가하십시오. 이제 로그인 페이지가 조금 더 예뻐졌습니다. 1-2- 가입하기 페이지이번에는 로그인 컴포넌트를 만든 것과 마찬가지로 가입하기 컴포넌트를 만들 것입니다.이를 위해 src/components/*에 *SignUp이라는 새 vue 컴포넌트를 생성합니다. 로그인 컴포넌트와 마찬가지로 SignUp 컴포넌트는 간단하고 비슷한 같은 스타일로 구성됩니다. 다음으로 src/router/index.js 내의 경로에 새 구성요소를 추가합니다. 그런 다음 브라우저의 url을 http://localhost:8080/#/sign-up으로 열면 다음과 같은 화면을 확인 할 수 있습니다. 지금까지 vue-router에 대한 이론 및 실습을 진행해보았습니다.다음 포스팅에선 vue-router의 router-link를 통해 컴포넌트간 이동을 실습해보겠습니다. 출처해당 글은 medium에 Anas Mammeri의 포스팅 글을 번역한것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"컴포넌트","slug":"컴포넌트","permalink":"https://tuhbm.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"},{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue-router","slug":"vue-router","permalink":"https://tuhbm.github.io/tags/vue-router/"},{"name":"history mode","slug":"history-mode","permalink":"https://tuhbm.github.io/tags/history-mode/"},{"name":"to","slug":"to","permalink":"https://tuhbm.github.io/tags/to/"},{"name":"compontent","slug":"compontent","permalink":"https://tuhbm.github.io/tags/compontent/"}]},{"title":"번역 - Vue 2 + Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 1편","slug":"vue-firebase1","date":"2018-10-20T12:56:34.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2018/10/20/vue-firebase1/","link":"","permalink":"https://tuhbm.github.io/2018/10/20/vue-firebase1/","excerpt":"Vue 2 + Firebase: Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 2편 이 튜토리얼에서는 Vue 2, vue-router 사용 그리고 Firebase의 인증 시스템을 사용하여,웹 어플리케이션을 신속하게 구축하는 방법을 알아봅니다. Vue.js란 무엇인가?다음은 놀랍고 가벼운 Javascript 프레임워크인 Vue.js의 개요입니다. 1234Vue는 사용자 인터페이스 구축을 위한 진보적인 프레임워크입니다. Vue는 타 다른 프레임 워크와 다르게 점진적으로 채택 가능하도록 설계되었습니다. 핵심 라이브러리는 &#x27;View&#x27; 단에만 초점을 맞추고 있으며, 다른 라이브러리 또는 기존 프로젝트와 통합하기가 매우 쉽습니다.vuejs 공식 문서: &lt;https://vuejs.org/v2/guide&gt;","text":"Vue 2 + Firebase: Firebase 인증 시스템을 사용하여 15분 안에 Vue 앱을 만드는 방법 2편 이 튜토리얼에서는 Vue 2, vue-router 사용 그리고 Firebase의 인증 시스템을 사용하여,웹 어플리케이션을 신속하게 구축하는 방법을 알아봅니다. Vue.js란 무엇인가?다음은 놀랍고 가벼운 Javascript 프레임워크인 Vue.js의 개요입니다. 1234Vue는 사용자 인터페이스 구축을 위한 진보적인 프레임워크입니다. Vue는 타 다른 프레임 워크와 다르게 점진적으로 채택 가능하도록 설계되었습니다. 핵심 라이브러리는 &#x27;View&#x27; 단에만 초점을 맞추고 있으며, 다른 라이브러리 또는 기존 프로젝트와 통합하기가 매우 쉽습니다.vuejs 공식 문서: &lt;https://vuejs.org/v2/guide&gt; 왜 Vue.js인가?Vue.js는 사용하기 쉽고 강력하며 문서화도 잘 되어 있습니다. 컴포넌트 중심의 새로운 자바스크립트 프레임워크 시대에 Vue는 단순함과 성능면에서 돋보여 졌습니다. 이러한 생태계(Vue.js의 환경)는 활기차며, 매일 점점 더 많은 사람들이 Vue로 전환한다. Vue.js를 사용해야하는 이유에 대해 더 자세히 알고 싶다면, 다른 javascript 프레임 워크와 비교해보십시오 https://vuejs.org/v2/guide/comparison.html Firebase 란 무엇입니까?123Firebase는 모바일 및 웹 응용 프로그램 개발 플랫폼입니다. Firebase는 개발자가 각각 필요에 맞게 보완하여 믹스 앤 매치 할 수 있는 기능으로 구성되어 있습니다. [...중간내용...] firebase의 초기 제품은 개발자가 여러 클라이언트에 데이터를 저장하고 동기화 할 수있는 API를 제공하는 실시간 데이터베이스였습니다. 그후 시간이 지남에 따라 웹과 앱등 여러 어플리케이션 개발을위한 제품군으로 확장되었습니다.위키피디아: &lt;https://en.wikipedia.org/wiki/Firebase&gt; 간단히 말해, Firebase는 서버에 대한 프로그래밍 없이 애플리케이션을 개발할 수 있는 도구 모음입니다. 실시간 데이터베이스, 인증 시스템, 충돌보고, 분석등의 모바일/웹 앱에서 사용할 수있는 기타 서비스를 제공합니다. 이러한 도구들로 앱과 사용자에게 집중할 수 있습니다. 왜 Firebase인가?인증이나 데이터베이스 스토리지 같은 최소한의 백엔드 요구 사항이 있는 애플리케이션의 경우, 다시 개발 할 필요가 없습니다. Firebase에서 대신해 훨씬 많은 도구를 제공합니다. 또한 확장, 서버 성능 및 데이터베이스 크기에 대해 신경 쓸 필요가 없습니다. Firebase는 모든 것을 자동으로 조정합니다. 시작먼저, 훌륭한 도구 Vue-clihttps://github.com/vuejs/vue-cli를 사용하여 새로운 Vue 프로젝트를 초기 구성 할 것입니다. Vue-cli를 아직 설치하지 않았으면 설치하겠습니다. 1$ npm install -g vue-cli 이제 vue-cli를 설치했으므로 새 프로젝트를 생성하겠습니다. vue-cli 설명서에는 다음과 같은 내용이 나와 있습니다. 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 만약 Vue-cli버전이 3.0이상이라면 아래와 같이 작성하세요. 1$ vue create &lt;project-name&gt; Vue-cli의 멋진 기능 중 하나는 다른 프로젝트 템플릿을 기반으로 프로젝트를 초기 구성 할 수 있으므로 가능한 한 빨리 코드를 작성할 수 있다는 것입니다.템플릿의 공식 목록은 여기를 참조하십시오. https://github.com/vuejs-templates 이 자습서에서는 webpack 템플릿을 사용합니다.(Vue-cli 버전이 3.0이라면 기본적으로 webpack을 사용합니다.) webpack을 사용하는 새로운 Vue 프로젝트를 만들고, 프로젝트 이름을 ‘vue-firebase-tutorial’이라고 해봅시다. 1$ vue init webpack vue-firebase-tutorial Vue-cli 버전이 3.0 이상이라면 1$ vue create vue-firebase-tutorial 프로젝트를 생성하는 동안 몇 가지 옵션을 선택해야합니다. 이 튜토리얼에서는 vue-router를 사용할 예정이므로 반드시 설치하십시오.다른 옵션은 원하는대로 수행하십시오. 나머지 튜토리얼에서는 별 문제가되지 않습니다. 그런 다음 새로운 vue-firebase-tutorial 디렉토리에 들어가서 npm install을 실행 한 다음 npm run dev 실행을 합니다.(Vue-cli 3.0이상에선 별도의 install이 필요없습니다.) 1234$ cd vue-firebase-tutorial$ npm install &#x2F;&#x2F;vue-cli 3.0이하에서만 실행[...]$ npm run dev 이제 만들어진 프로젝트를 브라우저에서 열어봅시다! 앱 구조앱 구조를 간단히 살펴보겠습니다.그리고약간의 차이라면 eslint의 설정파일이 package.json으로 포함되었습니다. 이 튜토리얼에서는 소스 코드가 src/ 디렉토리 아래에 들어가 있다는 것을 알아야합니다. 각 디렉토리 및 파일에 대한 전체 개요를 보려면 여기에서 webpack 템플리트의 문서를 확인하십시오.http://vuejs-templates.github.io/webpack/structure.html 또한 이 튜토리얼을 진행하기 전에 Vue 파일의 구조를 아직 모르는 경우(예: src/components/Hello.vue) 이 내용을 살펴보시기 바랍니다.&lt;vue-loader.vuejs.org/en/start/spec.html&gt; 지금까지 vue-cli를 통한 프로젝트 생성 및 vue의 기본 이론에 대해 살펴보았습니다.다음 포스팅에서는 vue-router 및 컴포넌트를 만들고 코드작성을 해보겠습니다. 출처해당 글은 medium에 Anas Mammeri의 포스팅 글을 번역한것입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"Vue.component","slug":"Vue-component","permalink":"https://tuhbm.github.io/tags/Vue-component/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://tuhbm.github.io/tags/vue-cli/"},{"name":"vue init","slug":"vue-init","permalink":"https://tuhbm.github.io/tags/vue-init/"},{"name":"vue-cli 3.0","slug":"vue-cli-3-0","permalink":"https://tuhbm.github.io/tags/vue-cli-3-0/"},{"name":"vue create","slug":"vue-create","permalink":"https://tuhbm.github.io/tags/vue-create/"},{"name":"npm install","slug":"npm-install","permalink":"https://tuhbm.github.io/tags/npm-install/"},{"name":"npm run dev","slug":"npm-run-dev","permalink":"https://tuhbm.github.io/tags/npm-run-dev/"}]},{"title":"SEO(Search Engine Optimization) 검색 엔진 최적화 1편","slug":"seo1","date":"2018-09-29T18:32:59.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/09/29/seo1/","link":"","permalink":"https://tuhbm.github.io/2018/09/29/seo1/","excerpt":"SEO의 중요성비지니스 측면에 있어서 검색순위 상위권에 노출되는 것은 매우 중요한 부분입니다.검색시 페이지 이동을 해야 검색이 된다면, 그만큼 유저들이 이전페이지들에서 원하는 결과를 얻어 해당 웹사이트에 접속할 확률이 낮습니다.물론 입소문이 타서 자연스럽게 해당 검색어를 정확하게 입력한다면 유저의 유입확률이 높을 것이지만, 그렇지 못한 경우가 많습니다.노출의 효과는 광고를 보면 알 수 있습니다. 자주 보는 광고를 통해 유저에게 특정 비지니스 상품을 홍보하고 그로인해 수익이 됩니다.검색 엔진 최적화도 마찬가지의 효과입니다.그러므로 비지니스 측면에서 검색 엔진 최적화는 매우 중요합니다.스타트업 또는 신제품의 경우 더더욱 중요합니다.","text":"SEO의 중요성비지니스 측면에 있어서 검색순위 상위권에 노출되는 것은 매우 중요한 부분입니다.검색시 페이지 이동을 해야 검색이 된다면, 그만큼 유저들이 이전페이지들에서 원하는 결과를 얻어 해당 웹사이트에 접속할 확률이 낮습니다.물론 입소문이 타서 자연스럽게 해당 검색어를 정확하게 입력한다면 유저의 유입확률이 높을 것이지만, 그렇지 못한 경우가 많습니다.노출의 효과는 광고를 보면 알 수 있습니다. 자주 보는 광고를 통해 유저에게 특정 비지니스 상품을 홍보하고 그로인해 수익이 됩니다.검색 엔진 최적화도 마찬가지의 효과입니다.그러므로 비지니스 측면에서 검색 엔진 최적화는 매우 중요합니다.스타트업 또는 신제품의 경우 더더욱 중요합니다. 우리가 살고 있는 대한민국의 경우 대표적으로 NAVER를 통해 검색하고,개발자들 같은 경우 GOOGLE에서 검색을 많이 합니다.두개의 포털사이트는 각각 다른 검색 엔진을 사용하지만, 기본적인 검색 엔진 최적화 작업은 동일합니다.지금부터 제가 알고 있는 범위내에서 검색 엔진 최적화작업 방법을 기재해보겠습니다. img태그의 alt값 넣기기본적인 웹표준에서 alt값은 이미지가 노출이 되지 않았을 때 대체 텍스트로 들어갈 값을 넣는 것으로 알고 있습니다.이부분 말고도 검색엔진에서는 alt값의 값을 긁어가 검색시 노출값으로 사용합니다.그렇기에 alt값은 웹표준 측면 뿐만 아니라 검색 엔진 최적화 작업에서도 매우 중요합니다. a태그에 href값 넣기a태그는 링크 또는 책갈피같은 역할을 합니다.href값에 URL을 넣으면 해당 URL로 이동을 하는 링크역할,그리고 href값에 #ID 값을 넣으면 해당페이지 내에 값으로 입력한 ID를 가진 DOM으로 이동하는 책갈피 기능합니다.검색 엔진 로봇은 이러한 href값을 읽어 해당 페이지의 검색요소들을 찾는다고 합니다.예를 들어 해당 상세페이지로 이동하여 그안에 검색요소들을 찾아 검색노출값에 노출하는 것입니다. heading tag의 적절한 사용h1~h6까지 heading tag는 페이지 내용의 구조의 제목을 나타내는 태그로 용도에 맞춰 사용해야하며, 또한 너무 남발시 검색엔진이 페이지 구조를 파악하는데 어려움이 있습니다. title태그 와 description 그리고 keywordstitle태그와 meta태그의 description은 검색엔진이 페이지의 내용을 파악할때 기본적으로 사용하는 데이터입니다.title태그는 해당 페이지의 제목을, description은 그페이지에 대한 설명을 나타냅니다. 12&lt;title&gt;페이지 제목&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;페이지 설명을 간략하게 나타냅니다.&quot;&gt; 특별한 글자수 제한은 없지만 네이버 검색엔진에서는 너무 길게 작성시 페널티가 있을 수 있다는 권고사항이 있습니다. 또한 keywords는 검색엔진에 큰영향을 미치지는 않지만 무시할 만한 요소는 아닙니다.description 처럼 키워드 역시 메타태그에 한 종류로 고유한 단어나 문구를 기록합니다. 1&lt;meta name=&quot;keywords&quot; content=&quot;대표키워드, 키워드1, 키워드2, 키워드3, 키워드4, 키워드5&quot;&gt; 대표URL설정하나의 페이지에 여러 URL이 존재할 경우 대표URL을 설정하여 리다이렉션 시키거나 또는 페이지 내에 rel=”canonical”표시를 추가하는 것이 좋습니다. 그래야 페이지랭크에 하나의 대표URL이 등록되어 페이지랭크가 올라가게 되어있습니다. 여기서 말하는 대표URL은 해당 페이지의 표준페이지로 인식됩니다. 1&lt;link rel=&quot;canonical&quot; href=&quot;http://www.seo.com&quot; /&gt; 오픈그래프 사용meta태그에 소셜미디어로 공유시 우선적으로 활용되는 정보입니다. 해당 웹페이지의 제목,설명,대표이미지를 같이 넣어주면 검색엔진이 이를 인식해 검색내용에 활용합니다. 12345&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;&lt;meta property=&quot;og:title&quot; content=&quot;페이지 제목&quot;&gt;&lt;meta property=&quot;og:description&quot; content=&quot;페이지 설명&quot;&gt;&lt;meta property=&quot;og:image&quot; content=&quot;http://www.site.com/image.jpg&quot;&gt;&lt;meta property=&quot;og:url&quot; content=&quot;http://www.site.com&quot;&gt; 소셜미디어 오픈그래프 사용위의 방법과 마찬가지로 소셜미디어 내에 검색 및 공유시 콘텐츠의 정보를 보여주므로써 검색확률을 높일 수 있습니다. 12345&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;&gt;&lt;meta name=&quot;twitter:title&quot; content=&quot;페이지 제목&quot;&gt;&lt;meta name=&quot;twitter:description&quot; content=&quot;페이지 설명&quot;&gt;&lt;meta name=&quot;twitter:image&quot; content=&quot;http://www.site.com/article/article1.html&quot;&gt;&lt;meta name=&quot;twitter:domain&quot; content=&quot;사이트 명&quot;&gt; robots.txt 사용robots.txt는 검색엔진이 사이트에서 액세스할 수 있는 부분과 하지 말아야할 부분(개인정보 조회)을 정해 놓은 검색엔진과의 규약입니다.기본적으로는 검색로봇이 방문하면 안되는 페이지를 이 파일 속에 양식에 맞춰 기록하여, 검색엔진의 신뢰를 통해 최적화되게 됩니다.robots.txt 파일은 반드시 root에 위치해야 합니다. 또한 과도한 robots.txt 설정은 사이트에 더 많은 방문자를 유도할 수 있는 정상적인 검색 엔진만을 차단할 뿐, 해킹이나 악성코드를 유발하는 수많은 악의적인 로봇들은 이러한 로봇 배제 표준을 따르지 않는다는 점도 유의해야 합니다. 사이트맵(Sitemap)의 작성사이트맵은 웹사이트의 구조를 알려주는 페이지입니다.통상적으로 ‘사이트맵’이라고 하면 웹사이트의 메뉴 항목에 포함된 사이트맵 페이지를 떠올리는 경우가 많지만(물론 사용자에게 웹사이트의 구조를 알려준다는 측면에서 이 페이지는 중요합니다), 검색엔진 입장에서 특히 중요한 것은 흔히 ‘Sitemap XML’이라 부르는 XML 형식의 파일입니다.이 파일을 작성하여 (웹마스터 도구를 이용해) 검색엔진에 등록하면 검색엔진이 사이트의 전체 구조를 파악하고 색인을 생성하는데 도움이 됩니다. 결론이러한 방법들을 사용한다고해서 검색시 무조건 상위에 들어간다는 보장은 없습니다.제일 좋은 방법은 많은 유저가 방문하므로써 검색랭킹이 올라가는 방법이 가장 좋은 방법입니다.하지만 유저수를 확보하지 못한 스타트업이나 신규서비스는 마케팅을 제외하고 개발자가 유저에게 노출빈도를 높히는 방법에는 검색 엔진 최적화 작업을 통해 노출하는 방법입니다.SEO 점수 체크 서비스(해당서비스는 google 검색엔진 기준으로 체크) 오픈전 체크를 통해 검색 엔진 최적화가 얼마나 잘 되었는지 확인이 필요합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"SEO","slug":"공부/SEO","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/SEO/"}],"tags":[{"name":"html","slug":"html","permalink":"https://tuhbm.github.io/tags/html/"},{"name":"seo","slug":"seo","permalink":"https://tuhbm.github.io/tags/seo/"},{"name":"search","slug":"search","permalink":"https://tuhbm.github.io/tags/search/"},{"name":"engine","slug":"engine","permalink":"https://tuhbm.github.io/tags/engine/"},{"name":"optimization","slug":"optimization","permalink":"https://tuhbm.github.io/tags/optimization/"},{"name":"검색최적화","slug":"검색최적화","permalink":"https://tuhbm.github.io/tags/%EA%B2%80%EC%83%89%EC%B5%9C%EC%A0%81%ED%99%94/"},{"name":"canonical","slug":"canonical","permalink":"https://tuhbm.github.io/tags/canonical/"},{"name":"noindex","slug":"noindex","permalink":"https://tuhbm.github.io/tags/noindex/"}]},{"title":"알고리즘","slug":"algorithm","date":"2018-08-20T22:47:40.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2018/08/20/algorithm/","link":"","permalink":"https://tuhbm.github.io/2018/08/20/algorithm/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 알고리즘알고리즘이란?명령어들의 순서상 처리과정을 말합니다.예를들어 우리가 학교에 등교할때도 잠에서 깨고, 아침을 먹고, 양치를 하고, 씻고, 교복을 입고, 학교에 도착하기까지의 순서상 처리하는 과정이 있습니다.이들을 순서상 나열해놓은 것을 알고리즘이라고 합니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 알고리즘알고리즘이란?명령어들의 순서상 처리과정을 말합니다.예를들어 우리가 학교에 등교할때도 잠에서 깨고, 아침을 먹고, 양치를 하고, 씻고, 교복을 입고, 학교에 도착하기까지의 순서상 처리하는 과정이 있습니다.이들을 순서상 나열해놓은 것을 알고리즘이라고 합니다. 이러한 과정을 효율적으로 하기위해, 일어나서 씻고, 아침을 먹으면서 교복을 입고 버스를 타고가는것도 알고리즘입니다. 이처럼 최상의 결과를 도출해낼수 있는 알고리즘이 좋은 알고리즘입니다. 컴퓨터를 사용할때도, 입력장치인 마우스와 키보드를 통해 우리가 어떠한 입력을 했을때, 가장 효율적으로 처리하는 것이 가장 좋은 알고리즘이라고 할 수 있습니다. 과거에 우리의 전화번호부는 매우 두껍고 많은 정보를 표현해 두었습니다.많은 사람들의 전화번호를 마구 표현해 놓고, 원하는 정보를 찾기위해 한장한장 넘기는 것도 알고리즘의 과정입니다. 하지만 더 효율적으로 원하는 정보를 보다 빠르고 쉽게 찾기 위해 전화번호부는 ㄱㅎ까지 ㅏㅠ 까지 순서대로 정렬을 해놓았습니다. 그로인해 더 효율적으로 원하는 정보를 찾을수 있었죠.이러한 부분이 바로 효율성과 정확성을 위해 알고리즘을 잘 정의해서 사용하는 좋은 알고리즘이라고 할 수 있습니다. 이처럼 개발을 할 때도 JavaScript부터 Java,C++등등의 개발언어 모두 좋은 알고리즘을 통해 성능과 효율적으로 개발을 했을 때 **’좋은 알고리즘을 사용해서 좋은 서비스를 개발했다.’**라고 말 할 수 있습니다. 아래는 필자가 알고 있는 알고리즘을 공부 할 수 있는 서비스들입니다.독자 여러분들도 이러한 알고리즘을 통해 뛰어 난 개발자가 되었으면 좋겠습니다. 알고리즘 공부 서비스**Programmers - ProgrammersBAEKJOON - BAEKJOON**","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"효율성","slug":"효율성","permalink":"https://tuhbm.github.io/tags/%ED%9A%A8%EC%9C%A8%EC%84%B1/"},{"name":"algorithm","slug":"algorithm","permalink":"https://tuhbm.github.io/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://tuhbm.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"개발","slug":"개발","permalink":"https://tuhbm.github.io/tags/%EA%B0%9C%EB%B0%9C/"}]},{"title":"java 유효범위(scope)","slug":"javaScope","date":"2018-06-24T21:08:55.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/06/24/javaScope/","link":"","permalink":"https://tuhbm.github.io/2018/06/24/javaScope/","excerpt":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 유효범위(scope) 이론우리는 보통 여러명의 개발자들과 협업을 하며 개발을 진행합니다.그렇기에 어떠한 것을 명명할때, 같은 이름으로 충돌이 발생 할 수 있습니다.예를들어, 12int left;public void left() &#123;&#125;","text":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 유효범위(scope) 이론우리는 보통 여러명의 개발자들과 협업을 하며 개발을 진행합니다.그렇기에 어떠한 것을 명명할때, 같은 이름으로 충돌이 발생 할 수 있습니다.예를들어, 12int left;public void left() &#123;&#125; 위의 경우와 같이 left는 왼쪽이라는 뜻으로 사용 할 수도있고, leave의 과거형 left으로 사용될 수 도 있습니다.이와같은 경우는 흔히 매우 빈번히 발생하는 경우 입니다.그렇기에 개발을 함에 있어, 에러등이 발생 할 수 있습니다. 자바역시 자바스크립트와 같이 유효범위(scope)가 존재하므로써 이러한 명명충돌을 방지할 수 있습니다. 번외의 이야기만 사실 명명할때 사람이 보기 좋은 누가봐도 알 수 있을 만한 명명규칙을 고민해봅시다.예를들면, getArticleInfo와 같이 길어도 누가봐도 기사정보를 가져오는 메소드구나! 이러한 느낌이 들도록 명명규칙을 고민해봅시다. 명명규칙에서 길더라도 명확한게 좋습니다. 다만 보통 단어별로 대문자를 사용하는 카멜케이스를 사용합니다.(물론 케밥기법이라던지 다양한 종류가 있지만 필자는 카멜케이스를 선호합니다.)다양한 방법은 위키를 참고하세요. 다시 본론으로 들어가서유효범위에 대해 다시 돌아가 보겠습니다. 123456789101112public class DemoScope &#123; static void a () &#123; int i = 0; &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 5; i++) &#123; a(); System.out.println(i); &#125; &#125;&#125; 결과를 예상해봅시다. 유효범위(Scope)를 제외하고 생각하면for문이 돌아갈때 메소드 a가 실행되면 i=0 이 되므로 0이 무한으로 찍히는 경우가 발생합니다.바로 무한루프가 발생합니다. 하지만 유효범위(Scope)라는 것이 존재하기에 이 코드는 0,1,2,3,4가 찍히고 종료됩니다.유효범위(Scope)가 존재하기 때문입니다.메소드에서 다른메소드의 지역변수(i)를 호출한다하더라도, 유효 범위의 우선순위는 지역변수 그다음이 멤버변수입니다.또한 메소드에서 다른 메소드의 지역변수의 값은 참조 할 수 없습니다.그렇기에 main메소드의 지역변수 i의 값은 0,1,2,3,4가 찍히게 되는것입니다. 다음예제를 보겠습니다. 123456789101112public class DemoScope &#123; static int i; static void a() &#123; i = 0; &#125; public static void main(String[] args) &#123; for(i = 0; i &lt; 5; i++) &#123; a(); System.out.println(i); &#125; &#125;&#125; 이전 코드와 다른점은 메소드a의 i와 for문에 i가 모두 멤버변수의 값을 참조하고있습니다.이코드를 실행시키면 어떻게 될까요?0000000000000000000000이 무한하게 찍히는 무한루프에 빠집니다. 위에서 말씀드렸다시피 메소드에서 유효범위(Scope)의 우선순위는 지역변수 다음 멤버변수입니다.하지만 이코드에서는 for문에서 i를 증가되어도 System.out.println(i)가 실행전 메소드a가 먼저 실행되기 때문에 i의 값은 계속 0이 되므로 무한루프에 빠지게 되는 것입니다. 무한루프를 빠져나오기 위해선 메소드 a의 i의 값을 지역변수로 선언해주면 말끔히 해결됩니다. 123static void a() &#123; int i = 0;&#125; 이렇게 고쳐주면 메소드 a의 i의 값은 지역변수가 되므로 멤버변수의 i의 값에는 영향을 미치지 못합니다.또한 main메소드에서는 i의 값을 멤버변수의 i의 값을 사용하는것입니다. 그렇다면 지역변수가 존재하는 메소드에서는 멤버변수에 접근을 못하는것인가?라는 의문을 가질 수 있습니다.예제를 들어보겠습니다. 1234567891011121314151617class Demo &#123; int v = 10; void m() &#123; int v = 20; System.out.println(v); &#125;&#125;public class DemoScope2 &#123; public static void main(String[] args) &#123; Demo c1 = new Demo(); c1.m(); &#125;&#125; 결과를 예측해보세요. 결과는 20이 출력됩니다.그렇다면 우리가 원하는 멤버변수의 값인 10이 나오게하려면 어떻게 해야할까요?이럴때 사용하는 키워드가 바로 this입니다. 1234void m() &#123; int v = 20; System.out.println(this.v);&#125; 이렇게 this를 사용하면 결과 값은 10이 나옵니다.this는 현재 실행된 메소드의 부모를 나타내므로 클래스Demo를 가르키게 됩니다. 이상으로 유효범위에 대해 알아보았습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"JAVA","slug":"공부/JAVA","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"oop","slug":"oop","permalink":"https://tuhbm.github.io/tags/oop/"},{"name":"객체지향","slug":"객체지향","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"메소드","slug":"메소드","permalink":"https://tuhbm.github.io/tags/%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"클래스","slug":"클래스","permalink":"https://tuhbm.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"멤버변수","slug":"멤버변수","permalink":"https://tuhbm.github.io/tags/%EB%A9%A4%EB%B2%84%EB%B3%80%EC%88%98/"},{"name":"유효범위","slug":"유효범위","permalink":"https://tuhbm.github.io/tags/%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/"},{"name":"스코프","slug":"스코프","permalink":"https://tuhbm.github.io/tags/%EC%8A%A4%EC%BD%94%ED%94%84/"},{"name":"scope","slug":"scope","permalink":"https://tuhbm.github.io/tags/scope/"},{"name":"this","slug":"this","permalink":"https://tuhbm.github.io/tags/this/"}]},{"title":"객체지향 언어 자바 이론","slug":"javaObjectOriented","date":"2018-06-21T22:33:33.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/06/21/javaObjectOriented/","link":"","permalink":"https://tuhbm.github.io/2018/06/21/javaObjectOriented/","excerpt":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 객체지향 이론하나의 결과물을 만들때, 필요한부분을 각각 개발하여, 하나로 사용하고, 또 필요한부분을 가져가 쓰는 방법이 객체지향프로그래밍입니다. 예를 들어보겠습니다.초창기 컴퓨터는 하나의 기계였습니다..그림으로 살펴보겠습니다..","text":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 객체지향 이론하나의 결과물을 만들때, 필요한부분을 각각 개발하여, 하나로 사용하고, 또 필요한부분을 가져가 쓰는 방법이 객체지향프로그래밍입니다. 예를 들어보겠습니다.초창기 컴퓨터는 하나의 기계였습니다..그림으로 살펴보겠습니다.. 이처럼 각 모니터(출력장치)와 본체(저장 및 연산장치) 키보드(입력장치)가 모두 하나로 연결되어있습니다.그렇기에 각각 하나의 부분이 고장난다고하면, 전체 수리를 맡기거나 교체를 해야 합니다. 그렇기에 현대의 컴퓨터는 각각 필요한 부분을 부품화하여, 조합하여 사용하는 방법으로 사용하고 있습니다.이러한 방식으로 부품화하여, 필요에 의해 부품을 가져다 쓰는방법입니다.예를 들면 필요에 의해 모니터를 두개사용하는 듀얼모니터 등을 예로 들 수 있습니다. 앞서 컴퓨터를 예로 들어본것처럼저장매체(아는것) + 출력&amp;입력등(하는것)을 하나로 묶은 객체를 부품화하여,각각 조합하여 사용하는 방법을 객체지향프로그래밍이라고 이해하면 될 것 같습니다. 클래스멤버변수(아는것)와 메소드(하는것)를 둘중 하나를 꼭 포함한 하나의 부품 멤버변수(아는것) 변수로 상태(아는것) 또는 값을 저장 메소드 기능부분(하는일) 공통부분을 하나의 기능별로 정리 은닉화,캡슐화부품을 사용할때, 단순 그룹핑하여 객체화 하였다고, 끝이 아닙니다.정작 사용하는데 있어서, 전문지식이 없이도 어떠한 정보만으로 만들 수 있도록 해야합니다.어떻게 동작하는지 정확히 알지못하는 사람도 사용할 수 있도록 만들어야 합니다.예를 들면 모니터가 어떻게 작동하는지에 대한 원리는 우리는 알지 못합니다.하지만 HDMI케이블 또는 DVI케이블을 사용하여, 본체와 연결하면 제대로 작동시킬 줄 아는것처럼동작 방법을 클래스 안에 숨기고, 사용방법만을 노출하는 방식을 은닉화, 캡슐화라고 합니다. 인터페이스부품과 부품사이 연결을 통하여, 부품끼리의 정보교환을 통해 연산 또는 출력 등의 작업이 이루어집니다.예를 들면, 본체와 모니터를 연결하는 HDMI의 연결선은 규격화 되어있어, 어떠한 모니터를 변경하여도 정상적으로 연결이 가능합니다. 이러한 규격화되어있는 HDMI와 같은 연결선을 인터페이스라고 합니다.부품끼리 서로 규격에 맞지 않는 부분이 있는데 연결하려 하면, 연결이 안됩니다.사전에 맞지 않는 부분을 차단하는 역할을 한다고 할 수 있습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"JAVA","slug":"공부/JAVA","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/JAVA/"}],"tags":[{"name":"인터페이스","slug":"인터페이스","permalink":"https://tuhbm.github.io/tags/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/"},{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"oop","slug":"oop","permalink":"https://tuhbm.github.io/tags/oop/"},{"name":"객체지향","slug":"객체지향","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"메소드","slug":"메소드","permalink":"https://tuhbm.github.io/tags/%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"클래스","slug":"클래스","permalink":"https://tuhbm.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"멤버변수","slug":"멤버변수","permalink":"https://tuhbm.github.io/tags/%EB%A9%A4%EB%B2%84%EB%B3%80%EC%88%98/"},{"name":"은닉화","slug":"은닉화","permalink":"https://tuhbm.github.io/tags/%EC%9D%80%EB%8B%89%ED%99%94/"},{"name":"캡슐화","slug":"캡슐화","permalink":"https://tuhbm.github.io/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"}]},{"title":"Java Data Type","slug":"javaDataType","date":"2018-06-14T21:27:36.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/06/14/javaDataType/","link":"","permalink":"https://tuhbm.github.io/2018/06/14/javaDataType/","excerpt":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 데이터 타입프로그래밍에서 데이터는 데이터형식, 메모리의 소비크기, 표현가능범위에 따라 알맞게 사용해야합니다.그 내용은 데이터의 형식을 알아보면서 알아보겠습니다.","text":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 데이터 타입프로그래밍에서 데이터는 데이터형식, 메모리의 소비크기, 표현가능범위에 따라 알맞게 사용해야합니다.그 내용은 데이터의 형식을 알아보면서 알아보겠습니다. 숫자정수형 데이터 타입 메모리의 크기 표현 가능 범위 byte 1 byte -128 ~ 127 short 2 byte -32,768 ~ 32,767 int 4 byte -2,147,483,648~2,147,483,647 long 8 byte -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 실수형 데이터 타입 메모리의 크기 표현 가능 범위 float 4byte ±(1.40129846432481707e-45 ~ 3.40282346638528860e+38) double 8byte ±(4.94065645841246544e-324d ~ 1.79769313486231570e+308d) 여기서 문제를 내보겠습니다. 12long a &#x3D; 123123123;long b &#x3D; 123; 이 변수의 메모리의 크기는 같을까요? 다를까요? 정답은 같습니다. 하지만 a에는 123132123이라는 큰 숫자가 들어갔지만,b에는 123이라는 작은 숫자가 들어갔습니다. 그럼에도 불구하고 메모리의 크기는 같습니다.컴퓨터 프로그래밍은 결국 메모리를 어떻게 사용하느냐에 따라 성능의 차이가 나타납니다.위의 b와같은 경우처럼 작은 숫자를 이용할때는 byte를 사용해야 하는것처럼 알맞은 데이터형태를 선언하므로써 메모리의 용량을 아낄수 있습니다.추가적으로 오늘날 하드웨어의 발달로 인해 메모리의 용량이 많이 향상되어, 정수를 사용할때는 충분히 편하게 큰 수를 표현 할 수 있는 데이터 타입인 int를 주로 사용합니다. 명시적 데이터타입명시적으로 데이터 형태를 표기해줘야 하는 데이터타입 형태가 있다. 1int a &#x3D; 2.2; 에러가 납니다. 2.2는 실수형 타입입니다. 그렇다면 실수형 타입인 float으로 변경해보겠습니다. 1float a &#x3D; 2.2; 에러가 납니다.그렇다면 double형태를 사용해보겠습니다. 1double a &#x3D; 2.2; 에러가 나지않습니다.이는 2.2는 double형태의 데이터값이라는 것입니다.‘float의 데이터형태는 언제 사용하지…?’라는 의문이 듭니다.float의 데이터 타입은 명시적으로 값에 float의 형태의 값이라는 F을 지정해줘야합니다. 1float a &#x3D; 2.2F; 이렇게 하니 에러가 안나는 것을 확인 할 수 있습니다. 1int a &#x3D; 2147483648; int는 2,147,483,647까지 밖에 표현을 못합니다.그러면 큰값을 표기할 수 있는 long의 데이터 형태를 사용해보겠습니다. 1long a &#x3D; 2147483648; 에러가 납니다. 이부분 역시 float의 형태와 같이 명시적으로 값을 지정해주겠습니다. 1long a &#x3D; 2147483648L; 이렇게 명시적으로 값을 long의 데이터 타입 L을 지정해주니 에러가 발생하지 않습니다. byte나 short의 데이터의 형태같은경우 자바에서 자체적으로 편하게 사용하기위해 int의 데이터값을 허용하고 있습니다. 단 허용범위내에 표시 할 수 있는 경우에 한에서만 가능합니다. 이부분은 생활코딩 강좌를 참고하였습니다. 문자 데이터 타입 메모리의 크기 표현 가능 범위 char 2byte 모든 유니코드 문자 자바에서는 문자와 문자열이 다릅니다.문자(character)는 글자 하나를 의미하고, 문자열은 글자들의 집합을 의미합니다. 문자열 데이터 타입 메모리의 크기 표현 가능 범위 String 글자당 2byte 모든 유니코드 문자 자동 형 변환서로 다른 데이터 타입의 형태의 숫자가 있다고 이를 더해야 한다고 생각을 해봅시다.예를들면 int와 byte값이 있다면 이는 데이터형태가 다르므로 더하기가 안되야합니다. 1234int a &#x3D; 20;byte b &#x3D; 10;int p &#x3D; a+b;System.out.println(p); &#x2F;&#x2F;30 실행이 되는 것을 볼 수 있습니다. ‘자바는 형태에 따른 오류를 방지하기 위한 엄격한 언어인데..’라는 생각이 들겠지만,자바도 유연함을 갖추고 있습니다.바로 표현 할 수 있는 메모리의 크기별로 데이터의 손실이 발생하지 않으므로,자동으로 형변환을 합니다. 또한 실수는 정수를 포함하지만, 정수는 실수를 포함 할 수 없습니다.이처럼 데이터 형태에 따라 자동으로 형변환이 가능한부분을 표기해보면byte =&gt; short, char =&gt; int =&gt; long =&gt; float =&gt; double순서로 자동으로 형변환이 됩니다. 명시적 형 변환자동으로 형변환이 되지 않는 부분들은 직접 명시적 형 변환을 해야 합니다. 1int a &#x3D; 100.0F; 이러한 변수타입은 에러가 발생합니다.데이터형태는 int형태이나 값은 float의 형태이기 때문입니다.이와같은경우 명시적 형 변환이 필요합니다. 1int a &#x3D; (int) 100.0F; 이렇게 값앞에 (int)을 적어주므로써 값을 명시적으로 int의 데이터형태로 변화하였습니다. 다른 예를 들어보겠습니다. 1int b &#x3D; 100.1F; 변환해보겠습니다. 1int b &#x3D; (int) 100.1F; 결과는 100이 출력됩니다.int의 형태로 변경하기위해 소수점이하를 버림으로 처리하기 때문입니다.이와 같은경우 기존에 갖고 있던 데이터의 손실이 발생합니다. 데이터의 손실이 발생하지않도록 곱하기를 하거나 더하기와 같이 추가적인 계산을 통해 데이터 손실이 발생하지 않도록 해야 합니다. 이번 포스팅을 통해 데이터의 타입과 형변환에 대해 알아보았습니다.다음시간엔 비교연산자와 배열에 대해 알아보도록하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"JAVA","slug":"공부/JAVA","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"oop","slug":"oop","permalink":"https://tuhbm.github.io/tags/oop/"},{"name":"객체지향","slug":"객체지향","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"데이터타입","slug":"데이터타입","permalink":"https://tuhbm.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"name":"byte","slug":"byte","permalink":"https://tuhbm.github.io/tags/byte/"},{"name":"숫자","slug":"숫자","permalink":"https://tuhbm.github.io/tags/%EC%88%AB%EC%9E%90/"},{"name":"정수","slug":"정수","permalink":"https://tuhbm.github.io/tags/%EC%A0%95%EC%88%98/"},{"name":"실수","slug":"실수","permalink":"https://tuhbm.github.io/tags/%EC%8B%A4%EC%88%98/"},{"name":"문자","slug":"문자","permalink":"https://tuhbm.github.io/tags/%EB%AC%B8%EC%9E%90/"},{"name":"문자열","slug":"문자열","permalink":"https://tuhbm.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"long","slug":"long","permalink":"https://tuhbm.github.io/tags/long/"},{"name":"float","slug":"float","permalink":"https://tuhbm.github.io/tags/float/"},{"name":"암시적형변화","slug":"암시적형변화","permalink":"https://tuhbm.github.io/tags/%EC%95%94%EC%8B%9C%EC%A0%81%ED%98%95%EB%B3%80%ED%99%94/"},{"name":"명시적형변화","slug":"명시적형변화","permalink":"https://tuhbm.github.io/tags/%EB%AA%85%EC%8B%9C%EC%A0%81%ED%98%95%EB%B3%80%ED%99%94/"}]},{"title":"Java 숫자와 문자","slug":"javaNumberText","date":"2018-06-13T20:29:10.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/06/13/javaNumberText/","link":"","permalink":"https://tuhbm.github.io/2018/06/13/javaNumberText/","excerpt":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 자바(JAVA) 숫자와 문자 System.out숫자와 문자를 접하기전에 우리는 결과물을 확인 할 방법을 먼저 알아보겠습니다.자바는 웹브라우저가 아닌 JVM을 이용해 실행합니다. CMD나 터미널등을 통해서도 코드작성이 가능하지만, **IDE(Integrated development environment)**를 통해 편하게 개발을 할 수 있습니다.IDE에는 여러가지가 있겠지만, 저는 jetbrain사의 intellij를 사용하고 있습니다.개발시 각자 본인에 맞는 IDE를 찾아보시길 권장합니다.IDE에서는 Run기능을 통해 실행하여 작성한 코드의 컴파일 결과를 확인 할 수 있습니다.","text":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 자바(JAVA) 숫자와 문자 System.out숫자와 문자를 접하기전에 우리는 결과물을 확인 할 방법을 먼저 알아보겠습니다.자바는 웹브라우저가 아닌 JVM을 이용해 실행합니다. CMD나 터미널등을 통해서도 코드작성이 가능하지만, **IDE(Integrated development environment)**를 통해 편하게 개발을 할 수 있습니다.IDE에는 여러가지가 있겠지만, 저는 jetbrain사의 intellij를 사용하고 있습니다.개발시 각자 본인에 맞는 IDE를 찾아보시길 권장합니다.IDE에서는 Run기능을 통해 실행하여 작성한 코드의 컴파일 결과를 확인 할 수 있습니다. 자바스크립트에서 console의 역할을 하는 부분을 자바에서는 **System.out 프로퍼티**를 통해 실행 결과 확인할 수 있습니다. System.out.println - 입력시 한줄씩 자동 줄바뀜123System.out.println(&quot;테스트1&quot;);System.out.println(&quot;테스트2&quot;);System.out.println(&quot;테스트3&quot;); 결과물123테스트1테스트2테스트3 System.out.print - 입력시 이어서 출력123System.out.print(&quot;테스트1&quot;);System.out.print(&quot;테스트2&quot;);System.out.print(&quot;테스트3&quot;); 결과물1테스트1테스트2테스트3 위에 내용을 살펴보면 1System.out.print(&quot;테스트1&quot;); 이처럼 &quot;&quot;큰따옴표를 사용한 것을 볼 수 있습니다. 기존 자바스크립트에서는 &#39;&#39; 또는 &quot;&quot;를 이용해 문자열을 입력하였습니다.자바에서도 마찬가지로 ‘’ 또는 &quot;&quot;를 이용 할 수 있습니다.하지만 차이가 있습니다. 1System.out.println(&quot;테스트&quot;); 를 입력시 정상적으로 실행이 됩니다. 하지만 1System.out.println(&#39;테스트&#39;); 여러글자를 입력시 오류가 발생합니다. 1System.out.println(&#39;테&#39;); 이처럼 한글자의 문자를 넣을때는 작은따옴표가 허용이되지만, 문자열(문자조합)을 입력시는 큰따옴표를 사용해야합니다. 문자열 입력시 큰따옴표를 사용해야합니다 변수기존 자바스크립트는 데이터의 형식을 정하지 않고, 자유로운 형식의 데이터를 변수에 담을 수 있었습니다.이부분은 ‘자유롭다. 유연하다.’라는 장점과 ‘그로 인해 오류가 발생하기 쉽다.’단점을 갖고 있습니다. 하지만 자바는 이러한 데이터형식을 변수를 선언할때 정의해야합니다.데이터 형식을 정의하지 않은 변수를 작성시 컴파일이 되지 않는 엄격한 언어입니다. 자바스크립트와 비교해보도록 하겠습니다. 123var a &#x3D; 0;let b &#x3D; 1;const pi &#x3D; 3.14; 선언시 데이터의 형태를 구분하는 부분이 없습니다.그렇기에 코드를 작성할때 방어패턴등을 사용하여, 올바른 데이터형태가 들어왔는지 확인하는 등의 방법으로 오류를 방지하였습니다. 다음으로 자바입니다. 1234int a &#x3D; 0;double pi &#x3D; 3.14;String b &#x3D; &quot;문자&quot;;byte c &#x3D; 1; 등 선언시 int, double, String, byte등의 데이터 형식을 미리 정의 한 후 변수이름을 선언합니다.데이터 형태는 다음 시간에 포스팅하도록 하겠습니다. 세미콜론세미콜론(;)은 코드를 작성시 끝을 의미한다.과거 자바스크립트에서는 세미콜론을 사용해도 되고, 사용하지 않아도 됩니다.세미콜론을 사용하므로써, 좀 더 명확히 문장의 끝을 나타내 사람도 보기 편하고 오류도 줄이는 결과를 가져올 수 있지만,한편으로는 세미콜론도 하나의 문자로 문서의 크기를 늘린다고 보는 개발자들도 존재한다.그렇기에 외국의 동영상강의를 보았을때 세미콜론을 사용하지 않는 개발자들도 많이 보았습니다. 하지만 자바에서는 세미콜론을 사용하지 않으면 컴파일이 되지 않아 에러가 발생하므로,자바에서는 세미콜론을 강제한다.라고 기억해 두시기 바랍니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"JAVA","slug":"공부/JAVA","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"oop","slug":"oop","permalink":"https://tuhbm.github.io/tags/oop/"},{"name":"객체지향","slug":"객체지향","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"문자열","slug":"문자열","permalink":"https://tuhbm.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"System.out","slug":"System-out","permalink":"https://tuhbm.github.io/tags/System-out/"},{"name":"console","slug":"console","permalink":"https://tuhbm.github.io/tags/console/"},{"name":"세미콜론","slug":"세미콜론","permalink":"https://tuhbm.github.io/tags/%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0/"},{"name":"큰따옴표","slug":"큰따옴표","permalink":"https://tuhbm.github.io/tags/%ED%81%B0%EB%94%B0%EC%98%B4%ED%91%9C/"},{"name":"작은따옴표","slug":"작은따옴표","permalink":"https://tuhbm.github.io/tags/%EC%9E%91%EC%9D%80%EB%94%B0%EC%98%B4%ED%91%9C/"}]},{"title":"Java 시작","slug":"startJava","date":"2018-06-11T22:07:25.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/06/11/startJava/","link":"","permalink":"https://tuhbm.github.io/2018/06/11/startJava/","excerpt":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 자바(JAVA) 시작하기 자바를 시작하게된 계기프론트 엔드 개발자로써 예전부터 패러다임이었던 OOP(Object-Oriented Programming) 즉 객체지향프로그래밍은 모든 개발자에게 접할 수 밖에 없는 숙제 일것이다.개발을 시작한지 얼마 되지 않은 필자는 지금까지 해왔던 절차지향프로그래밍을 떠나 객체지향프로그래밍을 접하기 위해, 공부를 하던 중 객체지향프로그래밍의 본좌인 JAVA를 공부하고 싶은 호기심이 생겼다.최근 개발 패러다임이라면 함수형 프로그래밍도 있겠지만, 좀 더 아직까진 대중적인 패러다임인 객체지향 프로그래밍을 시작하기로 했다.","text":"JAVA이 카테고리는 자바를 공부 하며, 익힌 내용을 기록합니다.책을 보며, 또는 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 자바(JAVA) 시작하기 자바를 시작하게된 계기프론트 엔드 개발자로써 예전부터 패러다임이었던 OOP(Object-Oriented Programming) 즉 객체지향프로그래밍은 모든 개발자에게 접할 수 밖에 없는 숙제 일것이다.개발을 시작한지 얼마 되지 않은 필자는 지금까지 해왔던 절차지향프로그래밍을 떠나 객체지향프로그래밍을 접하기 위해, 공부를 하던 중 객체지향프로그래밍의 본좌인 JAVA를 공부하고 싶은 호기심이 생겼다.최근 개발 패러다임이라면 함수형 프로그래밍도 있겠지만, 좀 더 아직까진 대중적인 패러다임인 객체지향 프로그래밍을 시작하기로 했다. 자바 설치하기자바는 자바스크립트와 마찬가지로 작성한 코드를 컴파일러를 통해 컴파일된 결과물을 **JVM(Java Virtual Machine)**을 통해 실행하여야 합니다.JVM에 대한 설명은 위키 링크를 통해 확인해보세요.자바는 과거 1.02버전부터 현 11버전까지 지속적으로 시행착오를 통해 성장해 왔습니다.자바는 1.1에서 1.2로 업데이트 되었을때, 마케팅팀에서 아예 이름을 새로 정해야겠다는 생각에 “자바 2”라고 지었다고 합니다.1.3버전과 1.4버전에서는 미비한 업데이트로 인해 계속 “자바 2”라는 명칭을 사용하다가대대전인 변화인 1.5 버전부터는 “자바 5”라고 이름을 변경하며, 현재 11버전까지 지속적으로 발전하고 있습니다. 자바로 개발을 하기위해서는 **JDK(Java Development Kit)**으로 설치하도록 합니다.자바는 원래 썬 마이크로시스템즈에서 만들고 배포했지만 오라클이 썬을 인수하면서부터 라이센스가 좀 복잡하게 변경 되었다고 합니다.하지만 공부를 위해 필요한 JDK는 온라인에서 무료로 다운로드 받고 설치할 수 있습니다.오라클 JDK공식홈페이지를 통해 다운을 받고 나면 일반적인 프로그램처럼 설치를 합니다. 윈도우와 Mac OS X는 설치방법이 다릅니다.윈도우는 설치를 직접해야 하는데, Mac OS X는 기존 설치로 별도의 설치가 필요 없습니다. 다음 포스팅부터는 자바의 기초 문법을, 공부하여 포스팅하겠습니다. Hello JAVA!!Hello OOP!!","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"JAVA","slug":"공부/JAVA","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"oop","slug":"oop","permalink":"https://tuhbm.github.io/tags/oop/"},{"name":"객체지향","slug":"객체지향","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"}]},{"title":"이것이 자바다","slug":"javaBook","date":"2018-04-12T21:51:20.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/04/12/javaBook/","link":"","permalink":"https://tuhbm.github.io/2018/04/12/javaBook/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 이것이 자바다 한줄평 리뷰어마어마한 두께만큼 배울때 보면 좋은도서다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 이것이 자바다 한줄평 리뷰어마어마한 두께만큼 배울때 보면 좋은도서다. 책정보 판매처: 한빛출판네트워크저자 : 신용권출간 : 2015-01-06페이지 : 1224 쪽가격 : 정가 30,000원 -&gt; 판매가 27,000원(10% off) 상세정보 네이버 북스 한빛출판네트워크 소개JAVA는 프로그래밍에서 손꼽히는 중요한 언어다. 2015년에 출간하여, 현재까지 동영상강의를 12개월 제공하며 JAVA를 배우는 이들이 쉽게 배울 수 있도록 노력하였다.책의 부피에 처음 압도되고, 내용의 꼼꼼함에서 다시 압도된다.책을 들고다니기 부담스러워 걱정이 되었으나 다행히도 분권이 가능하여 출퇴근길에 보기 편했다. 장점 스케줄표 및 예상시간등 그리고 동영상강의를 12개월 무료로 볼 수 있게 해주어 이해하기 그나마 쉽게 출간하였다. 단점 JAVA라는 전공자들이 학교를 다니면서 배우는 언어로 기초 CS(Computer Science)지식이 요구된다. 후기프론트엔드 개발자로써 JAVA보다 하위 언어인 Javascript를 주로 사용하는 개발자로써, 매우 정적인 언어로 이해하는데 힘들고, 아직도 힘들다.하지만 Javascript의 자유로움을 제한하여 Type을 작성하도록 하는 Typescript를 이해하는데 충분한 도움이 될 수 있다. 이 서평은 한빛비디어를 통해 제공받은 서적을 토대로 작성된 리뷰입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"book-review","slug":"book-review","permalink":"https://tuhbm.github.io/tags/book-review/"},{"name":"start","slug":"start","permalink":"https://tuhbm.github.io/tags/start/"},{"name":"북리뷰","slug":"북리뷰","permalink":"https://tuhbm.github.io/tags/%EB%B6%81%EB%A6%AC%EB%B7%B0/"},{"name":"프로그래머","slug":"프로그래머","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/"},{"name":"비전공자","slug":"비전공자","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90/"},{"name":"java","slug":"java","permalink":"https://tuhbm.github.io/tags/java/"},{"name":"major","slug":"major","permalink":"https://tuhbm.github.io/tags/major/"}]},{"title":"슈퍼클래스 와 서브클래스","slug":"superClassAndSubClass","date":"2018-03-11T13:30:13.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/03/11/superClassAndSubClass/","link":"","permalink":"https://tuhbm.github.io/2018/03/11/superClassAndSubClass/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 슈퍼클래스(superClass)와 서브클래스(subClass)슈퍼클래스와 서브클래스는 상속에서 나오는 개념입니다.원래 상속에 대한 개념은 고급언어 Java의 개념입니다.자바스크립트에서는 상속의 대한 개념이 적용이 되지 않고, 상속 비슷하게 만드는 개념인 prototype이 있습니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 슈퍼클래스(superClass)와 서브클래스(subClass)슈퍼클래스와 서브클래스는 상속에서 나오는 개념입니다.원래 상속에 대한 개념은 고급언어 Java의 개념입니다.자바스크립트에서는 상속의 대한 개념이 적용이 되지 않고, 상속 비슷하게 만드는 개념인 prototype이 있습니다. 예를 들어 살펴보겠습니다.예제는 ES6를 바벨을 사용하여 ES5로 변환하여, 상속의 개념을 살펴보겠습니다. 123456789101112131415161718class animal &#123; constructor(name)&#123; this.name = name; &#125; move(number)&#123; console.log(`Move Move!!! $&#123;number&#125;M`); &#125;&#125;class dog extends animal &#123;2speak(sound)&#123; console.log(`$&#123;this.name&#125; is speak $&#123;sound&#125;`); &#125;&#125;const Rocky = new dog(&#x27;Rocky&#x27;);Rocky.move(5);Rocky.speak(&#x27;wal wal&#x27;); 바벨(babel)을 이용하여 ES6문법을 ES6로 컴파일해보겠습니다. 1234567891011121314151617181920212223242526272829303132333435&#x27;use strict&#x27;;var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;();function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;); &#125; return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self; &#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123; throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; &#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;var animal = function () &#123; function animal(name) &#123; _classCallCheck(this, animal); this.name = name; &#125; _createClass(animal, [&#123; key: &#x27;move&#x27;, value: function move(number) &#123; console.log(&#x27;Move Move!!! &#x27; + number + &#x27;M&#x27;); &#125; &#125;]); return animal;&#125;();var dog = function (_animal) &#123; _inherits(dog, _animal); function dog() &#123; _classCallCheck(this, dog); return _possibleConstructorReturn(this, (dog.__proto__ || Object.getPrototypeOf(dog)).apply(this, arguments)); &#125; _createClass(dog, [&#123; key: &#x27;speak&#x27;, value: function speak(sound) &#123; console.log(this.name + &#x27; is speak &#x27; + sound); &#125; &#125;]); return dog;&#125;(animal);var Rocky = new dog(&#x27;Rocky&#x27;);Rocky.move(5);Rocky.speak(&#x27;wal wal&#x27;); 내용이 매우 복잡해 자세히 설명드리기는 어려우겠으나, 처음나오는 4줄을 살펴보면 1234var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;();function _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError(&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;); &#125; return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self; &#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123; throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; &#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125; ES5의 prototype을 이용한거라는 추측이 가능합니다.이처럼 Javascript에서는 상속의 개념이 없습니다. 그럼 이번 주제인 슈퍼클래스와 서브클래스는 무엇일까요?앞에 나왔던 ES6문법에선 클래스를 사용하였으므로 앞에 예제를 다시 살펴보죠. 12345678910class animal &#123; //...&#125;class dog extends animal &#123; //...&#125;const Rocky = new dog(&#x27;Rocky&#x27;);//... animal의 클래스를 extends를 이용해 dog에 상속한 것을 볼 수 있습니다. 이번예제에서는animal - 상속을 해준 부모를 슈퍼클래스,부모클래스라 하고dog - 상속을 받은 자식을 서브클래스,자식클래스라고 합니다. 앞으로 천천히 상속에 대해 공부해가며, 상속에 대한 내용르 더 정리하는 시간을 갖도록 하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"클래스","slug":"클래스","permalink":"https://tuhbm.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"superClass","slug":"superClass","permalink":"https://tuhbm.github.io/tags/superClass/"},{"name":"subClass","slug":"subClass","permalink":"https://tuhbm.github.io/tags/subClass/"},{"name":"inherit","slug":"inherit","permalink":"https://tuhbm.github.io/tags/inherit/"},{"name":"슈퍼클래스","slug":"슈퍼클래스","permalink":"https://tuhbm.github.io/tags/%EC%8A%88%ED%8D%BC%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"서브클래스","slug":"서브클래스","permalink":"https://tuhbm.github.io/tags/%EC%84%9C%EB%B8%8C%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"상속","slug":"상속","permalink":"https://tuhbm.github.io/tags/%EC%83%81%EC%86%8D/"},{"name":"프로토타입","slug":"프로토타입","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"prototype","slug":"prototype","permalink":"https://tuhbm.github.io/tags/prototype/"},{"name":"객체","slug":"객체","permalink":"https://tuhbm.github.io/tags/%EA%B0%9D%EC%B2%B4/"}]},{"title":"let 과 const","slug":"letAndConst","date":"2018-03-05T22:32:46.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/03/05/letAndConst/","link":"","permalink":"https://tuhbm.github.io/2018/03/05/letAndConst/","excerpt":"let과 const과거 ES5이하에서는 변수를 선언할때 아래와 같은 방식을 사용하였다. 123var a = 1;var b = 2;var c = a + b; 이러한 선언 방식은 javascript에게 유연함을 선물해 준 대신, 타언어를 공부한 많은 개발자들에게 혼란을 초래 했다.2015년 ECMAscript2015 또는 ES6로 자바스크립트가 변화하면서, 많은 혼란을 조금을 달래줄 수 있었다. 오늘은 ES6의 변수 선언방식인 let과 const에 대해 알아보겠다.과거 javascript의 변수를 var로 선언하였을때 함수스코프, 호이스팅 등 많은 자유로움으로 인해 작은 문제가 큰문제로 발생하는 경우가 많았다. ES6의 변수 선언방식인 let과 const는 block-scope로 스코프범위를 일반적인 다른 언어들과 맞추었다.예를 들어보자.","text":"let과 const과거 ES5이하에서는 변수를 선언할때 아래와 같은 방식을 사용하였다. 123var a = 1;var b = 2;var c = a + b; 이러한 선언 방식은 javascript에게 유연함을 선물해 준 대신, 타언어를 공부한 많은 개발자들에게 혼란을 초래 했다.2015년 ECMAscript2015 또는 ES6로 자바스크립트가 변화하면서, 많은 혼란을 조금을 달래줄 수 있었다. 오늘은 ES6의 변수 선언방식인 let과 const에 대해 알아보겠다.과거 javascript의 변수를 var로 선언하였을때 함수스코프, 호이스팅 등 많은 자유로움으로 인해 작은 문제가 큰문제로 발생하는 경우가 많았다. ES6의 변수 선언방식인 let과 const는 block-scope로 스코프범위를 일반적인 다른 언어들과 맞추었다.예를 들어보자. 1234567console.log(a); // undefinedvar a = 1;console.log(a);1&#123; var a = 2;&#125;console.log(a); //2 이처럼 var로 선언한 변수는 블록스코프 규칙을 따르지 않는다. let의 경우를 살펴보자. 123456789console.log(a); //Uncaught ReferenceError: a is not define. - 선언되지 않은 함수로써 호이스팅이 되지않아 실행조차 되지 않는다.//위에 콘솔이 없다는 가정하에 계속 진행해보겠다.let a = 1;console.log(a); //1&#123; let a = 2; console.log(a); //2&#125;console.log(a); //1 이처럼 &#123; &#125;블록스코프로 인해 블록안에 변수만 2로 재할당 된것을 볼 수 있다. 또한, 중복 선언도 금지되어있다. 123456var a = 1;var b = 2; //2let b = 1;let b = 2; //Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declaredb = 2; //2 같은 스코프 내에서 let은 재선언이 불가능하다. let과 const의 차이ES6의 변수인 let과 const의 차이는 바로 할당에 있다.위의 경우에 let은 재선언이 불가능 하였지만, 재할당은 가능함을 볼 수 있었다.하지만 const는 상수로 재할당이 불가능하다. 1234const a; //Uncaught SyntaxError: Missing initializer in const declarationconst a = 1;const a = 2; //Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declareda = 3; //Uncaught TypeError: Assignment to constant variable. 이처럼 상수 const는 할당 그리고 재선언도 불가능하다. 그리고 특이한점은 const를 사용하여 선언시 할당이 불가능하므로, 선언과 동시에 할당을 해야합니다. let과 const의 사용let과 const의 특징에 대해 알아보았다. 그렇다면 언제 사용할까? let은 재할당이 가능하다. 그러므로 원시형자료인 string, number, bloolean, null, undefined에 사용하고,const는 재할당이 불가능하므로, array, Object등 참조형자료인경우 사용한다. 왜냐하면 const는 immutable하지만 프로퍼티의 할당 및 재할당은 가능하다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"scope","slug":"scope","permalink":"https://tuhbm.github.io/tags/scope/"},{"name":"ES6","slug":"ES6","permalink":"https://tuhbm.github.io/tags/ES6/"},{"name":"var","slug":"var","permalink":"https://tuhbm.github.io/tags/var/"},{"name":"let","slug":"let","permalink":"https://tuhbm.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://tuhbm.github.io/tags/const/"}]},{"title":"Reflow와 Repaint","slug":"reflowAndRepaint","date":"2018-02-22T22:56:50.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/02/22/reflowAndRepaint/","link":"","permalink":"https://tuhbm.github.io/2018/02/22/reflowAndRepaint/","excerpt":"이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. Reflow와 Repaint지금 이후 편하게 한국어로 리플로우 &amp; 리페인트 로 표현하도록 하겠습니다.","text":"이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. Reflow와 Repaint지금 이후 편하게 한국어로 리플로우 &amp; 리페인트 로 표현하도록 하겠습니다. 리플로우와 리페인트 웹을 만드는 개발자로써 많이 들어본 내용일 것이다.이름만 들어로 리(Re)로 시작하는 하는 것이 뭔가 다시한다는 것 같다.위키를 살펴보니 Re- 로 시작하는 단어들은 다시 또는 반복, 되돌리다의 뜻을 더한 접두사로 정리되어 있다.리핏(repeat), 리턴(return), 리액션(reaction)등 우리가 아는 모든 단어가 위키에서 정리한대로 반복 또는 다시등의 뜻을 갖고 있다.이중 우리가 리플로우(reflow) &amp; 리페인트(repaint)에 관심을 갖어야 하는 이유는 우리는 웹개발자이기 때문이다.먼저 플로우와 페인트는 우리가 만든 웹문서를 브라우저에서 렌더링할때 발생한다.렌더링 과정은 이전에 1편과 2편으로 나누어서 포스팅했었다.(모르시는 분들을 위해 친절히 링크를 걸어두었습니다.) 그때의 보았던 그림을 통해 살펴보자그림은 친히 한글로 써있다. 렌더트리가 보이는가?렌더트리의 위쪽 그리고 오른쪽에 각각 배치와 그리기가 있다.저것이 바로 플로우와 페인트이다.이제 리플로우와 리페인트에 대해 알아보자. Reflow리플로우는 플로우가 다시 반복된다는 뜻이다. 위에서 살펴본 그림으로 보면 배치 === 플로우이다.배치라고 해서 위치를 뜻하는 것은 아니다.플로우 과정은 돔트리를 구성한 후에 스타일을 합쳐 렌더트리의 과정에서 크기, 위치등을 담당한다.각각 문서의 위에서 아래로 그리고 왼쪽에서 오른쪽으로 문서를 읽어가면서 필요한 부분에 대해 서버와 통신을 한후에 DOM트리 + 스타일을 합치고,이를 표현하기위한 렌더트리를 구성하는 과정에서 display 그리고 width, height, position 등을 계산하는 과정이다. 리플로우는 이과정을 다시 거치는 것을 말한다.Javascript를 통해 어떠한 이벤트가 발생하였을 경우,예를 들면 팝업노출 또는 슬라이드조작등 Javascript를 통한 UI를 변경 또는 이동하는 과정에서 리플로우가 발생한다. Repaint리페인트 역시 페인트가 다시 일어나는 과정이다. 위그림에서는 그리기 === 페인트이다.페인트는 다시 그린다는 뜻이다.위에 렌더트리과정에서 플로우를 통해 계산한 것을 그리는 과정이 바로 페인트이다.그리는 것은 실제 웹에 보여주는 것을 말한다. 계산된것을 웹브라우저에 ‘표현한다’는 것이 더 좋은 것 같다.색깔, 보더, 형태 등등을 우리가 보는 뷰의 형태로 표현하는것이다. 즉 리페인트는 리플로우로 인해 계산된 것을 다시 그리는 것이다. 우리가 Reflow 와 Repaint에 관심을 갖어야 하는 이유우리 웹개발자의 역량은 과거에는 단순 보여주는 것을 중심으로 두었었다.반면 현대에 들어서 웹개발자의 역량은 성능 최적화된 웹페이지를 만드는 것에 중점을 두고있다.물론 자사서비스가 아니고, 타사의 웹서비스를 만드는 곳은 속도라는 예외가 있긴하다. 하지만 자사의 서비스를 만드는 회사는 성능 최적화에 우선을 둬야한다.예를 들어 쇼핑몰을 렌더링하는데 5초의 시간이 걸린다고 해보자.같은 제품을 여러회사들이 나눠팔고 가격은 같다.여러분들이라면 어느곳을 택하겠는가? 당연히 소비자에게 불편함 없이 빨리 보여지는 페이지에 초점을 둔다.심지어 렌더링 과정에서 Javascript로 인한 기능이 보여지기 이전에 눈속임으로 뷰단을 이미지로 보여주는 회사도 보았었다.이처럼 성능 최적화에 중점을 둬야한다. 그렇기 위해서는 빠른 렌더링을 위해 여러 방법이 있지만, 리플로우와 리페인트를 최대한 줄이는 것이 성능 최적화의 좋은 방법이다.그래서 우리 웹개발자는 리플로우와 리페인트를 줄이는 방법에 대해 공부해야만한다","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tuhbm.github.io/tags/javascript/"},{"name":"rendering","slug":"rendering","permalink":"https://tuhbm.github.io/tags/rendering/"},{"name":"reflow","slug":"reflow","permalink":"https://tuhbm.github.io/tags/reflow/"},{"name":"repaint","slug":"repaint","permalink":"https://tuhbm.github.io/tags/repaint/"},{"name":"렌더링","slug":"렌더링","permalink":"https://tuhbm.github.io/tags/%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"name":"렌터트리","slug":"렌터트리","permalink":"https://tuhbm.github.io/tags/%EB%A0%8C%ED%84%B0%ED%8A%B8%EB%A6%AC/"},{"name":"리플로우","slug":"리플로우","permalink":"https://tuhbm.github.io/tags/%EB%A6%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/"},{"name":"리페인팅","slug":"리페인팅","permalink":"https://tuhbm.github.io/tags/%EB%A6%AC%ED%8E%98%EC%9D%B8%ED%8C%85/"}]},{"title":"프로그래머 첫걸음","slug":"firstProgramming","date":"2018-02-21T21:51:20.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/02/21/firstProgramming/","link":"","permalink":"https://tuhbm.github.io/2018/02/21/firstProgramming/","excerpt":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 프로그래머 첫걸음 한줄평 리뷰책 제목처럼 비전공자가 처음 프로그래밍을 배울때 보면 좋은도서다.","text":"이 카테고리는 책을 읽고, 느낀점에 대해 리뷰를 남기는 카테고리입니다. 프로그래머 첫걸음 한줄평 리뷰책 제목처럼 비전공자가 처음 프로그래밍을 배울때 보면 좋은도서다. 책정보 판매처: 한빛출판네트워크저자 : 코리 알트호프번역 : 한선용출간 : 2018-01-02페이지 : 404 쪽가격 : 정가 19,800원 -&gt; 판매가 17,8200원(10% off) 상세정보 네이버 북스 한빛출판네트워크 소개보통 많은 책들이 프로그래밍을 처음 시작하는 초심자들에게 쉽게 설명한다고 쓴다. 하지만 정작 읽어보면 그 언어에 대해 쉽게 설명한 책이 대부분이다.하지만 이책은 조금 달랐다. 비록 파이썬을 언어로 사용하여, 설명하긴 하지만 모든 언어에 공통적으로 갖고 있는 개념들에 대해 설명하고, 또한 그것을 실습으로 옮겨낸다.어떤 한 언어에만 초점을 두고 있지 않는 것이 다른 책들과의 차별성이라고 생각된다. 장점 앞서 말한바와 같이 하나의 언어를 설명을 초점으로 하지 않고, 실무에서 접해볼 프로그래밍 언어들의 공통적인 개념들에 대해 보다 쉽게 설명하였다. 마지막엔 프로그래밍에 대한 설명 뿐만아니라, 본인의 경험도 설명하며 좋은 프로그래머가 되기위한 조언들을 저술하였다. 집중력이 떨어질만한 시점에 좋은 내용으로 기억에 남는다. 단점 비전공자들에 초점을 두었기 때문에 전공자들에게는 비적합하다고 생각된다. 모든 개발서적과 마찬가지로 긴 코드를 눈으로 읽기가 힘들었다. E-BOOK이 아니라 출퇴근시간에 읽기 힘들었다. 비전공자의 프로그래밍리뷰를 쓰고 있는 필자는 비전공자이다. 그렇기 때문에 실무에서 들어봤을만 하지만 정확히 알고 있지 못한 개념에 아쉬움을 느꼈었다.물론 책에 있는 내용들은 검색을 해보면 모두 나와있는 내용이다. 하지만 키워드를 통해 이해하고, 어려 프로그래머의 명언들을 각 단에 시작부분에 써 놓으므로써조금 섬뜩할 수 있는 조언들을 통해 재미를 주는 부분도 포함되어 있다.비록 내가 주로 하고있는 언어와는 다르게 파이썬을 통해 프로그래밍에 대한 개념을 설명하였지만, 충분히 이해 할 수 있을정도로 쉽게 저술하였다. 후기모든 개발 서적을 끝까지 읽어본적이 없다. 초반에 집중을 후반으로 갈수록 어려워져 집중력이 떨어지고 버거움을 느꼈다. 하지만 이책은 비전공자들을 대상으로 한만큼 최대한 쉽게 표현하려고 애쓴 저자의 노력이 보이는 책이었다.그리고 후반에 집중력이 떨어질때 쯤 나오는 좋은 프로그래머가 되기 위한 조언을 보고 있자니 마치 책에서 나온 멘토를 하나 두고, 책에서 조언한 내용들을 &#39;꼭 해야겠다&#39; 다짐하였다.조언 또한 어려운것들이 아니고, 쉽게 해낼 수 있는 조언들을 담고 있다. 앞으로의 Hello Coding 시리즈가 기대되는 책이었다. 이 서평은 한빛비디어를 통해 제공받은 서적을 토대로 작성된 리뷰입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"book","slug":"공부/book","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/book/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"book-review","slug":"book-review","permalink":"https://tuhbm.github.io/tags/book-review/"},{"name":"python","slug":"python","permalink":"https://tuhbm.github.io/tags/python/"},{"name":"non-major","slug":"non-major","permalink":"https://tuhbm.github.io/tags/non-major/"},{"name":"first-programming","slug":"first-programming","permalink":"https://tuhbm.github.io/tags/first-programming/"},{"name":"start","slug":"start","permalink":"https://tuhbm.github.io/tags/start/"},{"name":"북리뷰","slug":"북리뷰","permalink":"https://tuhbm.github.io/tags/%EB%B6%81%EB%A6%AC%EB%B7%B0/"},{"name":"프로그래머","slug":"프로그래머","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/"},{"name":"파이썬","slug":"파이썬","permalink":"https://tuhbm.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"비전공자","slug":"비전공자","permalink":"https://tuhbm.github.io/tags/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90/"}]},{"title":"CSS - Resetting VS Normalize","slug":"cssReset","date":"2018-02-21T21:00:04.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2018/02/21/cssReset/","link":"","permalink":"https://tuhbm.github.io/2018/02/21/cssReset/","excerpt":"Resetting과 Normalize최근 외국의 한 블로거를 통해 작업 전 기본적으로 브라우저별 태그에 대한 기본 스타일링을 제어하는 두가지 방법을 비교한 글을 본적 있다.하지만 국내에서는 대부분 front-end개발의 아버지로 칭하는 Eric Meyer의 Reset.css를 사용하거나,yahoo가 내놓은 Reset.css를 사용 또는 국내 IT대기업인 네이버나 다음의 reset.css를 사용한다.그리고 본인의 입맛에 맞춰 커스터마이징하여 사용한다. 필자는 다음의 reset.css를 커스터마이징해서 사용한다.이처럼 국내에서는 아직 Normalize보다는 Resetting을 하는 추세이다.일단 Resetting은 대충 사용해보았기때문에 알 것 같은데 Normalize는 무엇인가를 정확히 설명 할 수 없을 것이다.그럼 Resetting과 Normalize에 대해 알아보자","text":"Resetting과 Normalize최근 외국의 한 블로거를 통해 작업 전 기본적으로 브라우저별 태그에 대한 기본 스타일링을 제어하는 두가지 방법을 비교한 글을 본적 있다.하지만 국내에서는 대부분 front-end개발의 아버지로 칭하는 Eric Meyer의 Reset.css를 사용하거나,yahoo가 내놓은 Reset.css를 사용 또는 국내 IT대기업인 네이버나 다음의 reset.css를 사용한다.그리고 본인의 입맛에 맞춰 커스터마이징하여 사용한다. 필자는 다음의 reset.css를 커스터마이징해서 사용한다.이처럼 국내에서는 아직 Normalize보다는 Resetting을 하는 추세이다.일단 Resetting은 대충 사용해보았기때문에 알 것 같은데 Normalize는 무엇인가를 정확히 설명 할 수 없을 것이다.그럼 Resetting과 Normalize에 대해 알아보자 Restting우리가 주로 사용하는 Resetting을 알아보자. 위에서 언급한 바와 같이 *Reset.css*를 사용한다.왜 멀쩡한 브라우저를 reset할까? 초심자들은 의문을 갖을 수 있다. 하지만 상급자 또는 동료가 하기 때문에 자연스럽게 복사 붙여 넣기를 하여 작업을 시작한다.필자는 이런 초심자들이 궁굼해 할만한 내용 찝찝한 등을 긁어주고자 한다. 고수들은 그냥 지나 쳐도 좋다.본론으로 들어가서 왜 reset을 할까? 우리의 주 업무는 성능쪽에도 관심을 둬야하지만, 일단 front 즉 보이는 부분을 담당한다.하지만 기본적으로 브라우저는 각 브라우저별로 각각의 태그에 대한 기본 스타일링이 되어있다.특히 우리의 적 익스플로러는 심하게 버전별로 차이가 있다. 이처럼 브라우저별로 각가 태그에 대한 기본 스타일링이 다르기 때문에, 기본적인 것들은 초기화해서 사용합니다.그래야지 우리가 생각하는 브라우저별 최대한 비슷한 흡사한 웹페이지를 작성할 수 있습니다. NormalizeNormalize는 기존의 브라우저별 스타일을 모두 리셋시키는 방법이 아니라이를 유지하고, 이용하려는 스타일링 방법입니다.브라우저 크롬과 사파리의 비교입니다.스타일 크롬과 사파리의 비교입니다. 이처럼 Normalize는 기존에 있던 부분을 이용하되, 최대한 훼손시키지 않고, 이용하는 방법을 사용하고 있습니다. 장점과 단점이처럼 CSS를 작업하기전에 설정하는 각 방법에 따라 장점과 단점이 존재합니다. Restting 장점 익숙하다 현재 우리나라에서는 초기화하는 방법을 많이 사용하므로 익숙합니다. 익숙하므로써 작업의 속도 측면에서 고려할 부분이 존재 하지 않기 때문에 작업 속도는 빠를 수 있습니다. 다른부분에 신경을 쓰지 않아도 된다. 만약 잘못 쓰고 있는 Restting일 경우 예상치 못한 변수가 등장합니다. 하지만 모든것을 제대로 Restting하였다면, 고려해야 할 변수가 적습니다. 단점 코드의 복잡성 Restting을 하면 우선순위에 따라 또한 상위 또는 하위에 작성했느냐에 따라 스타일이 달리 적용 될 수 있습니다. 최근 업데이트가 없다. 브라우저는 지속적으로 업데이트 되고 있습니다. 또한 코드는 언제나 변하죠. 하지만 Normalize처럼 대표적으로 한가지 방법을 사용하는 것과 달리, 앞서 언급한대로 Restting을 하는 방법은 다양합니다. Normalize 장점 코드의 간결함 Normalize는 리셋과 달리 기존 코드를 유지하고, 이용한다는 측면에 있어서 코드의 우선순위등의 측면에서 충돌이 일어날 가능성이 적습니다. 지속적인 업데이트 Restting과 다르게 최근에 v8.0이 나오고 github를 운영하여, 지속적인 업데이트를 거치고 있습니다. 단점 어색함 국내 많은 개발자들은 Restting을 사용해 왔기 때문에, 어색하고 새롭습니다. 그렇기에 생각지 못한 디자인 오류가 발생할 수 있습니다. 하지만 익숙해지면 괜찮을것으로 판단 됩니다. 정리정리하자면, 현재 국내의 개발자들은 Restting을 이용해 초기화하여 작업한 경우가 많기 때문에, 익숙합니다.하지만 최근에 해외에서는 Normalize를 통해 코드를 효율적으로 작성하는데 초점을 두고 있는 것 같습니다. 정답은 없습니다.각자 원하는 방법으로 효율적으로 작업하면 됩니다.하지만 개발자로써 이러한 방법이 있으니 실무에서 까지는 아니더라도 한번 사용해보는 것을 추천드립니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"}],"tags":[{"name":"reset","slug":"reset","permalink":"https://tuhbm.github.io/tags/reset/"},{"name":"normalize","slug":"normalize","permalink":"https://tuhbm.github.io/tags/normalize/"},{"name":"ie","slug":"ie","permalink":"https://tuhbm.github.io/tags/ie/"},{"name":"chrome","slug":"chrome","permalink":"https://tuhbm.github.io/tags/chrome/"},{"name":"firefox","slug":"firefox","permalink":"https://tuhbm.github.io/tags/firefox/"},{"name":"safari","slug":"safari","permalink":"https://tuhbm.github.io/tags/safari/"}]},{"title":"python2","slug":"python2","date":"2018-02-14T22:41:49.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/02/14/python2/","link":"","permalink":"https://tuhbm.github.io/2018/02/14/python2/","excerpt":"Python이 카테고리는 파이썬 공부를 하며, 익힌 내용을 기록합니다.책을 보며, 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 파이썬 2편","text":"Python이 카테고리는 파이썬 공부를 하며, 익힌 내용을 기록합니다.책을 보며, 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 파이썬 2편 파이썬 문법파이썬의 기본 문법은 들여쓰기로 구분이 됩니다.자바스크립트는 &#123;&#125;의 블록 형태로 또는 ()처럼 함수의 호출 등 괄호를 통해 문법을 구분하였습니다.또는 실수를 하지 않도록 ;을 통해 마침을 지었습니다. 그렇기에 자바스크립트 진영에서 minify을 하여도 문제가 되지 않았습니다.그리고 ;도 문자이므로 세미콜론을 쓰지말아야한다 VS 안정감을 위해 써야한다라는 식의 논란이 있을정도로 구분이 쉬웠습니다. 하지만 우리가 앞으로 배워나갈 파이썬은 들여쓰기로 문법을 나눕니다.예를 들어보겠습니다. 12345678 x = 2 y = 4 &quot;&quot;&quot;이렇게 작성하면,IndentationError: unexpected indent 에러가 발생합니다.&quot;&quot;&quot;이처럼 파이썬은 문법 구분을 할 때 들여쓰기를 기준으로 사용합니다. 나중에 또 설명드리겠지만 함수를 예로 들면 12def sum(x,y): return x + y 이런식으로 함수의 내용은 들여쓰기를 통해 입력을 합니다. 에러와 예외파이썬의 에러 형태는 두가지 입니다. 문법에러와 예외입니다.예를 들어 어떤 숫자를 0으로 나누려 할때 일어나는 ZeroDivisionError는 예외에 해당됩니다. 문법에러는 치명적이지만, 예외는 프로그램이 계속 실행되도록 만들 수 있는 에러입니다. 산술 연산자자바스크립트와 마찬가지로 파이썬도 연산을 할 수 있습니다.모든 산술 연산자가 같지만 다른점이 몇가지가 있습니다.그 중 한가지는 //연산자입니다. 자바스크립트에는 //연산자가 존재하지 않습니다.지금부터 //연산자의 예제를 보겠습니다. 12313 // 5 # 211 // 8 # 110 // 3 # 3 위 결과를 통해 추측이 되나요?바로 정수 나누셈의 몫을 얻는 연산자입니다.숫자는 정수만 있는 것이 아니라 소수도 있습니다.하지만 //연산자는 나누기인데 정수의 몫을 구하는 연산자입니다. 그리고 나머지 한가지는 제곱 연산자입니다.예제를 보겠습니다. 1234# 마크다운에서는 **이 표현되지 않아 제곱으로 표현합니다.2 ** 2 # 43 ** 2 # 94 ** 1 # 4 바로 제곱의 수를 구합니다.2 제곱 2 는 2 X 2와 같고3 제곱 2 는 3 X 3과 같습니다.그럼 4 제곱 4은 무엇일까요. 바로 4 X 4 X 4 X 4입니다 이처럼 자바스크립트의 기본적인 연산 뿐만 아니라,추가적인 산술 연산자를 알아보았습니다. 논리 연산자자바스크립트의 논리 연산자에는 &amp;&amp;, ||, !이 있습니다.하지만 파이썬에서는 더 쉽게 영어로 표현합니다.and, or, not으로 논리 연산자를 사용합니다.예를 들어 사용해보면, 1231 == 1 and 2 == 2 # 자바스크립트 1 == 1 &amp;&amp; 2 == 23 == 3 or 4 == 4 # 자바스크립트 3 == 3 || 4 == 4not5 == 6 # 자바스크립트 !5 == 6 이렇게 사용합니다. 이번시간에는 파이썬의 문법, 에러, 연산자를 알아보았습니다.다음시간에는 조건문, 함수, 반복문을 알아보겠습니다. 즐거운 명절 보내세요.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Python","slug":"공부/Python","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://tuhbm.github.io/tags/python/"},{"name":"파이썬","slug":"파이썬","permalink":"https://tuhbm.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"indentationError","slug":"indentationError","permalink":"https://tuhbm.github.io/tags/indentationError/"},{"name":"문법","slug":"문법","permalink":"https://tuhbm.github.io/tags/%EB%AC%B8%EB%B2%95/"},{"name":"들여쓰기","slug":"들여쓰기","permalink":"https://tuhbm.github.io/tags/%EB%93%A4%EC%97%AC%EC%93%B0%EA%B8%B0/"},{"name":"논리연산자","slug":"논리연산자","permalink":"https://tuhbm.github.io/tags/%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"에러","slug":"에러","permalink":"https://tuhbm.github.io/tags/%EC%97%90%EB%9F%AC/"},{"name":"예외","slug":"예외","permalink":"https://tuhbm.github.io/tags/%EC%98%88%EC%99%B8/"},{"name":"산술연산자","slug":"산술연산자","permalink":"https://tuhbm.github.io/tags/%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0%EC%9E%90/"}]},{"title":"python 시작하기","slug":"startPython","date":"2018-02-12T21:17:35.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/02/12/startPython/","link":"","permalink":"https://tuhbm.github.io/2018/02/12/startPython/","excerpt":"Python이 카테고리는 파이썬 공부를 하며, 익힌 내용을 기록합니다.책을 보며, 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 파이썬(python) 시작하기파이썬을 시작하게된 계기한빛미디어의 ‘나는 리뷰어다.’ 라는 이벤트가 있습니다.한빛미디어에서 신청을 받아 3가지의 선택한 책중 1권을 랜덤으로 보내주는데,그 책을 읽고, 기간내에 책에 대한 리뷰를 블로그 및 온라인 서점 등에 리뷰를 작성하는 이벤트입니다.그래서 받게 된 책이 &#39;비전공자가 궁굼해하는 프로그래머의 첫걸음&#39;입니다.이 책은 프로그래밍의 내용을 요즘 HOT하다는 파이썬이란 언어 통해 프로그래밍에 관련된 내용을 전달합니다.책을 반정도 읽다보니, 파이썬을 공부해 포스팅하는것도 좋겠다라는 생각이 들어 파이썬 공부를 시작하게 되었습니다.다만, 제가 주로 사용하는 언어가 아닌 만큼 포스팅에 다소 시간이 걸릴 수 있습니다.","text":"Python이 카테고리는 파이썬 공부를 하며, 익힌 내용을 기록합니다.책을 보며, 독학을 하므로 잘못된 내용이 있으면 댓글 또는 메일주시면 신속히 오류처리하겠습니다. 파이썬(python) 시작하기파이썬을 시작하게된 계기한빛미디어의 ‘나는 리뷰어다.’ 라는 이벤트가 있습니다.한빛미디어에서 신청을 받아 3가지의 선택한 책중 1권을 랜덤으로 보내주는데,그 책을 읽고, 기간내에 책에 대한 리뷰를 블로그 및 온라인 서점 등에 리뷰를 작성하는 이벤트입니다.그래서 받게 된 책이 &#39;비전공자가 궁굼해하는 프로그래머의 첫걸음&#39;입니다.이 책은 프로그래밍의 내용을 요즘 HOT하다는 파이썬이란 언어 통해 프로그래밍에 관련된 내용을 전달합니다.책을 반정도 읽다보니, 파이썬을 공부해 포스팅하는것도 좋겠다라는 생각이 들어 파이썬 공부를 시작하게 되었습니다.다만, 제가 주로 사용하는 언어가 아닌 만큼 포스팅에 다소 시간이 걸릴 수 있습니다. 파이썬 설치하기파이썬은 공식 홈페이지를 통해 설치가 가능합니다.저는 과거 버전인 2.x 버전이 아닌 3.x의 버전을 통해 공부를 시작하겠습니다.공식홈페이지를 통해 다운을 받고 나면 일반적인 프로그램을 설치하는것처럼 설치를 합니다. 파이썬 터미널파이썬은 일반적인 CMD 또는 터미널을 통해 작성(따로 PATH) 설치시 파이썬 사용이 가능하다.하지만 파이썬을 설치시 자동으로 설치되는 IDLE라는 파이썬 전용 터미널을 이용하는 것이 PATH문제의 측면에서 좋다고 생각합니다. Hello world!12print (&#x27;Hello world!&#x27;)#Hello world! 출력 &#39;Hello world&#39;는 프로그래밍을 배우는 개발자들이 가장 먼저 출력해 보는 예제입니다.파이썬 세계에 오신것을 환영합니다. 주석달기파이썬은 그동안 우리가 자바스크립트를 하면서 달아왔던 주석과는 조금 형태가 다릅니다.자바스크립트에서는 12345// 한줄주석/* 여러줄 주석 */ /** * 다른형태의 여러줄 주석 */ 이런 형태의 주석을 사용했습니다. 하지만 파이썬에서는 1234#파이썬 한줄주석달기&quot;&quot;&quot;파이썬 멀티주석&quot;&quot;&quot; 이런 형태로 주석을 사용합니다. 다음포스팅부터는 제가 기존에 알고 있던 자바스크립트와 파이썬을 비교하며,공부를 진행하며 포스팅하겠습니다. Hello python!!","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Python","slug":"공부/Python","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://tuhbm.github.io/tags/python/"},{"name":"start","slug":"start","permalink":"https://tuhbm.github.io/tags/start/"},{"name":"파이썬","slug":"파이썬","permalink":"https://tuhbm.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"파이썬 시작","slug":"파이썬-시작","permalink":"https://tuhbm.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%8B%9C%EC%9E%91/"}]},{"title":"스레드(thread)","slug":"thread","date":"2018-02-06T21:43:00.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/02/06/thread/","link":"","permalink":"https://tuhbm.github.io/2018/02/06/thread/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 스레드(thread)한글로 스레드라 표기하겠습니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 스레드(thread)한글로 스레드라 표기하겠습니다. 자바스크립트를 포함 여러 개발 서적 또는 웹문서들을 읽다 보면, 굉장히 많이 나오는 용어 중 하나이다.스레드….싱글스레드….멀티스레드….도대체 스레드란 무엇인가?위키를 통해 스레드를 알아보자.정리를 하면 프로그램 내에서 프로세스가 실행되는 흐름의 단위이다. 그렇다면 프로세스는 무엇인가?프로세스는 소프트웨어가 실행되는 작업단위이다. 이말인즉, 프로그램(소프트웨어) &gt; 프로세스 &gt; 스레드 라고 보면 이해하면 된다.스레드가 모여 프로세스가 되고, 프로세스가 모여 하나의 프로그램이 된다. 자바스크립트의 스레드각 언어별 특이한 사항들이 있다.자바스크립트의 특징은 싱글스레드라는 것이다. 싱글스레드싱글스레드는 말 그대로 하나의 직렬로 처리하는 스레드 방식이라는 것이다.이말인 즉 하나의 요청이 있으면 하나를 처리할때까지 다음 요청은 대기상태라는것이다.하나씩만 실행 할 수 있다.라는 뜻이다. 물론 자바스크립트에서도 멀티스레드 비슷한 방식으로 처리 하기위해 WebWork를 사용하면 된다.멀티스레드는 여러개의 스레드를 사용한다는 방식인대,실제 한번에 두가지 일을 동시에 병렬로 처리하는 것이 아니라 번갈아 가며 처리하므로써 동시에 작업이 처리되는 것처럼 느끼게 하는 방식이다.이는 채팅을 예로 들면, 상대방의 메시지를 다운 받는 동안 나는 입력을 할 수 없을 경우 멀티스레드를 사용하여 다운과 입력을 동시에 처리하는 것과 같다. 정리해보면 그림과 같다.이미지 참조사이트-LG CNS 결론싱글스레드와 멀티스레드를 사용할때 무작정 사용하는 것이 아니라작업의 효율을 따져보고 직렬로 빠르게 처리해야할 것, 또는 병렬로 다중으로 처리해야할 것을 구분하여상황에 맞게 사용해야 한다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://tuhbm.github.io/tags/thread/"},{"name":"스레드","slug":"스레드","permalink":"https://tuhbm.github.io/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"싱글스레드","slug":"싱글스레드","permalink":"https://tuhbm.github.io/tags/%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"멀티스레드","slug":"멀티스레드","permalink":"https://tuhbm.github.io/tags/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"프로세스","slug":"프로세스","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"}]},{"title":"ThirdParty(서드파티)","slug":"thirdParty","date":"2018-01-26T20:54:28.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/01/26/thirdParty/","link":"","permalink":"https://tuhbm.github.io/2018/01/26/thirdParty/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. Thrid party(서드파티)지금부터 서드파티라 칭하겠습니다.개발을 진행하다 보면, 모르는 부분을 검색을 통해 알아보는 경우가 매우 빈번하다.블로그등을 보다보면 서드파티 라는 용어가 자주 존재하는데, 그뜻을 알아보도록 하자","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. Thrid party(서드파티)지금부터 서드파티라 칭하겠습니다.개발을 진행하다 보면, 모르는 부분을 검색을 통해 알아보는 경우가 매우 빈번하다.블로그등을 보다보면 서드파티 라는 용어가 자주 존재하는데, 그뜻을 알아보도록 하자 일단 용어 검색을 할때는 위키는 먼저 찾아보는데, 위키를 살펴본 서드파티정리를 하면, 제조사 와 소비자 를 연결해주는 회사 또는 제3자라고 볼 수 있다.예를 들면, 게임제조사 와 소비자 를 연결해주는 게임회사(퍼블리싱)의 관계라고 볼 수 있다.중국에 크로스파이어로 성공을 거둔 스마일게이트(게임제조사) 와 유저(중국 사용자)를 이어주는 텐센트(퍼블리싱)같은 예시가 있다. 그렇다면 프로그래밍 개발에서 서드파트란 이야기가 왜 나올까…?프로그래밍 개발을 하다보면, 편하고 효율적인 개발을 위해, 플러그인이나 라이브러리 또는 프레임워크등을 사용한다.예를 들면 프로그래밍 개발과 개발자 사이에 플러그인, 라이브러리, 프레임워크를 서드파티로 볼 수 있다.만약 개발을 완료했다고 한다면, 서비스와 사용자를 이어주는 서드파티는 응용프로그램 or 어플리케이션 or 웹서비스입니다.이처럼 제3자로써 중간 다리의 역할을 하는 것을 서드파티라 합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://tuhbm.github.io/tags/programming/"},{"name":"framework","slug":"framework","permalink":"https://tuhbm.github.io/tags/framework/"},{"name":"library","slug":"library","permalink":"https://tuhbm.github.io/tags/library/"},{"name":"third party","slug":"third-party","permalink":"https://tuhbm.github.io/tags/third-party/"},{"name":"plug in","slug":"plug-in","permalink":"https://tuhbm.github.io/tags/plug-in/"},{"name":"vendor","slug":"vendor","permalink":"https://tuhbm.github.io/tags/vendor/"},{"name":"플러그인","slug":"플러그인","permalink":"https://tuhbm.github.io/tags/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/"},{"name":"라이브러리","slug":"라이브러리","permalink":"https://tuhbm.github.io/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/"},{"name":"프레임워크","slug":"프레임워크","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"}]},{"title":"리터럴이란 무엇일까?","slug":"literal","date":"2018-01-26T19:43:00.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2018/01/26/literal/","link":"","permalink":"https://tuhbm.github.io/2018/01/26/literal/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 리터럴프로그램 개발을 하다보면, 리터럴이라는 단어를 많이 사용한다.먼저 위키를 살펴보자","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 리터럴프로그램 개발을 하다보면, 리터럴이라는 단어를 많이 사용한다.먼저 위키를 살펴보자 리터럴리터럴이란? 소스 코드의 고정된 값을 대표하는 용어이다.고정된 값은 숫자, 문자, 함수 등 더이상 나눌 수 없는 명확하게 데이터를 표현하는 값이다. 예를 들어보자. 12345678const intergerNum = 123; // 정수인 number리터럴const floatingPointNum = 54.5413; // 실수인(소수점) number리터럴const str = &#x27;글자&#x27;; // 문자 리터럴const func = function (a) &#123; return a;&#125; // 함수 리터럴const obj = &#123; x: 123, y : 456&#125; // 객체 리터럴const regex = /[a-z]/; // 정규표현식 리터럴const arr = [1,2,3]; // 배열 리터럴const bool = true; // boolean 리터럴 이와같이 Javascript의 리터럴 종류가 있다.리터럴은 더이상 나눌 수 없는 값이므로(변화가 불가능하다 라는 뜻은 아니다) 변수 선언한다면, const로 선언 해야한다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"값","slug":"값","permalink":"https://tuhbm.github.io/tags/%EA%B0%92/"},{"name":"var","slug":"var","permalink":"https://tuhbm.github.io/tags/var/"},{"name":"let","slug":"let","permalink":"https://tuhbm.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://tuhbm.github.io/tags/const/"},{"name":"리터럴","slug":"리터럴","permalink":"https://tuhbm.github.io/tags/%EB%A6%AC%ED%84%B0%EB%9F%B4/"},{"name":"literal","slug":"literal","permalink":"https://tuhbm.github.io/tags/literal/"},{"name":"상수","slug":"상수","permalink":"https://tuhbm.github.io/tags/%EC%83%81%EC%88%98/"},{"name":"변수","slug":"변수","permalink":"https://tuhbm.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"메모리","slug":"메모리","permalink":"https://tuhbm.github.io/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/"}]},{"title":"SASS에 대해 알아보자2","slug":"sass2","date":"2018-01-24T20:01:13.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/01/24/sass2/","link":"","permalink":"https://tuhbm.github.io/2018/01/24/sass2/","excerpt":"SASSSASS를 통칭 사스 라고 표기하겠습니다.지난 포스팅을 통해 SASS의 확장자가 최종적으로 .scss로 확정되었다고 말씀드렸습니다.이번 포스팅부터는 사스의 문법에 대해 알아보겠습니다. 변수사용변수를 사용하므로써, 한번의 변경으로 사용한 모든 변수의 값을 바꿀 수 있는 효율적인 방법이라고 말씀드렸었습니다.변수를 키와값으로 표현해 보겠습니다. 1$normalFontSize: 14px;","text":"SASSSASS를 통칭 사스 라고 표기하겠습니다.지난 포스팅을 통해 SASS의 확장자가 최종적으로 .scss로 확정되었다고 말씀드렸습니다.이번 포스팅부터는 사스의 문법에 대해 알아보겠습니다. 변수사용변수를 사용하므로써, 한번의 변경으로 사용한 모든 변수의 값을 바꿀 수 있는 효율적인 방법이라고 말씀드렸었습니다.변수를 키와값으로 표현해 보겠습니다. 1$normalFontSize: 14px; 이제 14px은 $normalFontSize에 담겨있습니다.여러가지의 형태로도 담을 수 있습니다.이때 사용하는것이 @mixin입니다.예를 들어보겠습니다.대표적인 예로 우리는 float을 해제 할 때 여러방법이 있지만 가상선택자인 :after를 사용한 클리어 방법을 상황에 따라 사용합니다.이것을 사스로 표현해보겠습니다. 1234567891011121314@mixin afterClear &#123; display: block; content: &#x27;&#x27;; clear: both;&#125;ul &#123; &amp;:after&#123; @include afterClear; &#125; li&#123; float:left; &#125;&#125; 사스에서 CSS의 컴파일 된 코드를 보겠습니다. 123456789ul:after &#123; display: block; content: &#x27;&#x27;; clear: both;&#125;ul li &#123; float: left;&#125; 이처럼 코드 뭉치의 재사용도 가능합니다. 이처럼 선언시에는 @mixin으로 사용할때에는 @include로 사용하는 것을 볼 수 있습니다.또한 123456789101112131415161718192021@mixin setImageMaskRotate &#123; @include setImageMask; @include rotate;&#125;@mixin setImageMask &#123; position: relative; &amp;:after&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; border: 10px solid #000; opacity: 0.2; content: &#x27;&#x27;; &#125;&#125;@mixin rotate &#123; transform: rotate(45deg);&#125; 이처럼 @mixin안에 @mixin을 넣는것 역시 가능합니다.사실 @mixin은 변수의 개념보다는 함수의 개념에 가깝습니다. 이유를 살펴보도록 하겠습니다. 123456789101112131415161718@mixin center($width, $height) &#123; position: absolute; top: 50%; margin-top: - $height / 2; left: 50%; margin-left: - $width / 2; height: $height; width: $width;&#125;.ex_box_1&#123; @include center(100px, 100px); background-color: pink;&#125;.ex_box_2&#123; @include center(300px, 100px); background-color: orange;&#125; 매개변수의 사용이 가능합니다. 컴파일 코드를 보면 1234567891011121314151617181920.ex_box_1 &#123; position: absolute; top: 50%; margin-top: -50px; left: 50%; margin-left: -50px; height: 100px; width: 100px; background-color: pink;&#125;.ex_box_2 &#123; position: absolute; top: 50%; margin-top: -50px; left: 50%; margin-left: -150px; height: 100px; width: 300px; background-color: orange;&#125; 이처럼 매개변수의 값을 통해 연산 또한 가능함을 알 수 있습니다.사스의 기능을 설명 드리려고 하니, 기능이 너무너무 많아서 한번에 다 설명이 힘들어 여러편에 나누어야 할 것 같습니다.다음시간에는 @extend에 부터 설명을 드리겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"},{"name":"SASS","slug":"공부/CSS/SASS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/SASS/"}],"tags":[{"name":"변수","slug":"변수","permalink":"https://tuhbm.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"sass","slug":"sass","permalink":"https://tuhbm.github.io/tags/sass/"},{"name":"scss","slug":"scss","permalink":"https://tuhbm.github.io/tags/scss/"},{"name":"사스","slug":"사스","permalink":"https://tuhbm.github.io/tags/%EC%82%AC%EC%8A%A4/"},{"name":"mixin","slug":"mixin","permalink":"https://tuhbm.github.io/tags/mixin/"},{"name":"include","slug":"include","permalink":"https://tuhbm.github.io/tags/include/"}]},{"title":"SASS에 대해 알아보자1","slug":"sass1","date":"2018-01-24T16:12:13.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/01/24/sass1/","link":"","permalink":"https://tuhbm.github.io/2018/01/24/sass1/","excerpt":"SASSSASS를 통칭 사스 라고 표기하겠습니다.금일은 사스에 대해 알아보겠습니다.우선 컴파일 하는 방법에 대해 지난번 포스팅한 것이 있는데요. 1. scout앱 사용하여 컴파일하기 (지난번 포스팅내용입니다.)2. Ruby를 설치해 Cli를 통해 컴파일하기3. gulp등 Task runner(또는 webpack같은 빌드도구)이용하여 컴파일하기4. prepros 또는 kolal등의 앱사용하기 사스는 이렇게 컴파일 하시면 되겠구요.","text":"SASSSASS를 통칭 사스 라고 표기하겠습니다.금일은 사스에 대해 알아보겠습니다.우선 컴파일 하는 방법에 대해 지난번 포스팅한 것이 있는데요. 1. scout앱 사용하여 컴파일하기 (지난번 포스팅내용입니다.)2. Ruby를 설치해 Cli를 통해 컴파일하기3. gulp등 Task runner(또는 webpack같은 빌드도구)이용하여 컴파일하기4. prepros 또는 kolal등의 앱사용하기 사스는 이렇게 컴파일 하시면 되겠구요. 사스등 CSS 전처리기의 사용 이유우선 전처리기(위키바로가기)란?요약해보면 입력 데이터를 처리하여 다른 프로그램에 대한 입력으로서 사용되는 출력물을 만들어내는 프로그램입니다. CSS는 웹을 구현하는데 스타일을 담당하고 있습니다. 그렇기에 CSS만으로 웹을 정복하겠다는 생각을 가지신분을 없으시겠죠…?CSS는 웹의 스타일을 담당하는 웹에서 필수는 아니지만, 보이는 부분을 처리해주는 중요한 역할을 하고 있습니다. CSS가 없는 웹을 상상해 보셨나요?보신적있으신가요? 대부분 없을테니 보여드리겠습니다.어떤가요. 우리나라의 녹색사이트 입니다.이처럼 CSS로 인해 스타일을 입히는 것은 매우 중요한 작업입니다.물론 모든 회사들이 이부분을 알기 때문에 css를 빼고 웹개발을 진행 할리없습니다.서론이 길었습니다. 현대시대에 웹개발 기술은 지속적인 발전을 이루었습니다.웹에서 돔을 구성하는 HTML도 템플릿화 된 jade 또는 pug등의 방법으로 발전하였고,현재 가장 화두가 되고 있는 Javascript도 각각 라이브러리와 프레임워크등으로 발전하고 있습니다.여기서 발전 === 효율적으로 작업자들이 작업을 할 수 있고, 깊게는 렌더링등의 성능적인 부분에도 영향을 줄 수 있습니다.(성능적인 부분은 문서가 짧아지고 그러므로써.) 개발자들에게 작업을 효율적으로 할 수 있는 일은 참 대단히 반가운 소리입니다.이처럼 CSS도 전처리기를 통해 효율적으로 작업을 할 수 있습니다. CSS 전처리기의 종류 SASS LESS Stylus CssNext PostCSS현존하고 있는 CSS전처리기는 이정도 입니다.각각의 차이는 있지만 변수나 함수등을 사용하여, 코드를 효율적으로 작성 및 관리 할 수 있다는 공통적인 부분은 같습니다. 이제부터 SASS에 대해 본격적으로 알아보겠습니다. SASS의 특징 가장 오래된 역사를 가진 전처리기이다. Ruby 언어를 기반으로 동작한다. 기존 CSS 문법과 호환성이 높다. 함수, 제어문까지 제공하며 완성도 높은 프로그래밍 언어처럼 동작한다. 확장자명이 .SASS 와 .SCSS 로 두가지 방식의 확장자 사용이 가능하다. .SASS와 .SCSS의 차이같은 사스라도 말씀드린 것처럼 .sass와 .scss가 있습니다.차이를 알아보도록 하겠습니다. 123456789101112$normalFont: 14pxheader font-size: $normalFont .container display: block font-size: $normalFont p font-size: $normalFont color: #000 먼저 .sass의 문법입니다.어떤가요? 보시는 바와 같이 괄호가 없습니다.개인적으로는 보기 매우 불편하고, 헷갈릴것 같은 느낌이 듭니다.이처럼 .sass는 &#123;&#125;괄호 대신 들여쓰기등의 공백문자(white space)를 통해 선택자를 구분합니다.지금은 짧은 내용이지만, 내용이 길어지면 더욱 헷갈릴듯 합니다. 그렇게에 사스는 3.0버전부터는 문법이 .scss로 통일되었습니다. 12345678910111213$normalFont: 14px;header &#123; font-size: $normalFont;&#125;.container &#123; display: block; font-size: $normalFont; p &#123; font-size: $normalFont; color: #000; &#125;&#125; 통일된 .scss문법을 보시죠 괄호를 통해 매우 정갈함이 느껴집니다.그런데 혹시 이 간단한 예제에서 CSS와 차이점을 느끼셨습니까?네 맞습니다. $normalFont: 14px;를 지정하고 $normalFont를 호출하여 사용하고 있습니다.이처럼 변수형태로 작성이 가능합니다.에이… 별거아니네… 변수를 무시하시면 안됩니다. Javascript나 다른 언어에서도 사용하고 있는 변수는 매우 중요합니다.지금처럼 몇번 사용하지 않았을 경우 직접 바꿔주거나, 에디터의 찾은 후 변경 같은 기능을 사용하면 됩니다.하지만 10,000번을 사용한 부분이라면 어떨까요…?(여기부분은 마치 자바스크립트를 설명하는 느낌이네요..)변수를 지정한 부분의 1번 수정으로 10,000번 이상 수정해야 할 부분을 변경할 수 있습니다. 그럼 위에 부분을 컴파일 하면 어떻게 나올까요? 1234567891011header &#123; font-size: 14px;&#125;.container&#123; display: block; font-size: 14px;&#125;.container p&#123; font-size: 14px; color: #000;&#125; 이처럼 CSS의 원래 형태로 나오게 됩니다.이러한 사스의 강점은 CSS가 길어지면 길어질 수록 강점을 발휘합니다.잘 사용하면, 1000줄의 CSS를 700줄의 CSS로 줄일 수 있는 CSS전처리기 어떤가요? 다음시간엔 계속해서 사스의 문법에 대해 알아보겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"},{"name":"SASS","slug":"공부/CSS/SASS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/SASS/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://tuhbm.github.io/tags/sass/"},{"name":"compile","slug":"compile","permalink":"https://tuhbm.github.io/tags/compile/"},{"name":"scss","slug":"scss","permalink":"https://tuhbm.github.io/tags/scss/"},{"name":"사스","slug":"사스","permalink":"https://tuhbm.github.io/tags/%EC%82%AC%EC%8A%A4/"},{"name":"전처리기","slug":"전처리기","permalink":"https://tuhbm.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0/"},{"name":"processors","slug":"processors","permalink":"https://tuhbm.github.io/tags/processors/"}]},{"title":"부수효과","slug":"sideEffect","date":"2018-01-22T22:40:55.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/01/22/sideEffect/","link":"","permalink":"https://tuhbm.github.io/2018/01/22/sideEffect/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 부수효과(side effect)부수효과를 좀 있어보이게 사이드이팩트라 쓰겠습니다사이드이팩트란 무엇인가 알아보았다.위키에서의 부수효과(부가작용) 이렇게 정의하고 있습니다.이처럼 원래의 목적과 다르게 다른 효과 또는 부작용이 나는 상태를 지칭합니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 부수효과(side effect)부수효과를 좀 있어보이게 사이드이팩트라 쓰겠습니다사이드이팩트란 무엇인가 알아보았다.위키에서의 부수효과(부가작용) 이렇게 정의하고 있습니다.이처럼 원래의 목적과 다르게 다른 효과 또는 부작용이 나는 상태를 지칭합니다. 프로그래밍 세계에서도 마찬가지입니다.예를 들어보겠습니다. 순수 함수123456function add (a, b) &#123; //순수하게 더하는 함 return a + b;&#125;add(1, 2)//3add(3, 4)//7add(5, 6)//11 add함수는 단순하게 더하기만 하는 함수입니다.매개변수인 a와 b값을 어떠한 영향도 받지 않고, 더하기만 하는 함수입니다.이것을 순수함수(Pure function)이라고 합니다. 순수하지않은 함수순수하지 않은 함수는 부수효과등을 일으키는 함수입니다.예를 보겠습니다. 1234567891011var c = 10;function add (a, b) &#123; return a + b + c;&#125;add(1, 2)//13add(2, 3)//15c = 20;add(1, 2)//23add(2, 3)//25//이처럼 a와 b를 매개변수로 받아 c와 합산하는 함수입니다.//c의 값이 변경되므로써 값이 달라집니다. 이처럼 부수효과가 많을수록, 개발자들에게 예상치 못한 혼란을 줄 수 있습니다.그렇기 때문에 부수효과를 줄이므로써, 인간이 하는 개발에 있어서 좀 더 쉽게 편리하게 개발하자는 취지입니다.이렇게 순수함수를 통해 프로그래밍 하는 것을 함수형프로그래밍(Functional Programming)이라고 합니다. 함수형프로그래밍아직 공부하지 않아 아는내용만 작성 후 추후 포스팅하겠습니다.함수형 프로그래밍은 순수 함수를 통해, 부수효과를 줄이므로써 발생 할 수 있는 이슈를 줄이는 함수 입니다.함수안에 매개변수로 함수를 받아 단순 처리하며, 사이드이팩트를 줄여 순수하게 프로그래밍하는 것입니다. 공부가 부족함을 느끼고, 추후 공부하여 더 살을 붙이도록 하겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"side effect","slug":"side-effect","permalink":"https://tuhbm.github.io/tags/side-effect/"},{"name":"부수효과","slug":"부수효과","permalink":"https://tuhbm.github.io/tags/%EB%B6%80%EC%88%98%ED%9A%A8%EA%B3%BC/"},{"name":"functional programming","slug":"functional-programming","permalink":"https://tuhbm.github.io/tags/functional-programming/"}]},{"title":"VanillaJS","slug":"vanillaJS","date":"2018-01-21T23:42:22.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2018/01/21/vanillaJS/","link":"","permalink":"https://tuhbm.github.io/2018/01/21/vanillaJS/","excerpt":"Vanilla JS지금부터는 Vanilla JS를 편하게 바닐라JS라고 기재하겠다.Javascript를 사용하는 개발자로써, 많은 사람들이 들어 보았을 것이다.필자는 과거 면접에서 이러한 질문을 받은 적이 있다.‘바닐라 JS에 대해 아시나요?’라는 질문을 받았다. 좀 당황스러운 질문이었다.평소 바닐라JS === Javascript라고 생각해 온 상황이서 그런지 더욱 당황스러웠지만…답을했다.‘일반적으로 우리가 사용하고 있는 Javascript라고 합니다.’‘그럼 왜 자바스크립트가 바닐라JS라고 불리는지 아시나요?’ 또 당황스러웠다.(이것이 면접에서 말리는 시초였다.)","text":"Vanilla JS지금부터는 Vanilla JS를 편하게 바닐라JS라고 기재하겠다.Javascript를 사용하는 개발자로써, 많은 사람들이 들어 보았을 것이다.필자는 과거 면접에서 이러한 질문을 받은 적이 있다.‘바닐라 JS에 대해 아시나요?’라는 질문을 받았다. 좀 당황스러운 질문이었다.평소 바닐라JS === Javascript라고 생각해 온 상황이서 그런지 더욱 당황스러웠지만…답을했다.‘일반적으로 우리가 사용하고 있는 Javascript라고 합니다.’‘그럼 왜 자바스크립트가 바닐라JS라고 불리는지 아시나요?’ 또 당황스러웠다.(이것이 면접에서 말리는 시초였다.) 바닐라JS란 무엇인가?바닐라JS에 어원에 대한 내용을 검색하지 못해 바닐라를 통해 추측해보았습니다. 바닐라바닐라라는 단어는 우리 주변에서 많이 사용되고 있는데 대표적인 것이 바닐라 아이스크림입니다. 어원적으로 스페인어 vanilla 는 ‘작은 콩’ 이라는 뜻을 가진 난초과 식물로, 이 단어에는 ‘바닐라, 바닐라 향의’ 의미만 가지는 것이 아니라 ‘평범한, 특별할 것이 없는( ordinary )’ 이라는 의외의(?) 뜻이 있습니다. 프로그래밍으로서의 바닐라바닐라 이처럼 ‘바닐라’라는 단어는 프로그래밍 세계에서 기본적인 기능만 구현해 놓은 상태를 뜻합니다.그러므로 바닐라JS는 새로운 프레임워크 또는 라이브러리가 아닌 순수한 Javascript입니다.실제 바닐라JS 공식사이트를 접속해서 다운받을 수 있다.하지만 정작 파일을 다운받으면 파일 사이즈가 0KB이다. 바닐라JS를 사용하기위해선 별도의 파일이 없다는 것이다.이미 우리의 브라우저에는 바닐라JS가 탑제되어있다.바닐라JS 공식 사이트에는 마치 프레임워크처럼 가볍고 빠른데다가 호화성이 좋다라는 듯의 문구들로 인해 프레임워크나 라이브러리로 오해 할 수 있다.하지만 이말인 즉 나는 ‘순수한 자바스크립트를 사용하면, 가볍고 빠른데다가 호환성이 좋다.’라는 것으로 이해해야 할 것 같다. 현재 외국에서 또는 국내 굴지의 회사에서는 jQuery를 사용하는 프로젝트가 점점 줄어들고 있는 상황이다. 하지만 jQuery를 쓸 수 없으면 어떻게 개발을 할 것인가?필자의 경우 퍼블리셔로 개발에 입문을 했기 때문에 아직 jQuery의 Dom셀렉팅, 이벤트 바인딩, Ajax등에 의존도가 꽤 높은 편이지만, Vue 공부를 통해 필수는 아니라는 것을 깨닫고, 바닐라JS를 공부하는 중이다.바닐라JS 뿐만아니라 ES6, TypeScirpt등 하고 싶은 것이 아직 많다. 결론바닐라JS는 순수한 JavaScript로 프로그램세계에서는 부가기능을 제외한 기본적인 기능만 구현한상태를 부르는 어원이다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tuhbm.github.io/tags/javascript/"},{"name":"VanillaJS","slug":"VanillaJS","permalink":"https://tuhbm.github.io/tags/VanillaJS/"},{"name":"바닐라 JS","slug":"바닐라-JS","permalink":"https://tuhbm.github.io/tags/%EB%B0%94%EB%8B%90%EB%9D%BC-JS/"},{"name":"jQuery","slug":"jQuery","permalink":"https://tuhbm.github.io/tags/jQuery/"},{"name":"Pure Javascript","slug":"Pure-Javascript","permalink":"https://tuhbm.github.io/tags/Pure-Javascript/"}]},{"title":"늦은 2017 회고","slug":"bye2017","date":"2018-01-17T21:31:12.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2018/01/17/bye2017/","link":"","permalink":"https://tuhbm.github.io/2018/01/17/bye2017/","excerpt":"2017년 회고2017년이 가고 2018년 1월이 반쯤 보낸 후, 다시 한번 나를 채찍질 하게 만든 사건을 통해 마음을 다잡고 공부와 블로그 운영을 다짐하며,첫 회고를 쓴다.올해는 유난히 ‘첫, 처음’이란 단어가 어울렸던 한해였다.첫 블로그, 첫 커플해외여행, 첫 에이전시, 첫 기술들등……항상 개발을 하며 느끼는 점은 ‘처음’ 그리고 ‘낯선’ 기술등에 대한 어려움이나 반감이었다.올해 기술들에 대한 반감으로 새로운 기술을 도입하려고 팀원들의 반대로 했으나 실패했었다.필자는 개발자라면, 당연히 더 좋은 기술, 더 좋은 방법이 있다면 그것에 대해 지금 당장 사용을 하지 못하더라도 알아두는것 정도는 해야한다고 생각한다.서론이 길었다. 처음 쓰는 회고라 다른 분들의 회고를 보니 주제를 나눠 이야기 하는 것을 보았다. 나도 그방법을 선택하도록 하겠다.","text":"2017년 회고2017년이 가고 2018년 1월이 반쯤 보낸 후, 다시 한번 나를 채찍질 하게 만든 사건을 통해 마음을 다잡고 공부와 블로그 운영을 다짐하며,첫 회고를 쓴다.올해는 유난히 ‘첫, 처음’이란 단어가 어울렸던 한해였다.첫 블로그, 첫 커플해외여행, 첫 에이전시, 첫 기술들등……항상 개발을 하며 느끼는 점은 ‘처음’ 그리고 ‘낯선’ 기술등에 대한 어려움이나 반감이었다.올해 기술들에 대한 반감으로 새로운 기술을 도입하려고 팀원들의 반대로 했으나 실패했었다.필자는 개발자라면, 당연히 더 좋은 기술, 더 좋은 방법이 있다면 그것에 대해 지금 당장 사용을 하지 못하더라도 알아두는것 정도는 해야한다고 생각한다.서론이 길었다. 처음 쓰는 회고라 다른 분들의 회고를 보니 주제를 나눠 이야기 하는 것을 보았다. 나도 그방법을 선택하도록 하겠다. 개발실력나는 블로그 about에도 써 놓았듯이 비전공자다.(자랑을 하려고 써 놓은것은 아니다.) 비전공자로써 개발을 하면서, 전공자와의 비교는 어찌보면 무리일수도 있다. 하지만 사회는 냉정하다.회사에서 사람을 채용할때 비전공자로써 기대치가 더 낮기 때문에(아무래도 전공자들과 습득속도부터가 다르다고 생각한다.) 회사에서 같은 연봉이면 전공자를 뽑는게 맞다고 생각한다. 회사는 사람을 고용해서 인력에 대한 투자를 한 것 이상으로 수익을 내야 살아 남을 수 있다.그렇기에 비전공자로써의 이점은 전혀 없다고 봐도 무방하다. 비전공자이지만 같은 나이또래의 전공자보다 많은 지식 또는 비슷한 지식과 실력을 지녔다면, 어쩌면 이점이 될지도 모른다.(부단히 노력을 많이 했다는 것을 인정해주므로써…어디까지나 개인적인 생각이다.)비전공자는 그만큼 전공자보다 더~~~~~~ 많은 노력을 해야한다. 인정받기위해 어쩌면 살아 남기 위해….그렇다면 나는 개발실력을 늘리는데 그렇게 많은 노력을 했는가? 나는 올해 나에게 100점 만점의 점수를 준다면, 25점 정도를 주고 싶다.이유는 하고싶은 많은 것들 중 이룬것이 몇가지 존재하기에 더이상 내자신이 비참해지지 않기위해 억지로 25점이라도 주고 싶다.올해 개발자로써 이룬것이라고 하면 몇가지가 있긴하다. 브라우저의 렌더링과정에 대한 이해도우연히 올초에 진행했던 면접에서 느낀점을 통해서 ‘이부분을 공부해야겠다.’라는 생각이 들었다.면접…..신입때부터 시작하면, 면접은 참 많이도 보았다. 10인 미만의 기업부터 3000여명의 직원이 일하는 나름 업계 메이저 기업까지…면접에서 떨어진다고 해서 나는 결코 나쁘게만 생각하는 것은 옳지 못하다고 생각한다. 물론 면접을 통해 내가 입사여부를 가리도록 회사에서 나를 보는 것도 있지만, 나도 회사를 관찰하는 것이 면접과정 중 하나라고 생각한다.면접에서 떨어질 것이라고 면접을 보다보면 ‘feel’이 오는 경우가 있다. 그런경우 보통 낙심하고, 기가 죽어 하려던 말도 다 못꺼내고 오는 경우가 많다. 물론 나도 그 중 하나였다.올해 봤던 면접 중 올초 면접 웹퍼블리셔라는 직군으로 불리우던 프론트쪽에서 마크업과 스타일링 그리고 인터렉션을 담당하는 업무를 진행하던 나는 과거 jQuery를 이용해 ajax로 JSON데이터를 연동한 경력이 있다.그래서일까? 나는 단순 데이터바인딩을 해봤다라는 생각에 프론트엔드개발직군 무식하게 도전을 하였다.(사실 나중에 알게 되었지만…프론트엔드개발자는 해야할것들이 너무 많다…..심하게많다…)그렇게 운이 좋게 70여명 규모에 방송관련 자사서비스를 하는 회사에 면접을 진행하게 되었다. jquery밖에 써보지 않은 나로썬 정말 무모했다. 심하게 무모했다.질문을 받은 순간 나는 ‘아 내수준이아니구나….’라는 생각이 들었다.자기소개를 마치고, 첫 질문은 “렌더링 과정’ 에 대한 질문이었다. 정확히 말하면, ‘효율적인 렌더링을 하기위해서 어떤방법을 사용하고 계신가요?”흠… 이전회사에서 많은 도움을 받았기에 나는 자신있게 대답을 하였다. ‘유지보수를 위해 돔을 최소화하고, 클래스명 규칙등 가이드에 맞춰, 올바른 이미지 포멧을 사용하고, 스프라이트이미지를 사용하는것입니다.’지금 돌이켜 생각해보니 아찔하다. 답변은 “흠…몇개는 적당한 답변인것 같은데…몇개는 작업자를 위한 개발방법적인 부분도 있는 것 같습니다.”라는 답변을 들었다. 거기서부터 말려들기 시작한것 같다.“그럼 답변중에 스프라이트 이미지를 사용하신다고하셨는데, 스프라이트이미지는 왜 쓰신다고 생각하시나요?”사실 올해까지는 이유도 모르고, 현재 네이버나 카카오등의 굵직한 IT기업들에서 사용하니까 사용했다.이러한 답변이 오고 전부 틀렸다. 하지만 어디서 용기가 났는지 틀렸던것에 대한 질문을 하기 시작했다. 그러면서 공부를 위해 추천을 받고, 귀가길에 책을 주문하였다.이렇게 브라우저의 렌더링 과정에 대해 공부하기 시작하고, 과정에대해 조금은 이해(조금인 이유는 네트워크….ㅎㄷㄷ)를 했다. Task RunnerGulp의 실무 사용은 내가 위에 말한 렌더링을 알게 된 후 책을 통해 알게 되었고, 셋팅을 하며 개인적으로 공부를 진행했다.렌더링의 효율성을 위하여, 스프라이트이미지를 만들고, Concat(webpack이 아니니 번들이라고 하지 않겠다.)을 통해 JS파일과 CSS파일등을 효율적으로 사용하기 위해 시작하였다.어느정도 완성이 되었을때, 실무에 적용해보고 싶었다. 그때 당시 처음으로 에이전시 근무 중이었다. 에이전시는 다들 어떤 분위기인지 알것이다. 시간에 쫓겨 공부를 내팽겨치고, 야근과 철야 주말근무를 하며, 낮은 임금을 받는것이 보통의 에이전시라고 생각할 것이다.하지만 내가 다녔던 회사는 그정도는 아니었다. 하지만 업무시간이 빡빡한것은 맞았다. 그렇기에 팀장등에게 작은 사내세미나를 통해 Gulp를 공유하고, 렌더링 과정에 대해 설명하고 싶었다. 그리고 실무에 적용하고 싶었다.결과는 실패….. 기존의 것이 아닌 새로운것을 배우고 습득하는데 걸리는 시간이 문제였다.하지만 포기 하지 않았다. 왜냐하면 이직 후 도입했기 때문이다. 현재 회사에서 사용하고 있다. 이렇게 크게 보면 두가지정도의 목표를 이루었기 때문에 나는 25점을 주고싶다. 올해는 조금 더 세심하게, 조금 더 Deep하게 공부하겠다 독서 &amp; 세미나 &amp; 스터디누구나 나의 독서하는 습관을 보면 혀를 찰것이다. 하지만 정작 나만 몰랐다. 나의 문제를…올해 본책은 총 14권정도 그중 개발서적은 12권이나 된다. 누가보면 ‘왜 혀를 찬다는거지’라고 생각을 할 수 있다.문제는 어렵고 이해가 가지 않는다 싶으면, 따분함을 못참고 다른 책으로 갈아타버린다.세미나 또한 마찬가지 일것이다. 올해 참석한 세미나만 해도 약 10개정도는 다녀왔다.스터디…또한 7개는 참여했다. 하지만 복습을 하지 않아 전부 까먹어버렸다.위에서 말한것처럼 나는 ‘트랜드!!!’라는 것을 매우 중요시해서 이책을 보다가 저것도 공부해야지 하고 저책을 보다가…세미나도 이것듣고 저것듣고, 스터디도 이것하고, 저것하고이런식으로 여러마리 토끼를 잡기위해 이리 뛰고 저리 뛰고 뛰어만 다녔다. 정작 그러다가 한마리도 잡지 못했다.이러한 습관은 올해 나에게 채찍질을 할 수 있게 만든 사건을 통해 고쳐야겠다라는 생각이 들었다.그렇기에 올해 2018년 목표는 개발서적 완독을 목표로 3~4권정도로 정했다. 돈사람으로써 살아가기 위해서 필요한 것들 중 하나이다.올해목표는 작년까지는 빚에 허덕이며 살았으니, ‘올해부터는 빚청산 후 적금을 가입하자!’였다. 결론은 실패했다.이유는….너무 오래 쉬었다. 자신있게 다음 스텝을 위한 직장을 구하지 않고, 올해 중반 에이전시를 박차고 나왔다. 문제는 없었다. 다만 ‘내가 여기에서 성장할 수 없겠다.’ 라는 생각이 들어서였다.다른 곳으로 빠져나가지 않게 주제에 대해 돌아가겠다. 에이전시에 다닐때, 모든 카드빚을 청산하고 월급의 50%를 적금 및 주택청약등에 넣기 시작했다. 여기까지는 잘 이루어 졌다.하지만 생각보다 구직활동 시간이 길었다. 2~3개월이 걸렸다. 고정적을 받는 월급이 없어서 씀씀이를 줄인다고 생각하고 사용해도, 사람 씀씀이 어디안가더라…적금을 모두 해약하고 현재는 주택청약만이 남았다. 이른바 대실패다. 올해는 꼭 돈을 모으기 위해 실행 할 지켜야 할 나와의 약속을 정했다. 술 일주일에 1회 이상먹지 않기 쇼핑사이트 DM 무시하기 구매전 한번 더 생각하기이정도만 해도 정말 많은 돈을 모을 수는 없을 지언정 소비가 줄어들것이다. 그리고 내가 정해놓은 최소 연봉….받기….제일 중요하다.IT업계가 임금이 짠건 대한민국에 소문이 났나보다.하다못해 건설업계에 있는 친구가 비중있는 역할은 아닌데, 지금 너보다 많이 벌꺼야 하고 추천해준적.버스회사 사무직등 많은 직업 추천이 있었다.들어보면, 비전도 없을 지언정 연봉도 별차이가 없다.IT업계는 이러한 선입견을 없애기위해 연봉을 상향하라!!! 블로그의 시작이전에도 트랜드….를 통해 블로그를 시작한 적이 있다. 하지만 그때와 지금의 차이는 ‘남에게 보여주기 위한 블로그’와 ‘나의 필요로 인해 개설한 블로그’의 차이 일것이다.지금은 현재 내가 공부한부분을 내가 정리하므로써 빠르게 다시 머리속에서 소생시키는 역할을 중요시하여 시작하게 되었다. 공유도 중요하긴 하지만 내가 먼저 알아야한다.스터디를 통해 알게 된 Y군을 통해 hexo로 블로그를 개설하고, 초반 시작은 좋았다.하지만 게으름이 점점시작하고, 블로그포스팅이 없어졌다. 그렇기에 반성해야한다.올해는 최대한 공부한것들을 포스팅하도록 해야겠다.목표는 최소 2주 1포스팅 이상이다. 최소목표 이므로 더 많이 해야겠다라는 생각이 지금은 확고하다.작은 것이라도 모든 공부한것을 기록해 두어야겠다. 인간관계올해 최대 위안거리이다. 해가 가면 갈수록 나이를 먹으면 먹을수록 인간관계가 점점 좁아진다고들 한다.이점에 대해서 올해는 절대 아니었다 라고 말할 수 있다. 좋은 직장동료를 만나 퇴사한 지금까지 함께 개발에 대한 고민을 나눌 수 있는 좋은 친구같은 동생이 몇 생기고,정말 대단하다 싶은 정도의 분도 알게 되었고, 그전에 진행하던 스터디를 통해 만났던 사람들과도 좋은 관계를 유지하고 있다.또한 새로 입사한 회사에서 좋은 팀원들을 만났다.(현재는 해체된상태) 이를통해 올해의 그나마 인간관계를 더 넓히고, 좋은 인맥을 얻었다는 것에 위안거리를 삼을 수 있을 것 같다. 총평올해는 실패한 한해라고 생각이 들진 않는다. 그만큼 아픔도 많았지만 기쁨도 많았던 한해였다.물론 직업적인 부분을 따졌을때 자리를 잡지 못한 부분은 아쉽다.(현재 회사가 생존의 존폐위기)개발적인 목표들을 이루지 못하고, 나쁜 습관 같은 부분도 고치지 못하였다.하지만 그만큼 배우고 느끼고 경험한 것들이 많기에 올해가 나쁘지 않았다.그리고 올해를 통해 앞자리가 바뀌었다. 그만큼 책임감이 더생기고, 더많은 노력을 해야한다. 2018년은 부디 원하는걸 모두까지는 아니더라도 거의 이루는 한해가 되야한다.","categories":[{"name":"Column","slug":"Column","permalink":"https://tuhbm.github.io/categories/Column/"}],"tags":[{"name":"UI개발","slug":"UI개발","permalink":"https://tuhbm.github.io/tags/UI%EA%B0%9C%EB%B0%9C/"},{"name":"UI-developer","slug":"UI-developer","permalink":"https://tuhbm.github.io/tags/UI-developer/"},{"name":"웹퍼블리셔","slug":"웹퍼블리셔","permalink":"https://tuhbm.github.io/tags/%EC%9B%B9%ED%8D%BC%EB%B8%94%EB%A6%AC%EC%85%94/"},{"name":"프론트엔드개발","slug":"프론트엔드개발","permalink":"https://tuhbm.github.io/tags/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EA%B0%9C%EB%B0%9C/"},{"name":"front-end-developer","slug":"front-end-developer","permalink":"https://tuhbm.github.io/tags/front-end-developer/"},{"name":"javascript","slug":"javascript","permalink":"https://tuhbm.github.io/tags/javascript/"},{"name":"gulp","slug":"gulp","permalink":"https://tuhbm.github.io/tags/gulp/"},{"name":"task runner","slug":"task-runner","permalink":"https://tuhbm.github.io/tags/task-runner/"}]},{"title":"vue 알아보기 4편","slug":"vue4","date":"2017-09-20T14:13:27.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2017/09/20/vue4/","link":"","permalink":"https://tuhbm.github.io/2017/09/20/vue4/","excerpt":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. Vue.component우리는 SPA(single page application)을 제작할때 컴포넌트를 만들고 재사용하는 방법을 일반적으로 많이 사용합니다.그만큼 컴포넌트를 만드는 것이 중요합니다.이번에는 Vue를 이용해서 컴포넌트를 만드는 방법을 알아보겠습니다.기존의 방식과 같이 뷰 프레임워크를 연동 후 부터 진행을 해보겠습니다.","text":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. Vue.component우리는 SPA(single page application)을 제작할때 컴포넌트를 만들고 재사용하는 방법을 일반적으로 많이 사용합니다.그만큼 컴포넌트를 만드는 것이 중요합니다.이번에는 Vue를 이용해서 컴포넌트를 만드는 방법을 알아보겠습니다.기존의 방식과 같이 뷰 프레임워크를 연동 후 부터 진행을 해보겠습니다. app.js파일을 살펴보겟습니다.컴포넌트를 만드는 가장 쉬운 방법은Vue.component(컴포넌트이름,리턴할객체)의 형태입니다.실제 만들어 보겠습니다. 123456789101112131415161718192021222324252627Vue.component(&#x27;greeting&#x27;,&#123; template:&#x27;&lt;p&gt; 안녕하세요. 저는 &#123;&#123;name&#125;&#125;. &lt;button @click=&quot;changeName&quot;&gt;이름바꾸기&lt;/button&gt;&lt;/p&gt;&#x27;, data:function()&#123; return &#123; name:&#x27;태균&#x27; &#125; &#125;, methods:&#123; changeName:function()&#123; this.name = &#x27;현석&#x27; &#125; &#125;&#125;);new Vue(&#123; el:&#x27;#app-one&#x27;, data:&#123; &#125;, methods:&#123;&#125;, computed:&#123;&#125;&#125;);new Vue(&#123; el:&#x27;#app-two&#x27;, data:&#123;&#125;, methods:&#123;&#125;, computed:&#123;&#125;&#125;); 이제 html에서 사용해보도록 하겠습니다. 12345678&lt;div id=&quot;app-one&quot;&gt; &lt;h2&gt;Vue app one&lt;/h2&gt; &lt;greeting&gt;&lt;/greeting&gt;&lt;/div&gt;&lt;div id=&quot;app-two&quot;&gt; &lt;h2&gt;Vue app two&lt;/h2&gt; &lt;greeting&gt;&lt;/greeting&gt;&lt;/div&gt; 랜더링은 잘되었습니다.각각의 컴포넌트가 연결이 잘되었는지 확인해보겠습니다.클릭시 각각 이벤트가 진행되는 컴포는트가 완성되었음을 확인 할 수 있습니다. refsref는 한국어번역 vue을 살펴보면 ref는 엘리먼트 또는 자식 컴포넌트에 대한 참조를 등록하는데 사용합니다.참조는 부모 컴포넌트의 $refs 객체 아래에 등록됩니다.일반 DOM 엘리먼트에서 사용되는 경우 참조는 해당 엘리먼트입니다.하위 컴포넌트에서 사용되는 경우 참조는 컴포넌트 인스턴스 입니다. 이렇게 표현되어있습니다.쉽게말해 ref어트리뷰트 이용해 scope안에 있는 자식들은 참조하고, $refs를 통해 객체를 활용할 수 있다는 말입니다.실제 사용을 해보겠습니다. 123456&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;Refs&lt;/h2&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;button @click=&quot;readRefs&quot;&gt;Submit&lt;/button&gt; &lt;p&gt;당신이 좋아하는 음식은 무엇인가? :&#123;&#123;output&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; output:&#x27;&#x27; &#125;, methods:&#123; readRefs:function()&#123; console.log(this.$refs); this.output = this.$refs.input.value; &#125; &#125;&#125;); 이제 input[type=text]에 글을 입력하면, 밑에 답변이 적히게 됩니다.그리고 콘솔의 영역을 살펴보도록 하겠습니다.보시면 우리가 원하는 결과물이 나오는것을 확인하실 수 있습니다.콘솔영역을 살펴보면 input이 찍히고 우리가 입력한 ‘새우’가 value값에 찍히는 것을 확인 할 수 있습니다.스코프내에 엘리먼트를 조정할수도 있습니다. 1234567&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;Refs&lt;/h2&gt; &lt;input type=&quot;text&quot; ref=&quot;input&quot;&gt; &lt;button @click=&quot;readRefs&quot;&gt;Submit&lt;/button&gt; &lt;p&gt;당신이 좋아하는 음식은 무엇인가? :&#123;&#123;output&#125;&#125;&lt;/p&gt; &lt;div ref=&quot;test&quot;&gt;Vue ref를 공부해보자.&lt;/div&gt;&lt;/div&gt; 123456789101112new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; output:&#x27;&#x27; &#125;, methods:&#123; readRefs:function()&#123; console.log(this.$refs.test.innerText); this.output = this.$refs.input.value; &#125; &#125;&#125;); 제대로 된 값이 console.log에 찍히는것을 확인 할 수 있습니다.이처럼 ref를 이용해 참조를 통해 간단한 값을 뽑아내거나 이벤트를 발생시키도록 합니다. vue-cli설치우리는 Vue를 이용한 프로젝트를 구성할때 하나하나 모든 설정을 해야합니다.하지만 이를 간단하게 줄일 수 있는 방법이 있습니다.NPM(Node Package Module)을 이용한 방법입니다.node를 이용한 방법으로 vue도 설치하고, 빌드도구 등의 작업등을 쉽게 할수 있습니다. 일반적으로 GUI(graphic user interface)를 이용하는 방법도 있겠지만,Window에서는 CMD창을Mac OS에서는 터미널을 이용하여 text를 입력하여 사용가능합니다.(node 및 vue가 설치되어있다는 가정하에 진행하겠습니다.) vue-cli를 설치하기위서는 우선 npm install -g vue-cli 명령어를 통해 설치합니다.그런 후 프로젝트를 생성합니다. vue init vue init template-name project-name 을 통해 프로젝트를 생성합니다. template-name설명 링크 를 통해 템플릿네임에 대해 알아보세요. vue init webpack-simple vuejs-playlist저는 이렇게 생성하였습니다. 프로젝트 생성 후에는 생성된 프로젝트 내에 package.json의 module을 인스톨해야합니다. npm install npm install 명령어를 입력하면그림과 같이 package.json의 기록되어있는 모듈이 설치됩니다.설치가 완료된 후 파일들을 살펴보겠습니다.기본 구조입니다.Vue는 기본으로 javascript는 ES6문법을 사용하므로, ES6문법을 ES5문법으로 변경하기위해 babel을 사용하므로 babel설정파일 그리고 웹팩 설정파일등등이 구성되어 있습니다. npm run dev현재 작업내용을 확인하기위해 live server를 띄우며 작업을 확인 할 수 있습니다. npm run dev 를 통해 확인할 수 있습니다. 이처럼 현재 기본 템플릿형태가 나오는 것을 확인 할 수 있습니다.이제 Vue를 이용해서 본인의 작업을 완성해보세요 오늘은 Vue.component refs vue-cli설치 vue init npm install npm run dev 에 대해 배웠습니다.Vue 공부를 통해 지속적인 포스팅 하도록 하겠습니다. 감사합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"Vue.component","slug":"Vue-component","permalink":"https://tuhbm.github.io/tags/Vue-component/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://tuhbm.github.io/tags/vue-cli/"},{"name":"vue init","slug":"vue-init","permalink":"https://tuhbm.github.io/tags/vue-init/"},{"name":"npm install","slug":"npm-install","permalink":"https://tuhbm.github.io/tags/npm-install/"},{"name":"npm run dev","slug":"npm-run-dev","permalink":"https://tuhbm.github.io/tags/npm-run-dev/"},{"name":"vue.js2","slug":"vue-js2","permalink":"https://tuhbm.github.io/tags/vue-js2/"},{"name":"refs","slug":"refs","permalink":"https://tuhbm.github.io/tags/refs/"}]},{"title":"vue 알아보기 3편","slug":"vue3","date":"2017-09-19T14:58:26.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2017/09/19/vue3/","link":"","permalink":"https://tuhbm.github.io/2017/09/19/vue3/","excerpt":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. computed계산된 속성을 바인딩할때 사용. computed 사용법123456new Vue(&#123; el:&#x27;#app&#x27;, data:&#123;&#125;, methods:&#123;&#125;, computed:&#123;&#125;&#125;);","text":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. computed계산된 속성을 바인딩할때 사용. computed 사용법123456new Vue(&#123; el:&#x27;#app&#x27;, data:&#123;&#125;, methods:&#123;&#125;, computed:&#123;&#125;&#125;); 이처럼 computed의 메소드를 추가하여 사용할 수 있습니다. computed와 methods의 차이지난 1편 을 통해 함수를 methods의 메소드안에 입력한다고 배웠습니다.하지만 이번시간에 배우는 computed와의 차이는 무엇일까요?예를 들어 살펴보겠습니다. 먼저methods에 함수를 추가하여 입력해보겠습니다. 123456&lt;button v-on:click=&quot;a++&quot;&gt;Add to A&lt;/button&gt;&lt;button v-on:click=&quot;b++&quot;&gt;Add to B&lt;/button&gt;&lt;p&gt;A - &#123;&#123; a &#125;&#125;&lt;/p&gt;&lt;p&gt;B - &#123;&#123; b &#125;&#125;&lt;/p&gt;&lt;p&gt;Age + A = &#123;&#123; addToA &#125;&#125;&lt;/p&gt;&lt;p&gt;Age + B = &#123;&#123; addToB &#125;&#125;&lt;/p&gt; html에 연결을 해보겠습니다. 12345678910111213141516new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; age:29, a:0, b:0 &#125;, methods:&#123; addToA: function()&#123; return this.a + this.age &#125;, addToB: function()&#123; return this.b + this.age &#125; &#125;&#125;); 결과를 살펴보도록 하겠습니다.에러가 조금있지만데이터 a와 b의 값은 잘들어가 있습니다.함수값을 바인딩 했던 부분에 문제가 있습니다.하지만 data값을 바인딩한곳은 이벤트도 잘 일어나는 것을 확인할 수 있습니다.무엇이 문제일까요?이번에는 computed 메소드에 함수를 넣어보겠습니다. 12345678910111213141516new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; age:29, a:0, b:0 &#125;, computed:&#123; addToA: function()&#123; return this.a + this.age &#125;, addToB: function()&#123; return this.b + this.age &#125; &#125;&#125;); 보시는 바와같이 계산이 된값이 랜더링 되는 모습을 보실수 있습니다.이벤트도 잘 작동됩니다.차이는 무엇일까요? 차이는 렌더링시 함수를 미리 계산해서 적용할수 있느냐 없느냐의 차이입니다.methods의 입력함 함수는 랜더링시 바로 본인을 계산하지 못한다는것인데요.반면 computed의 에 입력한 함수는 미리 계산을 해서 캐싱해둔다는것입니다. 한마디로 정리를 하면,“랜더링 시 methods는 계산을 하지못한다. 그러므로 계산된 속성을 캐싱해두는 computed를 사용해야한다.”라고 정리할 수 있습니다. v-if2편 을 통해 우리는 토글 이벤트를 만들어보았습니다.그때 방식은 class명을 추가 제거하는 방식으로 진행했습니다.하지만 이번에는 v-if 어트리뷰트를 통해 돔을 조작하는 방법을 사용해보겠습니다. 123&lt;button @click=&quot;error = !error&quot;&gt;Toggle Error&lt;/button&gt;&lt;p v-if=&quot;error&quot;&gt;error&lt;/p&gt;&lt;p v-else=&quot;!error&quot;&gt;Success&lt;/p&gt; 123456new Vue(&#123; el:&quot;#app&quot;, data:&#123; error:false &#125;&#125;); v-if를 통해 data의 error의 값을 true와 false값을 변경하는 형태입니다.v-if 뿐만아니라 v-else를 통해 data값에 따라 돔을 조작하는 방법입니다.(v-else=”!error”에 값을 넣어주었지만 비워놓아도 작동을 합니다.) v-showv-show를 이용해서도 이벤트를 발생시킬 수있습니다. 예를 들어보겠습니다. 1234&lt;button @click=&quot;error = !error&quot;&gt;Toggle Show Error&lt;/button&gt;&lt;button @click=&quot;success = !success&quot;&gt;Toggle Show Success&lt;/button&gt;&lt;p v-show=&quot;error&quot;&gt;show error :)&lt;/p&gt;&lt;p v-show=&quot;success&quot;&gt;show success :)&lt;/p&gt; 1234567new Vue(&#123; el:&quot;#app&quot;, data:&#123; error:false, success:false &#125;&#125;); v-show를 통해 데이터에 값에 접근해 true &amp; false값을 확인하여 돔의 style중 display속성을 none과 block형태를 토글하는 것을 볼 수 있습니다. v-if와 v-show의 차이그렇다면 v-if와 v-show를 이용해 둘다 토글이벤트등을 발생시킬 수 있습니다.매우 자주 사용할 것입니다. display를 통해서 또는 dom조작을 통해서 컨텐츠를 표현하는 것은 텝, 메뉴 등등에서 매우 자주 사용하는 이벤트입니다. 그렇다면 차이는 무엇일까요?바로 v-show는 스타일(display)조작v-if는 돔자체를 생성하고 제거 하는 조작이정도의 차이입니다. 평소에 어떤 방법을 사용하느냐에 따라 렌더링이나 성능에 영향을 줄수 있으므로 잘판단해서 사용하는 냉철한 판단이 있어야겠죠? v-forvanilla js를 통해 우리는 데이터를 받아 랜더링 할때 주로 이런방법을 사용했습니다. 123456789101112131415var data = &#123; ninjas:[ &#123;name:&#x27;Ryu&#x27;,age:25&#125;, &#123;name:&#x27;Youshi&#x27;,age:35&#125;, &#123;name:&#x27;Ken&#x27;,age:55&#125; ]&#125;function write()&#123; var html = &#x27;&#x27;; for(var i =0; i &lt; data.ninjas.length; i++)&#123; html += &#x27;&lt;li&gt;&#x27;+data.ninjas[i].name+&#x27;,&#x27;+data.ninjas[i].age+&#x27;&lt;/li&gt;&#x27; &#125; console.log(html);&#125; 이러한 힘든 과정을 통해서 데이터를 바인딩해왔습니다. 그렇지만 우리는 Vue의 v-for어트리뷰트를 통해 쉽게 데이터를 바인딩 할 수 있습니다.예제를 통해 살펴보겠습니다. 먼저 데이터형태를 보겠습니다 12345678910111213new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; characters:[&#x27;Mario&#x27;,&#x27;luigi&#x27;,&#x27;Yoshi&#x27;,&#x27;Bowser&#x27;], ninjas:[ &#123;name:&#x27;Ryu&#x27;,age:25&#125;, &#123;name:&#x27;Youshi&#x27;,age:35&#125;, &#123;name:&#x27;Ken&#x27;,age:55&#125; ] &#125;, methods:&#123;&#125;, computed:&#123;&#125;&#125;); 데이터 형태는 객체에 배열,객체에 배열에 객체를 또 key,value로 묶은 객체가 들어가 있는 형태 두가지로 준비했습니다.html에 랜더링 시켜보겠습니다. 123456789&lt;ul&gt; &lt;!--&lt;li v-for=&quot;character in characters&quot;&gt;&#123;&#123;character&#125;&#125;&lt;/li&gt; 원래는 이렇게 사용--&gt; &lt;!-- &lt;li v-for=&quot;x in characters&quot;&gt;x&lt;/li&gt; 이렇게 변수 명을 바꿔서도 사용가능--&gt; &lt;li v-for=&quot;(x,index) in characters&quot;&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;x&#125;&#125;&lt;/li&gt;&lt;!-- 이처럼 자동으로 인덱스도 계산이 가능 --&gt;&lt;/ul&gt;&lt;ul&gt; &lt;!--&lt;li v-for=&quot;ninja in ninjas&quot;&gt;&#123;&#123;ninja.name&#125;&#125; - &#123;&#123;ninja.age&#125;&#125;&lt;/li&gt;--&gt; &lt;li v-for=&quot;(ninja,index) in ninjas&quot;&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;ninja.name&#125;&#125; - &#123;&#123;ninja.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 결과를 보도록 하죠.이 처럼 똑똑한 우리 Vue!! 데이터를 ul&gt;li의 구조가 아닌 다른 형태로도 렌더링 시켜보겠습니다.특별한 태그에 바인딩 시키는것이아니라 단순 구조 반복이라면,template 이라는 가상 태그를 이용해서 바인딩이 가능합니다.데이터는 위의 것과 같은 것을 사용하겠습니다. 123456789&lt;template v-for=&quot;(ninja,index) in ninjas&quot;&gt; &lt;h3&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;ninja.name&#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123;ninja.age&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;template v-for=&quot;ninja in ninjas&quot;&gt; &lt;div v-for=&quot;(val,key) in ninja&quot;&gt; &lt;p&gt;&#123;&#123;key&#125;&#125; - &#123;&#123;val&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 결과를 보겠습니다.이것처럼 특정 태그에 바인딩시키는 것이 아니면 template 가상태그를 사용하면 된다는 것 기억해주세요. 오늘은 computed computed 사용법 computed와 methods의 차이 v-if v-show v-if와 v-show의 차이 v-for 에 대해 배웠습니다.Vue 공부를 통해 지속적인 포스팅 하도록 하겠습니다. 감사합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue.js2","slug":"vue-js2","permalink":"https://tuhbm.github.io/tags/vue-js2/"},{"name":"methods","slug":"methods","permalink":"https://tuhbm.github.io/tags/methods/"},{"name":"computed","slug":"computed","permalink":"https://tuhbm.github.io/tags/computed/"},{"name":"v-if","slug":"v-if","permalink":"https://tuhbm.github.io/tags/v-if/"},{"name":"v-show","slug":"v-show","permalink":"https://tuhbm.github.io/tags/v-show/"},{"name":"v-for","slug":"v-for","permalink":"https://tuhbm.github.io/tags/v-for/"}]},{"title":"vue 알아보기 2편","slug":"vue2","date":"2017-09-18T17:02:20.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2017/09/18/vue2/","link":"","permalink":"https://tuhbm.github.io/2017/09/18/vue2/","excerpt":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. v-onv-on 어트리뷰트를 통해 이벤트를 발생시킬 수 있습니다.그리고약어 [ @ ] 를 통해 단축이 가능합니다. 12&lt;button v-on:click.once=&quot;Function&quot;&gt;이벤트&lt;/button&gt;&lt;button @click.once=&quot;Function&quot;&gt;이벤트&lt;/button&gt;","text":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. v-onv-on 어트리뷰트를 통해 이벤트를 발생시킬 수 있습니다.그리고약어 [ @ ] 를 통해 단축이 가능합니다. 12&lt;button v-on:click.once=&quot;Function&quot;&gt;이벤트&lt;/button&gt;&lt;button @click.once=&quot;Function&quot;&gt;이벤트&lt;/button&gt; keyboard event123&lt;input type=&quot;text&quot; v-on:keyup=&quot;logName()&quot;&gt;&lt;!-- keyup 이벤트가 발생할때마다 logName 함수실행 --&gt;&lt;input type=&quot;text&quot; v-on:keyup.enter=&quot;logName()&quot;&gt;&lt;!-- enter를 눌렀을때마다 logName 함수실행 --&gt;&lt;input type=&quot;text&quot; v-on:keyup.alt,enter=&quot;logName()&quot;&gt;&lt;!-- alt키와 enter를 눌렀을때마다 logName 함수실행 --&gt; mouse eventmousemove키보드 이벤트와 마찬가지로 마우스 이벤트도 가능합니다. 1&lt;div id=&quot;canvas&quot; v-on:mousemove=&quot;updataXY&quot;&gt;&#123;&#123;x&#125;&#125;,&#123;&#123;y&#125;&#125;&lt;/div&gt; 선언 후 12345678910111213new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; x:0, y:0 &#125;, methods:&#123; updataXY:function(event)&#123; this.x = event.offsetX; this.y = event.offsetY; &#125; &#125;&#125;); 이렇게 마우스의 현재값(offset)값을 알려주는 이벤트도 발생시킬 수 있습니다. click1&lt;button v-on:click=&quot;minus(1)&quot;&gt;1년빼기&lt;/button&gt; dblclick12&lt;button v-on:dblclick=&quot;minus(10)&quot;&gt;10년빼기&lt;/button&gt;&lt;!-- 클릭이벤트 앞에 dbl을 붙여주므로써 더블클릭시 이벤트가 발생하도록 할수있다 --&gt;&lt;button @dblclick=&quot;add(10)&quot;&gt;10년더하기&lt;/button&gt; once1&lt;button @click.once=&quot;add(1)&quot;&gt;1년더하기&lt;/button&gt; &lt;!-- once를 통해 한번만 실행되게 할 수 있다 --&gt; preventa태그 클릭시 링크되는기능을 막아줄 수 있다. 1e.preventDefault(); 보통 우리는 a태그시 링크되는것을 막기위해서 위와같은 방법을 사용했었다. 하지만 Vue에서는 prevent를 통해 이를 수행 할 수 있다. 1&lt;a v-on:click.prevent=&quot;click()&quot; href=&quot;https://tuhbm.github.io&quot;&gt;블로그 바로가기&lt;/a&gt; 를 html에서 설정할 수 있다는것이다. 더많은 v-on 한국어 설명은 링크를 통해 확인 v-bind1편 에서도 잠시 소개해 드린 v-bind 어트리뷰트는 동적으로 하나 이상의 컴포넌트 속성 또는 표현식을 바인딩 합니다.클래스나 스타일을 넣을때도 많이 사용됩니다.그리고약어 [ : ] 를 통해서 줄일 수도 있습니다.예를 들어 1234&lt;div v-bind:class=&quot;className&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;className&quot;&gt;&lt;/div&gt;&lt;div v-bind:style=&quot;display:none&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;display:none&quot;&gt;&lt;/div&gt; 이런식으로 사용이 가능합니다. class binding클래스를 바인딩 할때 아래와같은 표현도 가능합니다. 12&lt;div v-bind:class=&quot;&#123;red:true, blue:true&#125;&quot;&gt;&lt;/div&gt;&lt;div v-bind:class=&quot;&#123;red:true, blue:false&#125;&quot;&gt;&lt;/div&gt; 이렇게 표현되는것을 보실 수 있습니다.이를통해 토글이벤트도 발생시킬수 있습니다. toggle event123&lt;div v-on:click=&quot;available = !available&quot; v-bind:class=&quot;&#123;available:available&#125;&quot;&gt; &lt;span&gt;box&lt;/span&gt;&lt;/div&gt; 12345678910span&#123; background:red; display:inline-block; padding:10px; color:#fff; margin:10px 0;&#125;.available span&#123; background:green;&#125; 1234567new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; available: false, nearby: false &#125;&#125;); v-modelv-model은 2way binding에 적합한 어트리뷰트입니다.예를 들어보겠습니다. 123&lt;label for=&quot;&quot;&gt;Name:&lt;/label&gt;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;!-- v-model 어트리뷰트를 이용하면 데이터의 키에 맞게 설정됨 --&gt;&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; 오늘은 v-on keyboard event mouse event v-bind class binding toggle event v-model 에 대해 배웠습니다.Vue 공부를 통해 지속적인 포스팅 하도록 하겠습니다. 감사합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue.js2","slug":"vue-js2","permalink":"https://tuhbm.github.io/tags/vue-js2/"},{"name":"v-bind","slug":"v-bind","permalink":"https://tuhbm.github.io/tags/v-bind/"},{"name":"v-on","slug":"v-on","permalink":"https://tuhbm.github.io/tags/v-on/"},{"name":"v-model","slug":"v-model","permalink":"https://tuhbm.github.io/tags/v-model/"}]},{"title":"vue 알아보기 1편","slug":"vue1","date":"2017-09-15T12:49:08.000Z","updated":"2025-10-31T04:16:02.981Z","comments":true,"path":"2017/09/15/vue1/","link":"","permalink":"https://tuhbm.github.io/2017/09/15/vue1/","excerpt":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. Vue 시작하기Vue도 다른 프레임워크와 같이 npm 모듈을 이용해 설치해서 사용할 수 있습니다. 1&lt;script src=&quot;node_modules/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;","text":"Vue프론트엔드 개발 공부를 위해 SPA페이지 제작을 위한 Javascript 프레임워크 중 Vue를 공부해보도록하겠습니다.Vue에 대한 설명 및 장단점은 추후 포스팅하도록 하고, 지금은 사용방법에 대해서만 포스팅을 하도록 하겠습니다. Vue 시작하기Vue도 다른 프레임워크와 같이 npm 모듈을 이용해 설치해서 사용할 수 있습니다. 1&lt;script src=&quot;node_modules/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt; 이렇게 스크립트 파일로 준비해 불러오면 Vue를 사용할 준비가 되었습니다. Vue 텍스트 바인딩1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 이렇게 아이디 또는 클래스(클래스는 스타일잡을때만 사용하고, 큰단위이므로 아이디를 사용하길 권장)로 선택자를 만들어놓고 123456new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;태균&#x27; &#125;&#125;); el키값을 통해 Vue의 선택자를 지정해줍니다. 123&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Name:&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 이렇게 data안에 있는 name 객체를 바인딩 합니다. 결과를 어떨까요? 이렇게 바인딩이 되는 결과를 확인 할 수 있습니다. Vue 함수 바인딩이번에는 함수를 바인딩 해보겠습니다. 123&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;greet()&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 이렇게 greet라는 함수실행문을 바인딩하고, 1234567891011new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;태균&#x27; &#125;, methods:&#123; greet: function()&#123; return &#x27;안녕하세요&#x27; &#125; &#125;&#125;); Vue의 methods라는 객체를 통해 바인딩 할 함수를 넣습니다.결과를 볼까요?이처럼 함수가 바인딩 된 결과를 확인할 수 있습니다. 그렇다면 함수의 매개변수도 사용이 가능합니다. 1234567891011new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;태균&#x27; &#125;, methods:&#123; greet: function (time) &#123; return &#x27;안녕하세요 좋은 &#x27; + time + &#x27;입니다.&#x27;; &#125; &#125;&#125;); 1&lt;h1&gt;&#123;&#123;greet(&#x27;밤&#x27;)&#125;&#125;&lt;/h1&gt; 이렇게 입력을 해보겠습니다. 역시 매개변수 사용도 가능하다는 것을 확인해보았습니다. v-bind보통 템플릿에 데이터를 받아와 태그에 넣고 바인등을 합니다.Vue 역시 그러합니다. 태그 바인딩에 대해 알아보겟습니다.예를 들어 저의 블로그인 https://tuhbm.github.io를 태그에 넣고 추가해보겠습니다. 1234567new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;태균&#x27; website:&#x27;https://tuhbm.github.io&#x27; &#125;&#125;); 이렇게 데이터를 넣고 1&lt;a href=&quot;&#123;&#123;website&#125;&#125;&quot;&gt;&lt;/a&gt;&lt;!-- 이렇게 하면 당연히 텍스트만 연결이 됩니다.--&gt; 그렇다면 어떻게 넣어야할까요? 바로 여기서 사용할것은 바로 Vue만의 특이한 방법인 v-bind라는 어트리뷰트입니다. 1&lt;a v-bind:href=&quot;&#123;&#123;website&#125;&#125;&quot;&gt;블로그바로가기&lt;/a&gt; 이런식으로 연결을해보면 올바르게 나오는 것을 확인 할 수 있습니다. v-html태그 자체를 지정해서 넣는 방법도 있습니다. 1234567new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;태균&#x27; websiteTag:&#x27;&lt;a href=&quot;https://tuhbm.github.io&quot;&gt;블로그바로가기&lt;/a&gt;&#x27;//시멘틱한 객체이름을 지어줍니다. &#125;&#125;); 여기선 태그를 바로 바인딩 하므로 v-html이란 어트리뷰트를 사용합니다. 1&lt;p v-html=&quot;websiteTag&quot;&gt;&lt;/p&gt; 결과는? 오늘은 vue를 시작하는방법 텍스트 바인딩 함수 바인딩 v-bind v-html 에 대해 배웠습니다.Vue 공부를 통해 지속적인 포스팅 하도록 하겠습니다. 감사합니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"},{"name":"Vue","slug":"공부/Javascript/Vue","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://tuhbm.github.io/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"https://tuhbm.github.io/tags/vue-js/"},{"name":"tutorial","slug":"tutorial","permalink":"https://tuhbm.github.io/tags/tutorial/"},{"name":"vue.js2","slug":"vue-js2","permalink":"https://tuhbm.github.io/tags/vue-js2/"},{"name":"v-bind","slug":"v-bind","permalink":"https://tuhbm.github.io/tags/v-bind/"},{"name":"v-html","slug":"v-html","permalink":"https://tuhbm.github.io/tags/v-html/"},{"name":"vue를 시작하는방법","slug":"vue를-시작하는방법","permalink":"https://tuhbm.github.io/tags/vue%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/"},{"name":"텍스트 바인딩","slug":"텍스트-바인딩","permalink":"https://tuhbm.github.io/tags/%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%B0%94%EC%9D%B8%EB%94%A9/"},{"name":"함수 바인딩","slug":"함수-바인딩","permalink":"https://tuhbm.github.io/tags/%ED%95%A8%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9/"}]},{"title":"OSI7","slug":"OSI7","date":"2017-09-08T13:49:47.000Z","updated":"2025-10-31T04:16:02.976Z","comments":true,"path":"2017/09/08/OSI7/","link":"","permalink":"https://tuhbm.github.io/2017/09/08/OSI7/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. OSI 7계층면접을 보다보면, OSI 7계층에 대해 물어보는 곳이 꽤나있다.그렇게 접하게 된 OSI 7계층에 대해 네트워크 데이터 통신 책을 보며 간략히 정리를 해보았다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. OSI 7계층면접을 보다보면, OSI 7계층에 대해 물어보는 곳이 꽤나있다.그렇게 접하게 된 OSI 7계층에 대해 네트워크 데이터 통신 책을 보며 간략히 정리를 해보았다. OSI 7계층은국제표준화 단체 ISO(International Standard Organization)에서 정한 네트워크 연결 시스템이다네트워크에 연결된 호스트들은 7개층으로 모듈화된 통신기능을 갖추어야한다.먼저 HTTP프로토콜을 이용하여, 데이터를 요청하게되면, 응용계층부터 위에서 밑으로 차례로 물리계층까지 전달된다.또 데이터를 받는 과정은 반대로 물리계층부터 응용계층까지 순차적으로 밑에서부터 위로 전달된다.OSI7계층은 그림처럼 응용계층 표현계층 세션계층 전송계층 네트워크계층 데이터링크계층 물리계층이렇게 7개의 계층으로 나누어져 있습니다. 이제부터 각각 계층별로 하는 역할에 대해 알아보겠다. 응용계층응용계층은 최상위 계층으로 응용환경에서 공통적으로 필요한 기능을 다룹니다.응용환경은 범위가 매우 방대하지만 예를 들면 FTP등이 있습니다.. 표현계층계층5까지(세션계층~물리계층)까지는 데이터 전송에 관한 내용을 다룹니다.하지만 표현계층은 데이터의 의미와 표현방법을 처리합니다. 통신 양단에서 서로 이해할 수 있는 표준방식으로 데이터를 코딩하는 문제를 다룹니다. 호스트의 데이터 표현방법이 서로 다를수 있는데, 이러한 데이터를 이해할 수 있도록 적절하게 변환합니다.또 보안시 중요시 되고 있는 데이터를 암소화하는 기술,영상정보같은 대용량의 데이터크기를 압축하는 기능도 표현계층에서 처리합니다. 세션계층세션계층의 기능은 전송계층과 매우 유사합니다. 하지만 사용자가 원격파일을 전송하거나 원격 로그인등과 같은 상위적 연결개념인 세션기능을 제공하는 부분입니다.또한 송수신 호스트 사이 대화 제어등의 동작을 제어하기 위한 토큰제어,그리고 일시적인 전송장애를 해결하는 동기화기능을 제공합니다. 전송계층전송계층은 송수신 프로세스간 직접연결하는 통신기능을 합니다.전송계층의 하위계층(네트워크계층&amp;데이터링크계층)은 호스트와 호스트사이에 데이터 전송과정에서 발생하는 문제들을 다루지만,전송계층은 컴퓨터내부의 구축되는 통신당사자인 프로세스사이의 통신문제를 다룹니다.또한 사용자의 서비스 요구유형에 대한 고려, 전송 오류율, 전송속도등에대한 흐름제어기능도 제공합니다. 네트워크계층송신호스트가 전송한 데이터가 어떤경로를 통해 수신 호스트에 전달되는지를 결정하는 라우팅 문제를 다룹니다.라우팅이란 간단하게 표현하면, 데이터가 지나갈 경로를 선택해서 이동하는것을 말합니다.(경로설정)네트워크 계층에서의 전송데이터를 패킷이라 부르며,네트워크를 이용해 지나치게 많은 패킷이 전송되면, 전송속도가 떨어질수있으므로, 이를 제어하는 혼잡제어 기능도 담당합니다. 데이터 링크 계층데이터의 물리적 전송 오류를 해결합니다.상위의 네트워크 계층에 신뢰성 있는 패킷전송을 보장하여, 전송오류에 대한 부담을 줄여주고, 두 호스트간에 일대일로 직접 연결된 환경에서만 데이터를 전송합니다.이때 전송되는 데이터를 프레임이라고 부릅니다.프레임헤더에 표시되는 송수신 호스트 정보에는 LAN카드에 내장된 송수신 호스트의 MAC주소가 기록됩니다.또한 송수신 호스트사이의 전송속도 차이를 고려한 흐름제어기능도 제공합니다.그리고 물리적 오류를 감지하는 기능을 담당하며, 오류(데이터 분실 or 내용의 파손)를 감지하면 송신자가 원래데이터를 재전송으로 일반적으로 처리합니다. 물리계층물리적인 인터페이스에 관한 사항을 기술합니다.물리계층은 하드웨어 시스템으로 구현되고, 계층2 이상(응용계층~데이터링크계층)은 소프트웨어적으로 구현됩니다.물리계층에서 다루는 전송 매체의 특성은 데이터의 전송속도, 송수신 호스트사이의 클록의 동기화 방법, 물리적인 연결 형태등이 있습니다. 이처럼 네트워크 통신과정에서는 HTTP프로토콜을 이용하여 HTTP헤더에 정보를 통해, 데이터를 송수신할때 OSI7계층을 통해 데이터가 전송됨을 알 수 있다.밑에사진 HTTP프로토콜의 HTTP헤더 예시이미지 입니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"Component","slug":"Component","permalink":"https://tuhbm.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"https://tuhbm.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"}]},{"title":"Component","slug":"component","date":"2017-09-06T18:04:01.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2017/09/06/component/","link":"","permalink":"https://tuhbm.github.io/2017/09/06/component/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 컴포넌트란 무엇인가?쉬운듯 하나 어려운 IT언어…금일은 컴포넌트단위.. 컴포넌트수정..등 컴포넌트에 대해 알아보겠습니다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 컴포넌트란 무엇인가?쉬운듯 하나 어려운 IT언어…금일은 컴포넌트단위.. 컴포넌트수정..등 컴포넌트에 대해 알아보겠습니다. Component(컴포넌트)란 무엇인가?위키에서 검색을 하면 한국어로 구성요소라고 정의한다.기계적으로 봤을때 우리가 사용하는 휴대폰을 예로 들면휴대폰의 구성요소인 배터리는 하나의 컴포넌트이다.다시말에 어떤 기계나 프로그맹을 구성하는 부품정도라고 생각하면 될 것이다. 그렇다면 우리가 만드는 소프트웨어 즉 프로그래밍에서는 컴포넌트를 어떻게 사용하고 있을까? 개발자들의 컴포넌트사용우리 개발자들의 숙명 좋은 코드란 무엇일까?많은 좋은 코드들이 있겠지만, 프론트엔드개발자로써 좋은 코드의 요건중 하나는재사용이 가능한 코드일 것이다. html, css를 이용해서 텝리스트를 만든다고 가정을해보자!텝에 디자인만 조금 바뀐다면 어떻게 작업을 할 것인가?처음부터 다 다시만들것인가?여기서 좋은 개발자와 그냥 그러한 개발자가 나누어질것이다.좋은개발자라면 기존에 있는 코드에 부모의 클래스나 클래스를 추가하는 방법으로기본적으로 만들어놓은 텝을 활용할것이다. 이렇듯 기존에 있는 구성요소를 재활용 할 수 있도록 기본 컴포넌트를 잘 구성하는것이 좋은 개발의 한단계일 것 입니다. 프론트엔드개발에서의 컴포넌트 사용프론트엔드개발과정에서도 컴포넌트 단위로 코딩을 하는 경우가 많다.semantic-ui위 사이트는 우리가 원하는 컴포넌트를 만들어 공개해둔 사이트 입니다.기본적인 semantic-ui 모듈을 설치하고 가이드에 맞는 class명만 입력을 하면 사용하고자하는 컴포넌트로 변경되는 형태이다. 최근에 SPA(single page application)에서도 컴포넌트 단위 코딩을 하는 경우가 많다.이전에 말해던 semantic-ui 페이지는 React의 컴포넌트를 만든 페이지도 구성하고 있다.react semantic-ui 이처럼 컴포넌트를 잘 활용하는 것만으로 개발을 효율적으로 할 수 있다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"Component","slug":"Component","permalink":"https://tuhbm.github.io/tags/Component/"},{"name":"컴포넌트","slug":"컴포넌트","permalink":"https://tuhbm.github.io/tags/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/"}]},{"title":"doctype이란 무엇인가?","slug":"doctype","date":"2017-08-21T17:03:11.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2017/08/21/doctype/","link":"","permalink":"https://tuhbm.github.io/2017/08/21/doctype/","excerpt":"doctype이란 무엇인가?DOCTYPE이란 무엇인가. 흔히들 줄여말해 DTD라고 불리운다.DTD는 Document Type Definition의 약자이다. 즉, 문서형식을 정의해주는 것이다.HTML이 어떤 버전으로 작성되었는지 미리 선언해,웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것이 DTD입니다.","text":"doctype이란 무엇인가?DOCTYPE이란 무엇인가. 흔히들 줄여말해 DTD라고 불리운다.DTD는 Document Type Definition의 약자이다. 즉, 문서형식을 정의해주는 것이다.HTML이 어떤 버전으로 작성되었는지 미리 선언해,웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것이 DTD입니다. Strict DTD(엄격) 가장 표준이 되는 DTD입니다. 확장된 어트리뷰트를 허용하지 않습니다. 배경색 , 글자색등의 일정한 조건에 따른 어트리뷰트(bgcolor 라던가 font태그의 color속성)을 인정하지 않습니다. mhtml(mobile html)에 최적 Transitional DTD(호환) 일반적으로 가장 많이 쓰이는 DTD입니다. 확장된 어트리뷰트를 호환합니다. 각 브라우져에 따른 DTD를 호환합니다. Strict보다 로딩속도는 느립니다. Strict보다 표준안에 가깝지는 않습니다. Frameset DTD(복합) 프레임셋을 만들때 사용하는 DTD입니다. 확장 및 프레임에 사용가능한 모든 내용을 포함합니다. html 4.01 Frameset.dtd 와 동일합니다. HTML4.01의 Strict DTD(엄격) 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 엄격한 HTML4.01을 따르며, font와 같은 사용이 금지된 요소 등과 frameset 을 사용할 수 없습니다. HTML4.01의 Transitional DTD(호환) 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; font와 같은 사용이 금지된 요소 등을 사용할 수 있으나, frameset 을 사용할 수 없습니다. HTML4.01의 Frameset DTD 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; Transitional과 같으며 frameset 을 사용할 수 있습니다. XHTML1.0의 Strict DTD(엄격) 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 엄격한 XHTML1.0을 따르며, font와 같은 사용이 금지된 요소 등과 frameset 을 사용할 수 없습니다. 또한, XML의 문법 사용에 맞아야 합니다. XHTML1.0의 Transitional DTD(호환) 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; font와 같은 사용이 금지된 요소 등을 사용할 수 있으나, frameset 을 사용할 수 없습니다. 또한, XML의 문법 사용에 맞아야 합니다. XHTML1.0의 Frameset DTD 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; Transitional과 같으며 frameset 을 사용할 수 있습니다. XHTML1.1 DTD 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; XHTML 1.0 Strict과 같으나, 루비(Ruby)와 같은 모듈의 사용을 할 수 있게 합니다. HTML5 DTD 1&lt;!DOCTYPE html&gt; HTML5를 따릅니다. HTML과 XHTML의 차이 HTML DTD 종류의 선택 과거에서 현재까지 4.01과 Transitional을 많이 사용했으며, 최근의 대부분은 xml과 호환이 되는 XHTML 1.0의 Transitional을 많이 사용합니다. 최근에는 HTML5는 하위를 지원하며, 간략해졌기에 편의상 HTML5의 DTD로 즐겨 사용합니다. 표준모드와 쿼크모드 브라우저가 HTML문서를 처리를 할 경우, HTML DTD가 있으면 그에 맞는 W3C에서 정의한 방식에 따라 처리를 합니다. 이를 표준모드라고 하며, 그렇지 않은 경우를 쿼크모드라고 합니다.쿼크모드에서는 브라우저 회사마다 정의된 방식에 따르며, 그 결과에 차이를 보입니다. 대표적으로 박스모델에서 폭(width)과 높이(height)의 여백처리는 IE가 W3C의 표준과 달리 처리하기에 다른 결과를 보입니다.그러하기에 HTML DTD를 꼭 명시하여, 표준모드로 브러우저가 처리할 수 있게 해야 합니다.이것이 웹표준을 위한 첫 시작이라 봅니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"HTML","slug":"공부/HTML","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/HTML/"}],"tags":[{"name":"DTD","slug":"DTD","permalink":"https://tuhbm.github.io/tags/DTD/"},{"name":"html","slug":"html","permalink":"https://tuhbm.github.io/tags/html/"},{"name":"html doctype","slug":"html-doctype","permalink":"https://tuhbm.github.io/tags/html-doctype/"},{"name":"doc","slug":"doc","permalink":"https://tuhbm.github.io/tags/doc/"}]},{"title":"자바스트립트 함수 정리 1편","slug":"function1","date":"2017-08-17T21:50:26.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2017/08/17/function1/","link":"","permalink":"https://tuhbm.github.io/2017/08/17/function1/","excerpt":"함수정리&gt; 사용법편함수란 무엇일까요?우리는 중학교를 나왔다면, 이미 들어봤을것입니다.간단한 함수를 보며 살펴 보겠습니다. y = f(x)","text":"함수정리&gt; 사용법편함수란 무엇일까요?우리는 중학교를 나왔다면, 이미 들어봤을것입니다.간단한 함수를 보며 살펴 보겠습니다. y = f(x) 중학교 교과에서 보아왔던 간단한 함수입니다.x는 정의역y는 치역으로x라는 정의된 값을 함수에 넣으면, y라는 치역값이 나오는것입니다.이러한 함수를 자바스크립트에서도 사용하고 있습니다. 자바스크립트에서 함수는 여러 방법으로 사용될 수 있습니다. 1. 함수 표현식123var 식별자 = function()&#123; //이곳에 함수내 처리할 식을 적어주세요.&#125; 이런식으로 식별자에 함수를 대입하는 것이라고 볼 수 있습니다.식별자에 값을 대입하는 것 입니다.“값을 대입하는것인대, 왜 함수를 넣는나요..?”함수는 값입니다.우리는 함수는 치역(y)라는 값을 배출합니다.그러므로 함수는 값으로 볼 수 있습니다. 1234var practice = function(num)&#123; return num;&#125;practice(5); //5 위함수를 예로 들어보면 5를 배출하는것으로 볼 수 있습니다. 2. 함수 선언문123function 식별자()&#123; //이곳에 함수내 처리할 식을 적어주세요.&#125; 이런식으로 함수를 선언 하는 것입니다.함수표현식과는 다르게 함수를 대입하는것이 아니라 그차제가 함수인 것 입니다. 1234function practice2(num)&#123; return num;&#125;practice2(1) //1 이처럼 1을 리턴 하는것을 볼 수 있습니다.“음…그럼 함수는 값이라고 했으니 매개변수(parameter)에 함수를 넣어도 되나요?” “네 됩니다. 함수는 값이니까요.” 예를 들어보겠습니다. 12345678var practice = function(num)&#123; return num;&#125;function practice2(num)&#123; return num;&#125;///함수 표현식으로 만든 함수에 num(parameter)에 함수를 넣으면practice(practice2(5)); ///5 이처럼 매개변수(parameter)값으로 함수를 넣어도 잘 실행이 되는것을 볼 수 있습니다. 3. 생성자 함수생성자 함수는 어렵습니다.생성자 함수를 만들고,새로운 식별자에 생성자 함수를 대입하여,반복되는 함수를 줄이는 방법, 그리고 12345678910var Person = function(name) &#123; this.name = name; this.introduce = function() &#123; return &quot;Hi, my name is &quot; + this.name; &#125;;&#125;;var ktk = new Person(&#x27;ktk&#x27;);var jhk = new Person(&#x27;jhk&#x27;);console.log(ktk.introduce()); // Hi, my name is ktkconsole.log(jhk.introduce()); // Hi, my name is jhk 예제에서 Person은 생성자 함수이다.이처럼 함수는 반복될 수 있는 구조를 줄이기 위해 생성자 함수를 사용합니다. 마무리함수사용법에 대해 포스팅을 해보았는데요.함수는 값이다.함수는 반복을 줄이기위해 사용한다.이외에도 함수를 사용하는 이유는 다음번기회에 포스팅하겠습니다. 오늘의 포스팅을 마치겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"Javascript","slug":"공부/Javascript","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tuhbm.github.io/tags/javascript/"},{"name":"함수","slug":"함수","permalink":"https://tuhbm.github.io/tags/%ED%95%A8%EC%88%98/"},{"name":"function","slug":"function","permalink":"https://tuhbm.github.io/tags/function/"},{"name":"함수표현식","slug":"함수표현식","permalink":"https://tuhbm.github.io/tags/%ED%95%A8%EC%88%98%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"함수선언문","slug":"함수선언문","permalink":"https://tuhbm.github.io/tags/%ED%95%A8%EC%88%98%EC%84%A0%EC%96%B8%EB%AC%B8/"},{"name":"생성자함수","slug":"생성자함수","permalink":"https://tuhbm.github.io/tags/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98/"},{"name":"new","slug":"new","permalink":"https://tuhbm.github.io/tags/new/"},{"name":"javascript function","slug":"javascript-function","permalink":"https://tuhbm.github.io/tags/javascript-function/"}]},{"title":"Image Compressor","slug":"image-compressor","date":"2017-08-16T16:17:26.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2017/08/16/image-compressor/","link":"","permalink":"https://tuhbm.github.io/2017/08/16/image-compressor/","excerpt":"이미지 압축지난번 랜더링 포스팅에 있어 클라이언트가 서버에 요청을 줄이는 것이 가장 효율적인 렌더링을 하는 방법이라는 것을 포스팅했습니다.지난포스팅 1편 다시보기지난포스팅 2편 다시보기 랜더링에 있어 요청을 줄이는 것 만큼 중요한것이 있다.바로 이미지","text":"이미지 압축지난번 랜더링 포스팅에 있어 클라이언트가 서버에 요청을 줄이는 것이 가장 효율적인 렌더링을 하는 방법이라는 것을 포스팅했습니다.지난포스팅 1편 다시보기지난포스팅 2편 다시보기 랜더링에 있어 요청을 줄이는 것 만큼 중요한것이 있다.바로 이미지 우리가 입력한 코드들은 문자이므로 코드용량 굉장히 작은 크기이다.하지만 이미지는 굉장히 다양하게도 큰용량을 차지한다.많은 컬러 또 크기에 따라 용량차이는 천차만별이다. 이러한 이미지는 랜더링에도 굉장히 많은 영향을 미친다.그렇기때문에 많은 회사들에서는 요청을 줄이기위해 스트라이프 이미지를 만들고,스트라이트만들기 웹사이트그 후에 압축을 한다.압축!!! 압축은 말그래로 용량을 줄이는 것 입니다.하지만 압축은 이미지를 손상시키지 않는 선에서 압축을 해야하는데요.압축을 빌드툴을 이용해서 하는 방법도 있지만, 웹사이트를 통해 압축할 수 있습니다.지금 부터 소개해드리겠습니다. 직접 예시를 들어 설명을 해보겠습니다.오늘의 예제이미지가로 - 3720px세로 - 2138px용량 - 7.4MB의 이미지 파일입니다.의 구글 지도 이미지 입니다. 1번. compressjpegjpg파일과 png 그리고 pdf 및 밑에 보면 gif까지 압축할수 있는 사이트입니다.실험을 통해 얼마나 압축이 되는지 확인해보겠습니다.보는바와 같이 72% 압축으로 용량을 2.1MB로 줄였습니다.보시는바와같이 파일이름에 -min.확장자명 이 자동으로 붙습니다.이사이트는 최근까지 제가 가장 많이 사용하던 사이트입니다. 2번. iloveimg이미지를 압축 및 확장자 변환 및 사이즈 조절까지 가능한 사이트입니다.실험을 통해 얼마나 압축이 되는지 확인해보겠습니다.보는바와 같이 74% 압축으로 용량을 1.94MB로 줄였습니다.보시는바와같이 파일이름에 -iloveimg-compressed.확장자명 이 자동으로 붙습니다. 3번. imagesmallerjpg파일과 png 그리고 pdf 및 밑에 보면 gif까지 압축할수 있는 사이트입니다.실험을 통해 얼마나 압축이 되는지 확인해보겠습니다.보는바와 같이 78.67% 압축으로 용량을 1.51MB로 줄였습니다.파일이름에 자동으로 붙는 확장자명이 없습니다. 4번. compressorjpg파일과 png 그리고 pdf 및 밑에 보면 gif까지 압축할수 있는 사이트입니다.실험을 통해 얼마나 압축이 되는지 확인해보겠습니다.보는바와 같이 78% 압축으로 용량을 1.63MB로 줄였습니다.파일이름에 자동으로 -compressor.확장자명 이 붙습니다. 5번. tinypng이름은 tinypng라 png 파일만 압축 할 수 있나 생각 할 수 있지만,jpg도 가능합니다.위 파일을 보면 아쉽게도 무료버전은 5MB까지만 지원이되고,유료버전은 전부 다 지원이 됩니다.하지만 방법이있죠!!!다른 사이트에서 압축한 파일을 tinypng를 통해 재압축을하면 가능합니다.개인적으로 tinypng가 완전 무료면 좋겠지만, 그렇지 않습니다.tinypng는 최고의 압축률로 다른 사이트에서 압축한 이미지도 압축을 통해 용량을 확 줄여줍니다.들리는 소문에 의하면 sk 플래닛의 11번가 사이트에서도 tinypng를 통해 압축을 한다고 들었습니다. 마무리하며제 포트폴리오사이트는 굉장히 이미지가 많고, 이미지의 용량이 매우 커서 렌더링 이슈가 굉장히 큰사이트였습니다.하지만 이미지 용량을 줄이는 것만으로 7초정도의 렌더링시간을 2초정도 줄였습니다.이처럼 이미지 압축을 통해서도 사용자에서 빠른 페이지를 제공 할 수 있습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"ETC","slug":"공부/ETC","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/ETC/"}],"tags":[{"name":"image","slug":"image","permalink":"https://tuhbm.github.io/tags/image/"},{"name":"rendering","slug":"rendering","permalink":"https://tuhbm.github.io/tags/rendering/"},{"name":"image optimization","slug":"image-optimization","permalink":"https://tuhbm.github.io/tags/image-optimization/"},{"name":"compressor","slug":"compressor","permalink":"https://tuhbm.github.io/tags/compressor/"},{"name":"image compressor","slug":"image-compressor","permalink":"https://tuhbm.github.io/tags/image-compressor/"}]},{"title":"rendering 2편","slug":"rendering2","date":"2017-08-14T16:00:37.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2017/08/14/rendering2/","link":"","permalink":"https://tuhbm.github.io/2017/08/14/rendering2/","excerpt":"브라우저 렌더링에 영향을 주는 build 도구란 무엇인가?보통 많이 들 사용하는 대표적인 빌드도구는 gulp, grunt, webpack등이 있다.이러한 빌드도구는 업무의 효율성에서도 탁월하게 도움을 준다. 본인은 gulp와 webpack를 모두 조금씩 사용해보고, gulp를 더 자주 사용하고 있다.이유는 webpack은 webpack2를 넘어 webpack3까지나면서 문법을 사용하는 방식도 달라지도 있기때문에,설정을 하는데 조금 어려움이 있다.그러한이유로 gulp를 사용하는것이 더 편하다고 느껴 gulp를 사용하고있다.","text":"브라우저 렌더링에 영향을 주는 build 도구란 무엇인가?보통 많이 들 사용하는 대표적인 빌드도구는 gulp, grunt, webpack등이 있다.이러한 빌드도구는 업무의 효율성에서도 탁월하게 도움을 준다. 본인은 gulp와 webpack를 모두 조금씩 사용해보고, gulp를 더 자주 사용하고 있다.이유는 webpack은 webpack2를 넘어 webpack3까지나면서 문법을 사용하는 방식도 달라지도 있기때문에,설정을 하는데 조금 어려움이 있다.그러한이유로 gulp를 사용하는것이 더 편하다고 느껴 gulp를 사용하고있다. 앞서 작업에 효율성에 도움을 준다고 하였는데, 대표적인 예시로는 gulp-spritesmith가 있다.이처럼 자바스크립트 모듈을 사용하여, 스프라이트 이미지를 만들어주는 것이다.이처럼 빌드도구는 필요한 모듈을 사용하여, 설정을 하고 작업에 효율성을 주는 도구이다.빌드도구를 사용하는 방법은 이번편에서 언급하지 않겠습니다. build 도구를 사용하는 이유는 무엇인가?이렇게 작업을 효율성을 주어, 스프라이트 이미지를 사용하는 이유를 아는가?전에 1편을 보신분은 마지막쯤에 언급한대로 ‘구조가 복잡하거 길면 렌더링의 영향을 주겠구나..’라는 언급을 기억하실 수 있습니다.맞습니다! 분명히 영향을 받습니다! 하지만 돔관련해서 문서가 길어서 불필요한부분이라서 렌더링의 영향은 굉장히 이후 언급할 내용에 비하면 미비하다고 할 수 있습니다.이러한 랜더링 부분에서의 더큰 영향을 주는 것에 대해 이해하려면 네트워크의 동작원리에대해 알아야 합니다. 네트워크의 기초는 기본 http프로토콜을 사용하여 데이터를 주고 받는데,자세한 부분 http프로토콜 MDN web docs를 통해 살펴보도록 합니다. 문서에서 보면 나와있겠지만, http프로토콜을 이용하여 서버와 클라이언트(사용자)가 데이터를 주고받는데,가장 많은 리소스가 소비되는 구간은 요청 구간이다. 클라이언트에서 http프로토콜을 이용하여, 서버에 데이터를 요청하면 OSI7계층 모델을 통해응용계층부터 =&gt; 표현계층 =&gt; 세션계층 =&gt; 전송계층 =&gt; 네트워크계층 =&gt; 데이터 링크계층 =&gt; 물리계층까지순차적으로 요청을 한다.그러면 요청에 의한 답변을 역순으로 준비가 되었다고 답변을 올려보내고,그후에 다시 순차적으로 데이터를 받을 준비가 되었으니 보낸달라는 요청을 보낸후에,역순으로 데이터를 주고 받는다. 자세한 네트워크 기초에 대한 이야기는 후에 포스팅을 통해 진행하도록 하겠습니다. 이 포스팅의 주제로 돌아와서,데이터를 클라이언트와 서버에서 주고 받을때 가장 많은 리소스가 소비되는 구간은 요청구간이다. 우리는 지난번에 간단히 1편을 통해 랜더링이 이루어지는 과정에 대해 알아보았습니다.html문서를 파싱해서 내려가다보면 돔을 구성하고 돔안에 컨텐츠를 파싱할때, 이때 서버에 http프로토콜을 이용하여 내려 받는 것이다.이 포인트를 기억하면 ‘음.. 그럼 컨텐츠가 적으면 적을수록 요청이 적어지니까 렌더링이 더 빨라지겠군.’ 이러한 결론이나옵니다. 맞습니다. 우리가 빌드도구를 사용하는 이유는 include 및 live server등의 기능도 있겠지만, sprite-smith를 이용해 스프라이트 이미지를 만들고,그리고 여러개로 나뉘어 있는 css, javascript문서를 하나로 합치는 부분이 가장 핵심적인 부분이라고 생각합니다. 물론 대한민국은 전세계적으로 인터넷이 빠르기로 유명합니다. 그러므로 PC에서는 그 영향이 좀 덜할지 모릅니다. 하지만 모바일환경이라면 어떨까요?모바일에서 와이파이를 사용하면 관계없겠지만,데이터가 나가는 환경이라면, 말이 달라집니다. 왜냐하면 렌더링이 늦어지면 늦어질수록 데이터는 더 많이 나갈테니까요.데이터가 많이 들면, 고객이 불편함을 느껴 서비스를 떠날수 있는 환경이 됩니다. 자사서비스를 하는 회사에선 고객이 떠나는 것 만큼 큰 손해는 없습니다.그렇기때문에 자사서비스를 하는곳에서는 더더욱 렌더링에 신경을 써야합니다.그럼 우리 front-end개발자라면 앞으로 신경써야하는 렌더링을빌드도구를 사용하여, 보다 쉽게 작업을 하고, 효율적인 렌더링을 통해 고객을 불편을 줄여줘야하는게 업무가 아닐까요? 이상으로 포스팅을 마치겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"HTML","slug":"공부/HTML","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/HTML/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://tuhbm.github.io/tags/gulp/"},{"name":"html","slug":"html","permalink":"https://tuhbm.github.io/tags/html/"},{"name":"rendering","slug":"rendering","permalink":"https://tuhbm.github.io/tags/rendering/"},{"name":"랜더링","slug":"랜더링","permalink":"https://tuhbm.github.io/tags/%EB%9E%9C%EB%8D%94%EB%A7%81/"},{"name":"브라우저","slug":"브라우저","permalink":"https://tuhbm.github.io/tags/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/"},{"name":"grunt","slug":"grunt","permalink":"https://tuhbm.github.io/tags/grunt/"},{"name":"webpack","slug":"webpack","permalink":"https://tuhbm.github.io/tags/webpack/"},{"name":"build tool","slug":"build-tool","permalink":"https://tuhbm.github.io/tags/build-tool/"}]},{"title":"rendering 1편","slug":"rendering1","date":"2017-08-10T18:51:01.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2017/08/10/rendering1/","link":"","permalink":"https://tuhbm.github.io/2017/08/10/rendering1/","excerpt":"브라우저 렌더링이 이루어지는 과정 웹을 개발하는 사람로써 웹브라우저가 렌더링 되는 과정을 이해하는 것은 필수가 아닐까합니다. 저는 왜???라는 말을 참 좋아하는데요.어떠한 행위를 할때 ‘왜?’ 라고 생각해보는 과정은 좋은 습관이라고 생각합니다.우리는 웹개발을 하는 사람으로써, 어떠한 과정에 한계를 두지 말고 지금은 모르더라도 점진적으로 알아가야 한다고 생각을 하는데요.우리가 작업을 하는 HTML, CSS, JavaScript가 렌더링 되는 과정을 이해하는 것이 매우 중요하다고 생각합니다.","text":"브라우저 렌더링이 이루어지는 과정 웹을 개발하는 사람로써 웹브라우저가 렌더링 되는 과정을 이해하는 것은 필수가 아닐까합니다. 저는 왜???라는 말을 참 좋아하는데요.어떠한 행위를 할때 ‘왜?’ 라고 생각해보는 과정은 좋은 습관이라고 생각합니다.우리는 웹개발을 하는 사람으로써, 어떠한 과정에 한계를 두지 말고 지금은 모르더라도 점진적으로 알아가야 한다고 생각을 하는데요.우리가 작업을 하는 HTML, CSS, JavaScript가 렌더링 되는 과정을 이해하는 것이 매우 중요하다고 생각합니다. 서론이 조금 길었네요. 이제 본론으로 들어가겠습니다.우리가 구현하는 브라우저는 과연 어떻게 렌더링이 될까요? 우선 ‘렌더링’ 부터 알아보도록 하겠습니다.렌더링이란?렌더링(Rendering)은 컴퓨터 프로그램을 사용하여 모델(또는 이들을 모아놓은 장면인 씬(scene) 파일)로부터 영상을 만들어내는 과정을 말한다.라고 간단하게 표현하고 있습니다.한마디로 클라이언트(사용자)에서 서버에 파일을 받아 브라우저에 뿌려주는 과정이라고 볼 수 있습니다.더 깊이 알고싶으시면 밑에 위키링크를 클릭해보세요.위키 렌더링 클라이언트란 단어는 편하게 사용자라고 이해하시면 쉬울 것 같습니다.모바일에서 접속하면, 모바일 === 클라인언트pc에서 접속하면, pc === 클라이언트인것이죠. 이는 브라우저에만 국한된 단어는 아닙니다. 그냥 사용자를 클라이언트라고 이해하시면 될 것 같습니다. 제가 활동하고 있는 커뮤니티에서 한때 잠깐 어떤 질문이 올라온적이 있는데요.질문의 내용은 html, css, javascript 렌더링 순서에 관한 질문이었습니다. 그림을 살펴보도록하죠. 그림을 보면 doctype을 시작으로 html태그가 처음 나오는것을 보실 수 있습니다.다음 meta태그, title태그 등을 지나 head태그안에 script와 link태그를 이용한 css를 불러오는 과정을 보실수 있습니다.그렇다면..과연 html, css, javascript 중 가장 먼저 렌더링 되는 것은 무엇일까요? 정답 : html맞습니다 html이 불러와 지고 그다음 css 및 javascript가 렌더링됩니다. 아 참 빼먹은 설명이 있네요.우리의 컴퓨터 및 프로그램들은좌에서 우로 그리고위에서 아래로문서를 파싱합니다. 파싱 === 문서를 읽는다 정도로 이해하시면 될 것 같습니다. 렌더링에 관련되서 많은 서적 및 우리의 친구 구글에 보면 많은 자료들이 있습니다.그중 우리 대한민국의 포탈 네이버에서도 렌더링 되는 과정에대해 설명해 놓은 자료가 있습니다.그 중 참고를 해서 보여드리면, dom트리..랜더트리…이건무슨말이다냐….ㅋㅋㅋㅋ DOM트리 란? 하나의 태그로 구성된 형태라고 보시면 될 것 같습니다. 123&lt;div&gt; &lt;p&gt;DOM트리&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 이 코드를 기준으로 설명드리면, ‘div’라는 돔이 있고, 그자식으로 ‘p’라는 돔이 ‘DOM트리’ 라는 텍스트를 가지고 있다.어떤가요. 이해하셨나요? 우리가 사용하는 태그 하나하나가 모두 DOM이 됩니다. 랜더트리 란? 쉽게표현해 html과 css 그리고 넓게 javascript까지!스타일에 관여하는 모든 문서를 파싱하고 html의 돔에 적용을 시키기 전에!그러니까 그리기 전에 기억을 해두는 것이라고 생각을 하면 편하겠네요.어떠한 DOM은 display가 block이고, 어떠한 DOM은 color가 #000이고, 이러한 과정을 각각의 돔을 실제 그리기전에 스타일을 입히는 것! 어떤가요 조금 이해 되셨나요?웹킷(크롬)과 모질라의 게코에서 설명해 놓은 그림을 보면웹킷 모질라 게코 두 그림을 보면 조금의 용어의 차이는 있지만, 결론적으로 과정을 보면 동일한것을 보실 수 있습니다. 어떤가요? 렌더링 과정 그림을 보니 조금 더 이해가 되나요..? DOM트리 와 랜더트리 과정을 보니…문서가 길수록, 구조가 복잡하면, 렌더링에 영향이 있겠구나..그렇기 때문에 불필요한 태그 및 필요없는 부분을 지우라는 것이구나..라고 생각이 들면 이번 포스팅은 성공인것 같습니다. 최적화된 렌더링에 대해 생각해보고, 실천을 하는것이 각각 프론트엔드개발자 더 발전을 이룰 수 있는 과정이 아닐까 생각이 듭니다.마지막 더 자세한 사항은 D2 브라우저렌더링를 통해 공부해보세요. 다음은 작업을 할 때 빌드도구 예를 들면 걸프나 그런트 또는 웹팩등 다양항 빌드도구를 사용하는데 사용하는 이유에 대해 설명해보겠습니다.먼저 맛보기로 설명드리면, 작업환경을 편하게 하는것 뿐만 아니라 렌더링에도 영향을 줄수 있는 작업들을 포함하고 있습니다. 그럼 이만 오늘의 포스팅을 마치겠습니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"HTML","slug":"공부/HTML","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"https://tuhbm.github.io/tags/html/"},{"name":"rendering","slug":"rendering","permalink":"https://tuhbm.github.io/tags/rendering/"},{"name":"랜더링","slug":"랜더링","permalink":"https://tuhbm.github.io/tags/%EB%9E%9C%EB%8D%94%EB%A7%81/"},{"name":"브라우저","slug":"브라우저","permalink":"https://tuhbm.github.io/tags/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/"}]},{"title":"원페이지 HTML 이력서","slug":"onePageResume","date":"2017-08-05T20:49:11.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2017/08/05/onePageResume/","link":"","permalink":"https://tuhbm.github.io/2017/08/05/onePageResume/","excerpt":"취업준비를 위해서 필요한 이력서 보통 잡코리아 또는 사람인 사이트등 잡사이트를 이용해 지원을 많이한다. 그러나 예외는 있다!!","text":"취업준비를 위해서 필요한 이력서 보통 잡코리아 또는 사람인 사이트등 잡사이트를 이용해 지원을 많이한다. 그러나 예외는 있다!! 큰기업의 경우는 자사 채용사이트에서 직접 이력서를 받기 때문에 번거롭지만…우리는 경력사항….자격증번호…. 자소설…..등 새로 작성을 해야한다. 그러던 중 내가 겪은 경험은 보통의 개발자들은 포트폴리오를 URL로 제출을 한다. 하지만 자사채용사이트에 포트폴리오 URL을 넣는 칸이 없다면 어떻게 할것인가….ㅠㅠ 그래서 준비했다 원페이지 자소서!!! 이력서 다운 바로가기 순서 git을 이용한만큼 git명령어를 좀 알아야한다. 어렵지 않다 깃이 설치되어있고, 노드가 설치되어있다는 가정하에 설명하도록 하겠다. 터미널에 저장하고 싶은 경로로 이동 잘모르겠다면……기존에 필자가 포스팅해 놓은 cli명령어 포스팅으로 이동해서 공부해보자 CLI명령어 포스팅으로 이동하기 git clone 하기 어렵지않다…그냥 복붙하는 것이라고 생각하면 된다. git clone https://github.com/tuhbm/onePage_resume.git 이렇게 입력하면 끝!!! 그리고 텍스트 수정 및 이력서 사진 변경 세부 css변경은 minify 해 놓은 파일을 beautify기능이 있는 에디터 또는 밑에 사이트에서 css mifify 변경하기 변경하여 사용하기 각각 양식에 맞추어 텍스트만 변경하면 된다. 문제는 그래프…. 그래프는 아직 템플릿화하지 못하였다. 하지만!!!!! 여러분에 능력을 믿습니다!!! 개발자도구를 열어서 css를 고쳐가면 한땀한땀 바꿔보세요(저정도는 해주셔야죠ㅋㅋㅋ) 그럼 이력서 받고 취업 성공하세요~!!","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"ETC","slug":"공부/ETC","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/ETC/"}],"tags":[{"name":"RESUME","slug":"RESUME","permalink":"https://tuhbm.github.io/tags/RESUME/"},{"name":"ONEPAGE","slug":"ONEPAGE","permalink":"https://tuhbm.github.io/tags/ONEPAGE/"},{"name":"HTML 이력서","slug":"HTML-이력서","permalink":"https://tuhbm.github.io/tags/HTML-%EC%9D%B4%EB%A0%A5%EC%84%9C/"},{"name":"원페이지 이력서","slug":"원페이지-이력서","permalink":"https://tuhbm.github.io/tags/%EC%9B%90%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9D%B4%EB%A0%A5%EC%84%9C/"},{"name":"html template resume","slug":"html-template-resume","permalink":"https://tuhbm.github.io/tags/html-template-resume/"}]},{"title":"emmet1탄","slug":"emmet1","date":"2017-07-17T15:21:35.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2017/07/17/emmet1/","link":"","permalink":"https://tuhbm.github.io/2017/07/17/emmet1/","excerpt":"오늘은 많이 사용하는 Emmet을 알아보겠습니다.많이 사용하시는 에디트플러스에서는 zen coding으로 표현하고있습니다.이러한 Emmet에 명령어에 대해 정리해보겠습니다.일반 에디트에서는 Emmet의 기능이 없어서 플러그인을 설치해야 사용이 가능하다는점!!!","text":"오늘은 많이 사용하는 Emmet을 알아보겠습니다.많이 사용하시는 에디트플러스에서는 zen coding으로 표현하고있습니다.이러한 Emmet에 명령어에 대해 정리해보겠습니다.일반 에디트에서는 Emmet의 기능이 없어서 플러그인을 설치해야 사용이 가능하다는점!!! Emmet명령어 1단 html편+ : 형제 생성 ex:)header+main+footer -호출전 -호출후 &#123;&#125; : 텍스트추가 ex:) div&#123;테스트입니다&#125; -호출전 -호출후 &gt; : 자식 생성 ex:)div&gt;ul&gt;li -호출전 -호출후 * : 갯수 ex:) a*3 -호출전 -호출후 ^ : 등반 생성(자식에서 상위로 올라가는 등반) ex:) header&gt;p^main -호출전 -호출후 () : 등반선택이 어렵다면 사용가능 ex:) header&gt;(ul&gt;li&gt;a)+main-호출전 -호출후 [속성=“속성값”] : 속성삽입 ex:) div&gt;a[href=&quot;http://tuhbm.tistory.com/&quot;] -호출전 -호출후 $ : 연속되는 숫자 ex:) ul&gt;li.item$ -호출전 -호출후 금일 포스팅한것들 통합연습 예제:) header#header&gt;a.logo[href=“http://tuhbm.tistory.com”]+div.util_wrap&gt;ul&gt;li.item$*2&gt;a^^^^^main+footer와 header#header&gt;(a.logo[href=“http://tuhbm.tistory.com”]+div.util_wrap&gt;ul&gt;li.item#*2&gt;a)+main+footer 같음 -호출후","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"HTML","slug":"공부/HTML","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/HTML/"}],"tags":[{"name":"html","slug":"html","permalink":"https://tuhbm.github.io/tags/html/"},{"name":"emmet","slug":"emmet","permalink":"https://tuhbm.github.io/tags/emmet/"}]},{"title":"scout앱 사용하여 sass컴파일하기","slug":"sass-compile","date":"2017-07-17T15:05:34.000Z","updated":"2025-10-31T04:16:02.980Z","comments":true,"path":"2017/07/17/sass-compile/","link":"","permalink":"https://tuhbm.github.io/2017/07/17/sass-compile/","excerpt":"SASS먼저 사스에 대해 다들아시겠지만 설명 드리겠습니다. Sass (Syntactically Awesome Style Sheets : 문법적으로 멋진 스타일시트)라는 뜻입니다. 사스는 기본적으로 웹에서 구현되는 언어는 아닙니다.그러므로 우리가 알고있는 스타일을 정의 해주는 언어인 CSS로 컴파일 해야 사용이 가능합니다.","text":"SASS먼저 사스에 대해 다들아시겠지만 설명 드리겠습니다. Sass (Syntactically Awesome Style Sheets : 문법적으로 멋진 스타일시트)라는 뜻입니다. 사스는 기본적으로 웹에서 구현되는 언어는 아닙니다.그러므로 우리가 알고있는 스타일을 정의 해주는 언어인 CSS로 컴파일 해야 사용이 가능합니다. 먼저 컴파일이란?원시 코드에서 목적 코드로 옮기는 과정을 컴파일이라고 합니다. 컴파일 - 위키바로가기 Sass와 Less 등의 방법으로 스타일을 보다 간결하고 편하게 작업하도록 할 수 있습니다만,최근 Less를 사용하는 곳은 줄어들고 Sass를 사용하는 곳이 많더군요. 그래서 이 포스팅에서는 Sass만 다루도록 하겠습니다. Sass를 컴파일 하는방법은 여러가지입니다. 기본적으로 ruby를 설치해서 cli를 통해 변환하는 방법 gulp or grunt or webpack 등의 빌드도구를 사용해서 컴파일하는방법 APP 또는 사이트를 이용하는 방법입니다.본 포스팅에서는 APP을 이용하는 방법을 다루겠습니다.APP에도 컴파일 가능한 방법이 여러가지 있습니다. kolal 바로가기scout app 바로가기prepros 바로가기 위에 거론한 앱말고도 찾아보면 많은 앱들이 존재합니다.하지만 유료 또는 운영체제의 문제가 발생할 수 있습니다. 그 중에 scout app을 사용하는 방법을 포스팅해보겠습니다. 강아지모양의 아이콘 앱입니다. 현재 무료로 운영체제별로 다운로드가 각각 존재하니, 운영체제별로 확인하셔서 다운로드 해주세요. 앱을 실행하면 이런형태의 모습입니다. (개인신상문제로인해 현재 이용하고 있는 프로젝트명은 가렸습니다. 양해부탁드립니다.) 지금 이미지는 프로젝트를 추가했을때의 모습입니다. Input Folder - sass 문서가 들어있는곳Output Folder - css파일로 변환되어 들어갈곳 을 정해주고 Development 체크후 Expanded를 셀렉트해주시면 일반적인 형태의 줄바꿈 형태로 컴파일되고, 확장자가 map 파일이 나옵니다.map파일은 수정시 sass파일과 연결해주어 어디부분을 수정해야하는지 개발자도구에서 볼 수 있게 해주는데요. 현재 크롬 정식버전은 아니지만 크롬 연구버전에서 사용하게 해주면 알아서 map폴더를 인식해서 sass 파일을 알려줍니다. 아참 그리고 프로젝트 명에 플레이버튼을 클릭하면 watch 모드이므로,변경시 알아서 컴파일 해주는 부분입니다. 주로 제가 사용하는방법은 Gulp를 사용하는 방법이지만, 빌드도구 접근이 어려우신 분들을 위한 포스팅지금까지 App중에 scout app으로 컴파일하는 방법이었습니다. 참고css를 sass로 변경해주는 사이트입니다. 기본적으로 거꾸로 하는것이라 정확하지는 않아 신뢰하시않으나, 혹시나 필요한분을 위해 공유드립니다. css를 sass로 변경해주는 사이트 바로가기","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"},{"name":"SASS","slug":"공부/CSS/SASS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/SASS/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://tuhbm.github.io/tags/sass/"},{"name":"SCOUT","slug":"SCOUT","permalink":"https://tuhbm.github.io/tags/SCOUT/"},{"name":"compile","slug":"compile","permalink":"https://tuhbm.github.io/tags/compile/"}]},{"title":"자주쓰는 CLI명령어","slug":"cli","date":"2017-07-17T14:55:23.000Z","updated":"2025-10-31T04:16:02.977Z","comments":true,"path":"2017/07/17/cli/","link":"","permalink":"https://tuhbm.github.io/2017/07/17/cli/","excerpt":"cli 명령어ls : 리스트출력 ls -l : 리스트 출력(사용권한,소유자,그룹,크기,날짜등 상세정보 출력) ls [폴더명]/ : 입력한 폴더의 리스트 출력 cd [폴더명] : 입력한 폴더로 이동 cd ~ : Desktop 폴더로 이동","text":"cli 명령어ls : 리스트출력 ls -l : 리스트 출력(사용권한,소유자,그룹,크기,날짜등 상세정보 출력) ls [폴더명]/ : 입력한 폴더의 리스트 출력 cd [폴더명] : 입력한 폴더로 이동 cd ~ : Desktop 폴더로 이동 cd .. : 한단계 상위폴더로 이동 mkdir [폴더명] : 폴더 생성(띄어쓰기 하고 칠경우 여러개 생성 가능) touch [파일명] : 입력한 파일생성(띄어쓰기 하고 칠경우 여러개 생성 가능) mv [파일명] [폴더명/파일명] : 파일을 입력한 폴더로 이동 mv [파일명] [변경될파일명] : 현재파일을 입력한 파일명으로 변경 pwd : 현재 작업중인 폴더의 절대경로가 출력 vim [파일명] : 파일을 수정할수있다.(저장하고 나가려면 ESC키를 누른 후 :wq{Write Quit} 명령어 실행) vimtutor : vim튜토리얼 cat [파일명] : 파일내용확인 cp [폴더명/파일명] [복제될파일명] - 폴더에 파일을 현재 폴더에 복제한다 cp -R [복제될폴더명] [복제된폴더명] - 파일을 복제한다(파일도 가능) rm [파일명] : 해당 파일을 삭제(폴더불가능)(띄어쓰기 하고 칠경우 여러개 삭제 가능)(*.[파일종류]를 입력하면 해당 파일 종류 모두를 삭제한다) rmdir [폴더명] : 폴더삭제(단, 빈폴더가아닐경우 삭제안됨) rmdir —help : rmdir 삭제 도우미 rm -rf [폴더명] : 비어있지 않은 폴더 삭제 rm —help : re명령어 도우미","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"ETC","slug":"공부/ETC","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/ETC/"}],"tags":[{"name":"CLI","slug":"CLI","permalink":"https://tuhbm.github.io/tags/CLI/"},{"name":"터미널","slug":"터미널","permalink":"https://tuhbm.github.io/tags/%ED%84%B0%EB%AF%B8%EB%84%90/"},{"name":"CMD","slug":"CMD","permalink":"https://tuhbm.github.io/tags/CMD/"}]},{"title":"한줄말줄임","slug":"oneLine-ellipsis","date":"2017-07-17T14:42:33.000Z","updated":"2025-10-31T04:16:02.979Z","comments":true,"path":"2017/07/17/oneLine-ellipsis/","link":"","permalink":"https://tuhbm.github.io/2017/07/17/oneLine-ellipsis/","excerpt":"데이터를 바인딩할, 예를 들어 게시판의 경우 정해둔 width값을 초과하는 데이터가 들어올수 있다.이를 방지하기위해 한줄말줄임을 사용해야한다.이러한 한줄 말줄임에 대해 포스팅을 해보겠다. - 적용시 알아두어야 할 것들 하나,문자열을 줄이는 대다수의 이유는 고정되고 제한된 공간을 유지하며 적절한 텍스트 표현을 하기 위한 것이기에 적용시에는 해당 영역의 width 가 고정폭인 조건이어야 합니다.","text":"데이터를 바인딩할, 예를 들어 게시판의 경우 정해둔 width값을 초과하는 데이터가 들어올수 있다.이를 방지하기위해 한줄말줄임을 사용해야한다.이러한 한줄 말줄임에 대해 포스팅을 해보겠다. - 적용시 알아두어야 할 것들 하나,문자열을 줄이는 대다수의 이유는 고정되고 제한된 공간을 유지하며 적절한 텍스트 표현을 하기 위한 것이기에 적용시에는 해당 영역의 width 가 고정폭인 조건이어야 합니다. 둘,ellipsis 사용시 CSS 지정 글꼴(Font)과 브라우저에 따라 표현되는 방식에 차이가 있습니다.통상적으로 “…” 처럼 하단에 깔려야 하지만 대부분의 브라우저에서 중앙 “—“ 영역에 노출됩니다.개인적으로 확인은 못했지만 “맑은 고딕”(웹폰트가 되겠지요?) 글꼴 사용시 대부분의 브라우저에서 우리가 원하는 결과를 얻을 수 있다고 합니다.기본 글꼴(돋움,굴림 등)로 “…” 표시를 중앙(middle)영역이 아닌 하단(bottom)에 표시하고자 한다면 프로그램단에서 처리하는 것이 효율적입니다. 셋,적용시에는 아래 두 속성도 함께 넣어줍니다. 123456div#title&#123; width:200px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; &#125; overflow:hidden;고정폭을 넘어가는 text를 숨기고 white-space:nowrap;고정폭이라도 자동 줄바꿈이 되지 않도록 합니다. text-overflow:ellipsis;고정폭을 넘을 경우 “…”를 붙여줍니다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"CSS","slug":"공부/CSS","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://tuhbm.github.io/tags/CSS/"},{"name":"한줄 말줄임","slug":"한줄-말줄임","permalink":"https://tuhbm.github.io/tags/%ED%95%9C%EC%A4%84-%EB%A7%90%EC%A4%84%EC%9E%84/"},{"name":"ellipsis","slug":"ellipsis","permalink":"https://tuhbm.github.io/tags/ellipsis/"}]},{"title":"framework 와 library","slug":"frameworkVSliblibrary","date":"2017-07-17T13:55:55.000Z","updated":"2025-10-31T04:16:02.978Z","comments":true,"path":"2017/07/17/frameworkVSliblibrary/","link":"","permalink":"https://tuhbm.github.io/2017/07/17/frameworkVSliblibrary/","excerpt":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 라이브러리와 프레임워크의 차이초보개발자로써 나와같은 고민을 하고 있는 사람이 많을것이다.세상에는 많은 용어들이 존재한다. 무역용어부터 개발용어까지…..이러한 용어중 나는 개발자로써 개발 용어에 헷갈리는 것들을 나름 이해하기 쉽게 정리해보려한다.","text":"용어정리이 카테고리는 비전공자로서 개발자로써 공부하며, 평소 이해하지 못한 단어를 제방식대로 정리하는 카테고리입니다.제방식대로 풀어 쓴것이므로 오류가 있을 수 있습니다.오류가 있을시 댓글로 남겨주시면 참고하도록 하겠습니다. 라이브러리와 프레임워크의 차이초보개발자로써 나와같은 고민을 하고 있는 사람이 많을것이다.세상에는 많은 용어들이 존재한다. 무역용어부터 개발용어까지…..이러한 용어중 나는 개발자로써 개발 용어에 헷갈리는 것들을 나름 이해하기 쉽게 정리해보려한다. 개발용어에는 많은 것들이 존재한다. 그러나 도대체 이많은 용어들은 무엇인가….?좀알았다 생각했으나..막상 설명하려면…..ㅂㄷㅂㄷ도대체 어떻게 설명해야할까…? 이번 주제는 라이브러리(Library)와 프레임워크(Framework)이다둘은 정말 많이 들어본 용어들이다. 하지만 그만큼 무지 헷갈린다. 라이브러리(Library)란 무엇인가?간단히 설명하면 대표적인 예로 가장 유명한 javascript의 라이브러리인 jQuery와 React가 있다.이러한 라이브러리는 내가 그냥 가져다 사용 할 수 있는 모듈이며 수정이 용이하다. 그렇게 때문에 내가 라이브러리를 가져다 쓴다고 생각 할 수 있다. 이러한 라이브러리를 어떤것을 사용해야 하는지 정해진것은없다. 표현하자면 톱이나 망치 같은 공구들이라고 보면 될것이다.땅을 팔때 톱을 이용해도 되고, 망치로 땅을 파도 무방하다. 다만 효율성의 차이일뿐…“그냥 사용해서 만든다.”라고 보면될것이다. 프레임워크(FrameWork)는 무엇인가?대표적인 예로는 현재 매우 핫한 Angular가 있다프레임워크는 이미 정해진 명세, 규칙이기 때문에 수정이 어렵다. 소스코드를 짤때 이 규칙을 토대로 프레임워크를 사용하므로, 프레임워크가 명시한 대로 사용 할 수 있을 뿐이다. 그래서 내가 짠 소스코드는 프레임워크에 의존하여 동작하게 하게 된다. 이것 역시 표현하자면 자동차,배,비행기같은 이용수단 표현 할 수 있다.라이브러리와 다르게 이용 수단이라고 보면 될것이다.바다를 항해하기 위해선 배를 이용해야한다. 자동차를 이용해서 항해 할순 없지 않은가?이처럼 사용용도가 정해져있고, 그것을 따라야 한다고 볼수있다. 즉 라이브러리와 프레임워크의 차이는 흐름의 키를 누가 쥐고있느냐일것이다.프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며, 사용자는 그 안에서 필요한 코드를 짜 넣는다. 반면 라이브러리는 사용자가 전체적인 흐름을 만들며, 라이브러리를 가져다 쓰는 것이다.라이브러리는 개별자가 만든 클래스에서 호출하여 사용하지만, 프레임워크는 반대로 프레임워크의 클래스가 개별자가 만든 클래스를 부른다.","categories":[{"name":"공부","slug":"공부","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/"},{"name":"용어정리","slug":"공부/용어정리","permalink":"https://tuhbm.github.io/categories/%EA%B3%B5%EB%B6%80/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/"}],"tags":[{"name":"framework","slug":"framework","permalink":"https://tuhbm.github.io/tags/framework/"},{"name":"library","slug":"library","permalink":"https://tuhbm.github.io/tags/library/"}]}]}